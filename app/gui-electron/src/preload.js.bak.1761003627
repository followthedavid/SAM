console.log('[preload] boot');
console.log('[preload] typeof require =', typeof require);
console.log('[preload] Node version =', process.versions.node, 'electron =', process.versions.electron);

const { contextBridge, ipcRenderer } = require("electron") = require("electron") = require('electron');

// Load xterm in preload context
let Terminal, FitAddon, WebLinksAddon;
try {
  ({ Terminal } = require('xterm'));
  ({ FitAddon } = require('xterm-addon-fit'));
  ({ WebLinksAddon } = require('xterm-addon-web-links'));
  console.log('[preload] xterm loaded successfully');
} catch (e) {
  console.error('[preload] xterm load failed:', e.message);
}

contextBridge.exposeInMainWorld('bridge', {
  // Sessions
  startPTY: async (opts) => ipcRenderer.invoke('pty:start', opts),
  sendInput: (id, data) => ipcRenderer.send('pty:input', { id, data }),
  resizePTY: (id, cols, rows) => ipcRenderer.send('pty:resize', { id, cols, rows }),
  killPTY: (id) => ipcRenderer.send('pty:kill', { id }),

  // Streams
  onPTYData: (cb) => ipcRenderer.on('pty:data', (_e, payload) => cb(payload)),
  onPTYExit: (cb) => ipcRenderer.on('pty:exit', (_e, payload) => cb(payload)),

  // Utilities
  copy: (text) => clipboard.writeText(text || ''),
  openExternal: (href) => ipcRenderer.send('open:external', href),
  
  // Terminal factory
  createTerminal: (container) => {
    if (!Terminal) throw new Error('xterm not available');
    
    const term = new Terminal({
      fontFamily: 'ui-monospace, Menlo, Monaco, "Cascadia Mono", monospace',
      fontSize: 13,
      allowProposedApi: true,
      theme: {
        background: '#0b0f14',
        foreground: '#e6edf3',
        cursor: '#a6da95',
        selection: '#204a72'
      },
      scrollback: 5000
    });

    const fit = new FitAddon();
    const links = new WebLinksAddon((e, uri) => ipcRenderer.send('open:external', uri));
    term.loadAddon(fit);
    term.loadAddon(links);

    term.open(container);
    fit.fit();

    return {
      write: (d) => term.write(d),
      onData: (cb) => term.onData(cb),
      clear: () => term.clear(),
      fit: () => fit.fit(),
      dispose: () => term.dispose(),
      getSelection: () => term.getSelection(),
      get cols() { return term.cols; },
      get rows() { return term.rows; }
    };
  }
});

// --- WARP_OPEN_PALETTE_FILES_MARKER ---
try {
  const fs = require('fs');
  const os = require('os');
  const path = require('path');

  function readTextFile(p) {
    try { return fs.readFileSync(p, 'utf8'); } catch { return null; }
  }
  function writeTextFile(p, data) {
    try {
      const dir = path.dirname(p);
      if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
      fs.writeFileSync(p, data, 'utf8'); 
      return true;
    } catch { return false; }
  }
  function getHomeDir() { return os.homedir(); }

  // New, separate surface (keeps existing bridge unchanged)
  contextBridge.exposeInMainWorld('files', { readTextFile, writeTextFile, getHomeDir });
} catch (e) {
  // Non-fatal; UI will degrade gracefully
  // console.error('[preload files] failed', e);
}
// --- WARP_OPEN_PALETTE_FILES_MARKER ---

// --- tabs/events bridge (append) ---
contextBridge.exposeInMainWorld('tabs', {
  new: (initialCmd) => ipcRenderer.invoke('app:new-tab', { initialCmd }),
  onNew: (cb) => ipcRenderer.on('tabs:new', (_e, payload) => cb && cb(payload || {})),
});

// --- WARP_OPEN_BLOCKS_API_MARKER ---
// Blocks API bridge for renderer
contextBridge.exposeInMainWorld('blocksAPI', {
  getBlocks: async (limit = 50) => {
    try {
      return await ipcRenderer.invoke('blocks:get-all', limit);
    } catch (e) {
      console.warn('[preload] blocks:get-all failed:', e.message);
      return [];
    }
  },
  exportBlock: async (id, format = 'text') => {
    try {
      return await ipcRenderer.invoke('blocks:export', id, format);
    } catch (e) {
      console.warn('[preload] blocks:export failed:', e.message);
      return null;
    }
  }
});
// --- WARP_OPEN_BLOCKS_API_MARKER ---

// <<< FT_SESSIONS_API_START >>>
try {
  const { contextBridge } = require("electron");
  const fs=require("fs"), path=require("path"), os=require("os");
  const SESS_DIR = path.join(os.homedir(), ".warp_open", "sessions");
  function listLatest(limit=10){
    try {
      const files=(fs.existsSync(SESS_DIR)?fs.readdirSync(SESS_DIR):[])
        .filter(f=>/^session-.*\.jsonl$/.test(f))
        .map(f=>({f, p:path.join(SESS_DIR,f), t:fs.statSync(path.join(SESS_DIR,f)).mtimeMs}))
        .sort((a,b)=>b.t-a.t).slice(0,limit).map(x=>x.p);
      return files;
    } catch(e){ return []; }
  }
  if(typeof window!=="undefined"){
    contextBridge.exposeInMainWorld("sessions", { listLatest });
  }
} catch(_) {}
// <<< FT_SESSIONS_API_END >>>


/* WARP_OPEN_DEMO_PRELOAD */
try {
  // Safe session flush hook -> main
  contextBridge.exposeInMainWorld('session', {
    flush: () => ipcRenderer.invoke('session:flush').catch(()=>({ok:false}))
  });

  // Optional blocks helper summary (renderer can call blocksExtra.summary())
  contextBridge.exposeInMainWorld('blocksExtra', {
    async summary() {
      try {
        const getBlocks = (window.blocks && window.blocks.getBlocks)
                       || (window.bridge && window.bridge.getBlocks);
        if(!getBlocks) { console.warn('[blocksExtra] no getBlocks'); return; }
        const list = await getBlocks();
        const running = list.filter(b=>!b.endedAt).length;
        const done    = list.filter(b=>b.endedAt).length;
        const failed  = list.filter(b=>b.exitCode && b.exitCode!==0).length;
        const lastCmd = list.length ? (list[list.length-1].command||'') : '';
        console.log('[blocks] total=%d running=%d done=%d failed=%d last="%s"',
          list.length, running, done, failed, lastCmd);
      } catch(e) { console.error('[blocksExtra.summary]', e); }
    }
  });
} catch(e) { console.error('[preload demo wiring]', e); }



// === CRASH_GUARD_START (idempotent) ===
(() => {
  try {
    const { contextBridge, ipcRenderer } = require('electron');

    // Ensure namespaces exist
    const expose = (name, api) => {
      try {
        // if already exposed by earlier patches, merge shallowly
        if (window[name]) Object.assign(window[name], api);
        else contextBridge.exposeInMainWorld(name, api);
      } catch {}
    };

    expose('session', {
      flush: () => ipcRenderer.invoke('session:flush').catch(()=>false),
    });

    expose('appctl', {
      softReload: () => ipcRenderer.invoke('app:soft-reload').catch(()=>false),
    });

    // Optional: listen for crash toasts from main
    ipcRenderer.on('crash:toast', (_e, payload) => {
      window.dispatchEvent(new CustomEvent('warpopen-crash', { detail: payload||{} }));
    });
  } catch (e) {
    console.error('[preload][crash-guard] expose failed', e);
  }
})();
// === CRASH_GUARD_END ===

// === CWD_RESTORE_BRIDGE_START ===
(() => {
  try {
    const { contextBridge, ipcRenderer } = require('electron');
    const api = { newTabWithCwd: (opts) => ipcRenderer.invoke('term:new', opts||{}) };
    if (window.bridge) Object.assign(window.bridge, api);
    else contextBridge.exposeInMainWorld('bridge', api);
  } catch {}
})();
// === CWD_RESTORE_BRIDGE_END ===
(() => {
  try {
    const { contextBridge, ipcRenderer } = require('electron');
    const api = { simulateMainCrash: () => ipcRenderer.invoke('dev:simulate-main-crash') };
    if (window.devctl) Object.assign(window.devctl, api);
    else contextBridge.exposeInMainWorld('devctl', api);
  } catch {}
})();
