{"conversations": [{"from": "human", "value": "Reverse a string in Python"}, {"from": "gpt", "value": "```python\n# Simplest\ns = \"hello\"\nreversed_s = s[::-1]  # \"olleh\"\n\n# Using reversed()\nreversed_s = ''.join(reversed(s))\n\n# Manual loop\ndef reverse_string(s):\n    result = \"\"\n    for char in s:\n        result = char + result\n    return result\n\n# Two pointers (in-place for list)\ndef reverse_list(chars):\n    left, right = 0, len(chars) - 1\n    while left < right:\n        chars[left], chars[right] = chars[right], chars[left]\n        left += 1\n        right -= 1\n```\n\nSlicing `[::-1]` is the most Pythonic way."}]}
{"conversations": [{"from": "human", "value": "Check if a string is a palindrome"}, {"from": "gpt", "value": "```python\ndef is_palindrome(s):\n    # Simple\n    return s == s[::-1]\n\n# Ignoring case and non-alphanumeric\ndef is_palindrome_clean(s):\n    cleaned = ''.join(c.lower() for c in s if c.isalnum())\n    return cleaned == cleaned[::-1]\n\n# Two pointer approach\ndef is_palindrome_two_pointer(s):\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n\n# Test\nprint(is_palindrome_clean(\"A man, a plan, a canal: Panama\"))  # True\nprint(is_palindrome_clean(\"race a car\"))  # False\n```"}]}
{"conversations": [{"from": "human", "value": "Find duplicates in an array"}, {"from": "gpt", "value": "```python\n# Using set\ndef find_duplicates(arr):\n    seen = set()\n    duplicates = set()\n    for item in arr:\n        if item in seen:\n            duplicates.add(item)\n        else:\n            seen.add(item)\n    return list(duplicates)\n\n# Using Counter\nfrom collections import Counter\n\ndef find_duplicates_counter(arr):\n    counts = Counter(arr)\n    return [item for item, count in counts.items() if count > 1]\n\n# One-liner\ndef find_duplicates_oneliner(arr):\n    return [x for x in set(arr) if arr.count(x) > 1]\n\n# Test\narr = [1, 2, 3, 2, 4, 5, 3, 6, 3]\nprint(find_duplicates(arr))  # [2, 3]\n```\n\nThe set approach is O(n) time. The count method is O(n²) - avoid for large arrays."}]}
{"conversations": [{"from": "human", "value": "Merge two sorted arrays"}, {"from": "gpt", "value": "```python\ndef merge_sorted(arr1, arr2):\n    result = []\n    i, j = 0, 0\n    \n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] <= arr2[j]:\n            result.append(arr1[i])\n            i += 1\n        else:\n            result.append(arr2[j])\n            j += 1\n    \n    # Add remaining elements\n    result.extend(arr1[i:])\n    result.extend(arr2[j:])\n    \n    return result\n\n# Test\narr1 = [1, 3, 5, 7]\narr2 = [2, 4, 6, 8]\nprint(merge_sorted(arr1, arr2))  # [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\nTime: O(n + m)\nSpace: O(n + m)\n\nThis is the merge step in mergesort."}]}
{"conversations": [{"from": "human", "value": "Two sum problem"}, {"from": "gpt", "value": "```python\ndef two_sum(nums, target):\n    \"\"\"Return indices of two numbers that add up to target.\"\"\"\n    seen = {}  # value -> index\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    \n    return []  # No solution found\n\n# Test\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # [0, 1] because 2 + 7 = 9\n```\n\nTime: O(n) - single pass\nSpace: O(n) - hash map\n\nBrute force would be O(n²). The hash map is the key insight."}]}
{"conversations": [{"from": "human", "value": "FizzBuzz"}, {"from": "gpt", "value": "```python\ndef fizzbuzz(n):\n    for i in range(1, n + 1):\n        if i % 15 == 0:  # Divisible by both 3 and 5\n            print(\"FizzBuzz\")\n        elif i % 3 == 0:\n            print(\"Fizz\")\n        elif i % 5 == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\n# Alternative - more extensible\ndef fizzbuzz_v2(n):\n    for i in range(1, n + 1):\n        output = \"\"\n        if i % 3 == 0:\n            output += \"Fizz\"\n        if i % 5 == 0:\n            output += \"Buzz\"\n        print(output or i)\n\n# One-liner (for fun)\nfor i in range(1, 101): print(\"Fizz\"*(i%3==0)+\"Buzz\"*(i%5==0) or i)\n\nfizzbuzz(15)\n```\n\nThe classic interview question. Tests basic programming competency."}]}
{"conversations": [{"from": "human", "value": "Find max in array without using max()"}, {"from": "gpt", "value": "```python\ndef find_max(arr):\n    if not arr:\n        return None\n    \n    max_val = arr[0]\n    for num in arr[1:]:\n        if num > max_val:\n            max_val = num\n    return max_val\n\n# Using reduce\nfrom functools import reduce\ndef find_max_reduce(arr):\n    return reduce(lambda a, b: a if a > b else b, arr)\n\n# Test\narr = [3, 1, 4, 1, 5, 9, 2, 6]\nprint(find_max(arr))  # 9\n```\n\nTime: O(n)\nSpace: O(1)"}]}
{"conversations": [{"from": "human", "value": "Remove duplicates from array"}, {"from": "gpt", "value": "```python\n# Preserving order (Python 3.7+)\ndef remove_duplicates(arr):\n    return list(dict.fromkeys(arr))\n\n# Using set (doesn't preserve order)\ndef remove_duplicates_set(arr):\n    return list(set(arr))\n\n# Preserving order manually\ndef remove_duplicates_manual(arr):\n    seen = set()\n    result = []\n    for item in arr:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result\n\n# Test\narr = [1, 2, 2, 3, 4, 4, 5, 1]\nprint(remove_duplicates(arr))  # [1, 2, 3, 4, 5]\n```\n\ndict.fromkeys() is a clever Python trick - dicts preserve insertion order."}]}
{"conversations": [{"from": "human", "value": "Count character occurrences in string"}, {"from": "gpt", "value": "```python\nfrom collections import Counter\n\n# Using Counter (recommended)\ndef count_chars(s):\n    return Counter(s)\n\n# Manual approach\ndef count_chars_manual(s):\n    counts = {}\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n    return counts\n\n# Using defaultdict\nfrom collections import defaultdict\ndef count_chars_default(s):\n    counts = defaultdict(int)\n    for char in s:\n        counts[char] += 1\n    return dict(counts)\n\n# Test\ns = \"hello world\"\nprint(count_chars(s))\n# Counter({'l': 3, 'o': 2, 'h': 1, 'e': 1, ' ': 1, 'w': 1, 'r': 1, 'd': 1})\n```\n\nCounter is the Pythonic way for this."}]}
{"conversations": [{"from": "human", "value": "Check if two strings are anagrams"}, {"from": "gpt", "value": "```python\nfrom collections import Counter\n\ndef are_anagrams(s1, s2):\n    # Clean and compare\n    clean1 = s1.lower().replace(' ', '')\n    clean2 = s2.lower().replace(' ', '')\n    return Counter(clean1) == Counter(clean2)\n\n# Sorting approach\ndef are_anagrams_sort(s1, s2):\n    clean1 = sorted(s1.lower().replace(' ', ''))\n    clean2 = sorted(s2.lower().replace(' ', ''))\n    return clean1 == clean2\n\n# Test\nprint(are_anagrams(\"listen\", \"silent\"))  # True\nprint(are_anagrams(\"hello\", \"world\"))   # False\nprint(are_anagrams(\"Dormitory\", \"Dirty room\"))  # True\n```\n\nCounter approach: O(n) time, O(n) space\nSorting approach: O(n log n) time, O(n) space"}]}
{"conversations": [{"from": "human", "value": "Find first non-repeating character"}, {"from": "gpt", "value": "```python\nfrom collections import Counter\n\ndef first_non_repeating(s):\n    counts = Counter(s)\n    for char in s:\n        if counts[char] == 1:\n            return char\n    return None\n\n# Index version\ndef first_non_repeating_index(s):\n    counts = Counter(s)\n    for i, char in enumerate(s):\n        if counts[char] == 1:\n            return i\n    return -1\n\n# Test\nprint(first_non_repeating(\"leetcode\"))  # 'l'\nprint(first_non_repeating(\"loveleetcode\"))  # 't'\nprint(first_non_repeating(\"aabb\"))  # None\n```\n\nTwo passes: First to count, second to find first unique. O(n) time."}]}
{"conversations": [{"from": "human", "value": "Implement factorial"}, {"from": "gpt", "value": "```python\n# Recursive\ndef factorial_recursive(n):\n    if n <= 1:\n        return 1\n    return n * factorial_recursive(n - 1)\n\n# Iterative\ndef factorial_iterative(n):\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\n# Using reduce\nfrom functools import reduce\ndef factorial_reduce(n):\n    return reduce(lambda a, b: a * b, range(1, n + 1), 1)\n\n# Using math library\nimport math\nmath.factorial(5)  # 120\n\n# Test\nprint(factorial_recursive(5))  # 120\nprint(factorial_iterative(5))  # 120\n```\n\nIterative is preferred - no stack overflow risk for large n."}]}
{"conversations": [{"from": "human", "value": "Implement Fibonacci"}, {"from": "gpt", "value": "```python\n# Naive recursive (SLOW - exponential)\ndef fib_recursive(n):\n    if n <= 1:\n        return n\n    return fib_recursive(n - 1) + fib_recursive(n - 2)\n\n# Memoized (fast)\ndef fib_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fib_memo(n - 1, memo) + fib_memo(n - 2, memo)\n    return memo[n]\n\n# Iterative (best)\ndef fib_iterative(n):\n    if n <= 1:\n        return n\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n    return curr\n\n# Using lru_cache\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib_cached(n):\n    if n <= 1:\n        return n\n    return fib_cached(n - 1) + fib_cached(n - 2)\n\n# Test\nprint(fib_iterative(10))  # 55\nprint(fib_memo(50))       # 12586269025 (try this with naive recursive...)\n```\n\nNaive recursive: O(2^n) - terrible\nMemoized/Iterative: O(n) - good"}]}
{"conversations": [{"from": "human", "value": "Binary search"}, {"from": "gpt", "value": "```python\ndef binary_search(arr, target):\n    \"\"\"Return index of target, or -1 if not found.\"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\n# Recursive version\ndef binary_search_recursive(arr, target, left=0, right=None):\n    if right is None:\n        right = len(arr) - 1\n    \n    if left > right:\n        return -1\n    \n    mid = (left + right) // 2\n    \n    if arr[mid] == target:\n        return mid\n    elif arr[mid] < target:\n        return binary_search_recursive(arr, target, mid + 1, right)\n    else:\n        return binary_search_recursive(arr, target, left, mid - 1)\n\n# Using bisect module\nimport bisect\ndef binary_search_bisect(arr, target):\n    i = bisect.bisect_left(arr, target)\n    if i != len(arr) and arr[i] == target:\n        return i\n    return -1\n\n# Test\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(binary_search(arr, 7))  # 6\nprint(binary_search(arr, 11)) # -1\n```\n\nTime: O(log n)\nRequires sorted array!"}]}
{"conversations": [{"from": "human", "value": "Check if number is prime"}, {"from": "gpt", "value": "```python\ndef is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    # Only check odd numbers up to sqrt(n)\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n# Generate primes up to n (Sieve of Eratosthenes)\ndef sieve_of_eratosthenes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n    \n    return [i for i in range(n + 1) if is_prime[i]]\n\n# Test\nprint(is_prime(17))  # True\nprint(is_prime(18))  # False\nprint(sieve_of_eratosthenes(30))  # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n```\n\nSimple check: O(√n)\nSieve: O(n log log n) to generate all primes up to n"}]}
{"conversations": [{"from": "human", "value": "Flatten nested list"}, {"from": "gpt", "value": "```python\ndef flatten(nested):\n    \"\"\"Flatten arbitrarily nested list.\"\"\"\n    result = []\n    for item in nested:\n        if isinstance(item, list):\n            result.extend(flatten(item))\n        else:\n            result.append(item)\n    return result\n\n# Generator version (memory efficient)\ndef flatten_gen(nested):\n    for item in nested:\n        if isinstance(item, list):\n            yield from flatten_gen(item)\n        else:\n            yield item\n\n# For single level nesting\ndef flatten_single(nested):\n    return [item for sublist in nested for item in sublist]\n\n# itertools for single level\nfrom itertools import chain\ndef flatten_chain(nested):\n    return list(chain.from_iterable(nested))\n\n# Test\nnested = [1, [2, 3], [4, [5, 6, [7]]], 8]\nprint(flatten(nested))  # [1, 2, 3, 4, 5, 6, 7, 8]\nprint(list(flatten_gen(nested)))  # [1, 2, 3, 4, 5, 6, 7, 8]\n```"}]}
{"conversations": [{"from": "human", "value": "Reverse a linked list"}, {"from": "gpt", "value": "```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_iterative(head):\n    prev = None\n    curr = head\n    \n    while curr:\n        next_temp = curr.next  # Store next\n        curr.next = prev       # Reverse pointer\n        prev = curr            # Move prev forward\n        curr = next_temp       # Move curr forward\n    \n    return prev  # New head\n\ndef reverse_recursive(head):\n    if not head or not head.next:\n        return head\n    \n    new_head = reverse_recursive(head.next)\n    head.next.next = head\n    head.next = None\n    \n    return new_head\n\n# Test\n# 1 -> 2 -> 3 -> None becomes 3 -> 2 -> 1 -> None\n```\n\nIterative: O(n) time, O(1) space\nRecursive: O(n) time, O(n) space (call stack)\n\nIterative is preferred."}]}
{"conversations": [{"from": "human", "value": "Detect cycle in linked list"}, {"from": "gpt", "value": "```python\nclass ListNode:\n    def __init__(self, val=0):\n        self.val = val\n        self.next = None\n\ndef has_cycle(head):\n    \"\"\"Floyd's Cycle Detection (tortoise and hare).\"\"\"\n    if not head or not head.next:\n        return False\n    \n    slow = head\n    fast = head\n    \n    while fast and fast.next:\n        slow = slow.next         # Move 1 step\n        fast = fast.next.next    # Move 2 steps\n        \n        if slow == fast:         # They meet = cycle\n            return True\n    \n    return False\n\n# Find start of cycle\ndef detect_cycle_start(head):\n    if not head or not head.next:\n        return None\n    \n    slow = fast = head\n    \n    # Find meeting point\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            break\n    else:\n        return None  # No cycle\n    \n    # Find start of cycle\n    slow = head\n    while slow != fast:\n        slow = slow.next\n        fast = fast.next\n    \n    return slow\n```\n\nTime: O(n)\nSpace: O(1)\n\nThe \"tortoise and hare\" algorithm is a classic."}]}
{"conversations": [{"from": "human", "value": "Find middle of linked list"}, {"from": "gpt", "value": "```python\nclass ListNode:\n    def __init__(self, val=0):\n        self.val = val\n        self.next = None\n\ndef find_middle(head):\n    \"\"\"Use slow and fast pointers.\"\"\"\n    slow = fast = head\n    \n    while fast and fast.next:\n        slow = slow.next        # Move 1 step\n        fast = fast.next.next   # Move 2 steps\n    \n    return slow  # When fast reaches end, slow is at middle\n\n# If even length, returns second middle\n# For [1,2,3,4] returns 3\n# For [1,2,3,4,5] returns 3\n\n# To get first middle in even case:\ndef find_middle_first(head):\n    slow = fast = head\n    \n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    return slow\n```\n\nTime: O(n)\nSpace: O(1)\n\nSlow/fast pointer pattern is used in many linked list problems."}]}
{"conversations": [{"from": "human", "value": "Validate BST"}, {"from": "gpt", "value": "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, min_val, max_val):\n        if not node:\n            return True\n        \n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        return (validate(node.left, min_val, node.val) and\n                validate(node.right, node.val, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))\n\n# Inorder traversal approach\ndef is_valid_bst_inorder(root):\n    prev = float('-inf')\n    \n    def inorder(node):\n        nonlocal prev\n        if not node:\n            return True\n        \n        if not inorder(node.left):\n            return False\n        \n        if node.val <= prev:\n            return False\n        prev = node.val\n        \n        return inorder(node.right)\n    \n    return inorder(root)\n```\n\nKey insight: Not just left < node < right, but ALL left descendants < node < ALL right descendants.\n\nTime: O(n)\nSpace: O(h) where h is height"}]}
