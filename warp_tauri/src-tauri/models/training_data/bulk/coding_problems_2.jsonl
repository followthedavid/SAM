{"conversations": [{"from": "human", "value": "Implement a function to find the longest palindromic substring"}, {"from": "gpt", "value": "Here's an efficient O(n²) solution using expand-around-center:\n\n```python\ndef longest_palindrome(s: str) -> str:\n    if len(s) < 2:\n        return s\n    \n    start, max_len = 0, 1\n    \n    def expand(left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    for i in range(len(s)):\n        # Odd length palindromes\n        len1 = expand(i, i)\n        # Even length palindromes\n        len2 = expand(i, i + 1)\n        \n        length = max(len1, len2)\n        if length > max_len:\n            max_len = length\n            start = i - (length - 1) // 2\n    \n    return s[start:start + max_len]\n```\n\nFor O(n) there's Manacher's algorithm, but it's rarely worth the complexity unless you're dealing with massive strings."}]}
{"conversations": [{"from": "human", "value": "Write a function to merge two sorted linked lists"}, {"from": "gpt", "value": "```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    current = dummy\n    \n    while l1 and l2:\n        if l1.val <= l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n    \n    # Attach remaining nodes\n    current.next = l1 if l1 else l2\n    \n    return dummy.next\n```\n\nTime: O(n + m), Space: O(1) - we're reusing existing nodes, not creating new ones."}]}
{"conversations": [{"from": "human", "value": "Implement a min heap"}, {"from": "gpt", "value": "```python\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n    \n    def parent(self, i): return (i - 1) // 2\n    def left(self, i): return 2 * i + 1\n    def right(self, i): return 2 * i + 2\n    \n    def push(self, val):\n        self.heap.append(val)\n        self._sift_up(len(self.heap) - 1)\n    \n    def pop(self):\n        if not self.heap:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n        \n        min_val = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._sift_down(0)\n        return min_val\n    \n    def peek(self):\n        return self.heap[0] if self.heap else None\n    \n    def _sift_up(self, i):\n        while i > 0 and self.heap[i] < self.heap[self.parent(i)]:\n            self.heap[i], self.heap[self.parent(i)] = self.heap[self.parent(i)], self.heap[i]\n            i = self.parent(i)\n    \n    def _sift_down(self, i):\n        smallest = i\n        l, r = self.left(i), self.right(i)\n        \n        if l < len(self.heap) and self.heap[l] < self.heap[smallest]:\n            smallest = l\n        if r < len(self.heap) and self.heap[r] < self.heap[smallest]:\n            smallest = r\n        \n        if smallest != i:\n            self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i]\n            self._sift_down(smallest)\n```\n\nPush and pop are O(log n). In practice, just use `heapq` module."}]}
{"conversations": [{"from": "human", "value": "Find the kth largest element in an array"}, {"from": "gpt", "value": "Three approaches:\n\n**1. Sort (simple but slow):**\n```python\ndef find_kth_largest(nums, k):\n    return sorted(nums, reverse=True)[k-1]\n# O(n log n)\n```\n\n**2. Min heap (good for streaming):**\n```python\nimport heapq\n\ndef find_kth_largest(nums, k):\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heap[0]\n# O(n log k)\n```\n\n**3. Quickselect (optimal average case):**\n```python\nimport random\n\ndef find_kth_largest(nums, k):\n    k = len(nums) - k  # Convert to kth smallest\n    \n    def quickselect(left, right):\n        pivot_idx = random.randint(left, right)\n        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n        \n        store = left\n        for i in range(left, right):\n            if nums[i] < nums[right]:\n                nums[store], nums[i] = nums[i], nums[store]\n                store += 1\n        nums[store], nums[right] = nums[right], nums[store]\n        \n        if store == k:\n            return nums[store]\n        elif store < k:\n            return quickselect(store + 1, right)\n        else:\n            return quickselect(left, store - 1)\n    \n    return quickselect(0, len(nums) - 1)\n# O(n) average, O(n²) worst case\n```"}]}
{"conversations": [{"from": "human", "value": "Implement a trie (prefix tree)"}, {"from": "gpt", "value": "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n    \n    def search(self, word: str) -> bool:\n        node = self._find_node(word)\n        return node is not None and node.is_end\n    \n    def starts_with(self, prefix: str) -> bool:\n        return self._find_node(prefix) is not None\n    \n    def _find_node(self, prefix: str) -> TrieNode:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return None\n            node = node.children[char]\n        return node\n    \n    def autocomplete(self, prefix: str) -> list:\n        node = self._find_node(prefix)\n        if not node:\n            return []\n        \n        results = []\n        def dfs(node, path):\n            if node.is_end:\n                results.append(prefix + path)\n            for char, child in node.children.items():\n                dfs(child, path + char)\n        \n        dfs(node, '')\n        return results\n```\n\nUse cases: autocomplete, spell checking, IP routing tables, word games."}]}
{"conversations": [{"from": "human", "value": "Detect a cycle in a linked list"}, {"from": "gpt", "value": "Floyd's Tortoise and Hare algorithm:\n\n```python\ndef has_cycle(head: ListNode) -> bool:\n    if not head or not head.next:\n        return False\n    \n    slow = head\n    fast = head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    \n    return False\n```\n\nTo find where the cycle starts:\n```python\ndef find_cycle_start(head: ListNode) -> ListNode:\n    if not head or not head.next:\n        return None\n    \n    slow = fast = head\n    \n    # Find meeting point\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            break\n    else:\n        return None  # No cycle\n    \n    # Find cycle start\n    slow = head\n    while slow != fast:\n        slow = slow.next\n        fast = fast.next\n    \n    return slow\n```\n\nO(n) time, O(1) space. The math behind why this works: when they meet, slow has traveled distance d + k, fast has traveled d + k + nc (n complete cycles). Since fast travels 2x slow: 2(d+k) = d+k+nc, so d = nc-k."}]}
{"conversations": [{"from": "human", "value": "Implement LRU cache"}, {"from": "gpt", "value": "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n    \n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(first=True)\n```\n\nOr from scratch with doubly linked list + hash map:\n\n```python\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key, self.val = key, val\n        self.prev = self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head, self.tail = Node(), Node()\n        self.head.next, self.tail.prev = self.tail, self.head\n    \n    def _remove(self, node):\n        node.prev.next, node.next.prev = node.next, node.prev\n    \n    def _add(self, node):\n        node.prev, node.next = self.tail.prev, self.tail\n        self.tail.prev.next = self.tail.prev = node\n    \n    def get(self, key):\n        if key in self.cache:\n            self._remove(self.cache[key])\n            self._add(self.cache[key])\n            return self.cache[key].val\n        return -1\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self._remove(self.cache[key])\n        node = Node(key, value)\n        self._add(node)\n        self.cache[key] = node\n        if len(self.cache) > self.cap:\n            lru = self.head.next\n            self._remove(lru)\n            del self.cache[lru.key]\n```"}]}
{"conversations": [{"from": "human", "value": "Find all permutations of a string"}, {"from": "gpt", "value": "```python\ndef permutations(s: str) -> list:\n    result = []\n    \n    def backtrack(path, remaining):\n        if not remaining:\n            result.append(path)\n            return\n        \n        seen = set()\n        for i, char in enumerate(remaining):\n            if char in seen:  # Skip duplicates\n                continue\n            seen.add(char)\n            backtrack(path + char, remaining[:i] + remaining[i+1:])\n    \n    backtrack('', s)\n    return result\n\n# Or using itertools:\nfrom itertools import permutations as perms\nlist(set([''.join(p) for p in perms(s)]))\n```\n\nFor just the count: n! permutations (or n!/k! if there are k duplicate characters)."}]}
{"conversations": [{"from": "human", "value": "Implement binary search tree"}, {"from": "gpt", "value": "```python\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def insert(self, val):\n        if not self.root:\n            self.root = TreeNode(val)\n            return\n        \n        node = self.root\n        while True:\n            if val < node.val:\n                if not node.left:\n                    node.left = TreeNode(val)\n                    return\n                node = node.left\n            else:\n                if not node.right:\n                    node.right = TreeNode(val)\n                    return\n                node = node.right\n    \n    def search(self, val) -> bool:\n        node = self.root\n        while node:\n            if val == node.val:\n                return True\n            node = node.left if val < node.val else node.right\n        return False\n    \n    def delete(self, val):\n        def find_min(node):\n            while node.left:\n                node = node.left\n            return node\n        \n        def delete_node(node, val):\n            if not node:\n                return None\n            \n            if val < node.val:\n                node.left = delete_node(node.left, val)\n            elif val > node.val:\n                node.right = delete_node(node.right, val)\n            else:\n                if not node.left:\n                    return node.right\n                if not node.right:\n                    return node.left\n                \n                successor = find_min(node.right)\n                node.val = successor.val\n                node.right = delete_node(node.right, successor.val)\n            \n            return node\n        \n        self.root = delete_node(self.root, val)\n    \n    def inorder(self) -> list:\n        result = []\n        def traverse(node):\n            if node:\n                traverse(node.left)\n                result.append(node.val)\n                traverse(node.right)\n        traverse(self.root)\n        return result\n```\n\nAll operations O(log n) average, O(n) worst case (degenerate tree)."}]}
{"conversations": [{"from": "human", "value": "Find the maximum subarray sum"}, {"from": "gpt", "value": "Kadane's algorithm - elegant O(n) solution:\n\n```python\ndef max_subarray(nums: list) -> int:\n    max_sum = current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```\n\nTo also get the subarray indices:\n```python\ndef max_subarray_with_indices(nums: list) -> tuple:\n    max_sum = current_sum = nums[0]\n    start = end = temp_start = 0\n    \n    for i, num in enumerate(nums[1:], 1):\n        if num > current_sum + num:\n            current_sum = num\n            temp_start = i\n        else:\n            current_sum += num\n        \n        if current_sum > max_sum:\n            max_sum = current_sum\n            start = temp_start\n            end = i\n    \n    return max_sum, nums[start:end+1]\n```\n\nThe insight: at each position, either extend the previous subarray or start fresh. If running sum goes negative, it can only hurt future sums."}]}
{"conversations": [{"from": "human", "value": "Validate a binary search tree"}, {"from": "gpt", "value": "```python\ndef is_valid_bst(root) -> bool:\n    def validate(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n        \n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        return (validate(node.left, min_val, node.val) and\n                validate(node.right, node.val, max_val))\n    \n    return validate(root)\n```\n\nOr using inorder traversal (BST inorder is always sorted):\n```python\ndef is_valid_bst(root) -> bool:\n    prev = float('-inf')\n    \n    def inorder(node):\n        nonlocal prev\n        if not node:\n            return True\n        \n        if not inorder(node.left):\n            return False\n        \n        if node.val <= prev:\n            return False\n        prev = node.val\n        \n        return inorder(node.right)\n    \n    return inorder(root)\n```\n\nCommon mistake: only checking immediate children. A node must be valid against ALL ancestors, not just its parent."}]}
{"conversations": [{"from": "human", "value": "Implement merge sort"}, {"from": "gpt", "value": "```python\ndef merge_sort(arr: list) -> list:\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left: list, right: list) -> list:\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n```\n\nIn-place version (more complex but O(1) extra space):\n```python\ndef merge_sort_inplace(arr, left=0, right=None):\n    if right is None:\n        right = len(arr) - 1\n    \n    if left < right:\n        mid = (left + right) // 2\n        merge_sort_inplace(arr, left, mid)\n        merge_sort_inplace(arr, mid + 1, right)\n        merge_inplace(arr, left, mid, right)\n```\n\nTime: O(n log n) always. Space: O(n) for standard, O(log n) for in-place (stack). Stable sort - equal elements keep original order."}]}
{"conversations": [{"from": "human", "value": "Find the lowest common ancestor of two nodes in a binary tree"}, {"from": "gpt", "value": "```python\ndef lowest_common_ancestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    \n    left = lowest_common_ancestor(root.left, p, q)\n    right = lowest_common_ancestor(root.right, p, q)\n    \n    if left and right:\n        return root  # p and q are on different sides\n    \n    return left if left else right\n```\n\nFor BST (can use values to guide search):\n```python\ndef lca_bst(root, p, q):\n    while root:\n        if p.val < root.val and q.val < root.val:\n            root = root.left\n        elif p.val > root.val and q.val > root.val:\n            root = root.right\n        else:\n            return root\n```\n\nWith parent pointers:\n```python\ndef lca_with_parents(p, q):\n    ancestors = set()\n    while p:\n        ancestors.add(p)\n        p = p.parent\n    while q:\n        if q in ancestors:\n            return q\n        q = q.parent\n    return None\n```"}]}
{"conversations": [{"from": "human", "value": "Serialize and deserialize a binary tree"}, {"from": "gpt", "value": "```python\nclass Codec:\n    def serialize(self, root) -> str:\n        if not root:\n            return 'null'\n        \n        result = []\n        \n        def preorder(node):\n            if not node:\n                result.append('null')\n                return\n            result.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n        \n        preorder(root)\n        return ','.join(result)\n    \n    def deserialize(self, data: str):\n        if data == 'null':\n            return None\n        \n        values = iter(data.split(','))\n        \n        def build():\n            val = next(values)\n            if val == 'null':\n                return None\n            node = TreeNode(int(val))\n            node.left = build()\n            node.right = build()\n            return node\n        \n        return build()\n```\n\nLevel-order alternative:\n```python\nfrom collections import deque\n\ndef serialize_bfs(root) -> str:\n    if not root:\n        return ''\n    result = []\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        if node:\n            result.append(str(node.val))\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append('null')\n    return ','.join(result)\n```"}]}
{"conversations": [{"from": "human", "value": "Implement quicksort"}, {"from": "gpt", "value": "```python\ndef quicksort(arr: list) -> list:\n    if len(arr) <= 1:\n        return arr\n    \n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return quicksort(left) + middle + quicksort(right)\n```\n\nIn-place version:\n```python\nimport random\n\ndef quicksort_inplace(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_idx = partition(arr, low, high)\n        quicksort_inplace(arr, low, pivot_idx - 1)\n        quicksort_inplace(arr, pivot_idx + 1, high)\n\ndef partition(arr, low, high):\n    # Random pivot to avoid worst case\n    pivot_idx = random.randint(low, high)\n    arr[pivot_idx], arr[high] = arr[high], arr[pivot_idx]\n    \n    pivot = arr[high]\n    i = low - 1\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n```\n\nAverage O(n log n), worst O(n²). Random pivot makes worst case extremely unlikely."}]}
{"conversations": [{"from": "human", "value": "Find all subsets of a set"}, {"from": "gpt", "value": "```python\ndef subsets(nums: list) -> list:\n    result = [[]]\n    \n    for num in nums:\n        result += [subset + [num] for subset in result]\n    \n    return result\n\n# Or backtracking:\ndef subsets_backtrack(nums: list) -> list:\n    result = []\n    \n    def backtrack(start, path):\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    \n    backtrack(0, [])\n    return result\n\n# Or bit manipulation:\ndef subsets_bits(nums: list) -> list:\n    n = len(nums)\n    result = []\n    \n    for i in range(2 ** n):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        result.append(subset)\n    \n    return result\n```\n\nFor subsets with duplicates:\n```python\ndef subsets_with_dup(nums: list) -> list:\n    nums.sort()\n    result = []\n    \n    def backtrack(start, path):\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    \n    backtrack(0, [])\n    return result\n```\n\nTotal subsets: 2^n"}]}
{"conversations": [{"from": "human", "value": "Implement a graph and BFS/DFS"}, {"from": "gpt", "value": "```python\nfrom collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self, directed=False):\n        self.graph = defaultdict(list)\n        self.directed = directed\n    \n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        if not self.directed:\n            self.graph[v].append(u)\n    \n    def bfs(self, start):\n        visited = set([start])\n        queue = deque([start])\n        result = []\n        \n        while queue:\n            node = queue.popleft()\n            result.append(node)\n            \n            for neighbor in self.graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        \n        return result\n    \n    def dfs(self, start):\n        visited = set()\n        result = []\n        \n        def explore(node):\n            visited.add(node)\n            result.append(node)\n            for neighbor in self.graph[node]:\n                if neighbor not in visited:\n                    explore(neighbor)\n        \n        explore(start)\n        return result\n    \n    def dfs_iterative(self, start):\n        visited = set()\n        stack = [start]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                result.append(node)\n                stack.extend(reversed(self.graph[node]))\n        \n        return result\n    \n    def has_path(self, start, end):\n        if start == end:\n            return True\n        \n        visited = set([start])\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in self.graph[node]:\n                if neighbor == end:\n                    return True\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        \n        return False\n```\n\nBFS: O(V + E), finds shortest path in unweighted graph\nDFS: O(V + E), good for exhaustive search, cycle detection"}]}
{"conversations": [{"from": "human", "value": "Solve the coin change problem"}, {"from": "gpt", "value": "**Minimum coins needed:**\n```python\ndef coin_change(coins: list, amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for x in range(coin, amount + 1):\n            dp[x] = min(dp[x], dp[x - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1\n```\n\n**Number of ways to make change:**\n```python\ndef coin_change_ways(coins: list, amount: int) -> int:\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n    \n    for coin in coins:\n        for x in range(coin, amount + 1):\n            dp[x] += dp[x - coin]\n    \n    return dp[amount]\n```\n\n**Track which coins were used:**\n```python\ndef coin_change_with_coins(coins: list, amount: int) -> list:\n    dp = [float('inf')] * (amount + 1)\n    parent = [-1] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for x in range(coin, amount + 1):\n            if dp[x - coin] + 1 < dp[x]:\n                dp[x] = dp[x - coin] + 1\n                parent[x] = coin\n    \n    if dp[amount] == float('inf'):\n        return []\n    \n    result = []\n    while amount > 0:\n        result.append(parent[amount])\n        amount -= parent[amount]\n    return result\n```\n\nTime: O(amount * len(coins)), Space: O(amount)"}]}
{"conversations": [{"from": "human", "value": "Find the longest increasing subsequence"}, {"from": "gpt", "value": "**O(n²) DP solution:**\n```python\ndef longest_increasing_subsequence(nums: list) -> int:\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n  # dp[i] = LIS ending at index i\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n```\n\n**O(n log n) with binary search:**\n```python\nimport bisect\n\ndef lis_fast(nums: list) -> int:\n    tails = []  # tails[i] = smallest ending element for LIS of length i+1\n    \n    for num in nums:\n        pos = bisect.bisect_left(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    \n    return len(tails)\n```\n\n**To reconstruct the actual subsequence:**\n```python\ndef lis_with_sequence(nums: list) -> list:\n    if not nums:\n        return []\n    \n    n = len(nums)\n    dp = [1] * n\n    parent = [-1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[j] < nums[i] and dp[j] + 1 > dp[i]:\n                dp[i] = dp[j] + 1\n                parent[i] = j\n    \n    # Find the end of LIS\n    max_len = max(dp)\n    idx = dp.index(max_len)\n    \n    # Reconstruct\n    result = []\n    while idx != -1:\n        result.append(nums[idx])\n        idx = parent[idx]\n    \n    return result[::-1]\n```"}]}
{"conversations": [{"from": "human", "value": "Implement a stack using queues"}, {"from": "gpt", "value": "```python\nfrom collections import deque\n\nclass StackUsingQueues:\n    def __init__(self):\n        self.queue = deque()\n    \n    def push(self, x: int) -> None:\n        self.queue.append(x)\n        # Rotate so newest element is at front\n        for _ in range(len(self.queue) - 1):\n            self.queue.append(self.queue.popleft())\n    \n    def pop(self) -> int:\n        return self.queue.popleft()\n    \n    def top(self) -> int:\n        return self.queue[0]\n    \n    def empty(self) -> bool:\n        return len(self.queue) == 0\n```\n\nAlternatively, with O(1) push and O(n) pop:\n```python\nclass StackUsingQueues2:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n    \n    def push(self, x: int) -> None:\n        self.q1.append(x)\n    \n    def pop(self) -> int:\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        result = self.q1.popleft()\n        self.q1, self.q2 = self.q2, self.q1\n        return result\n```\n\nThe inverse (queue using stacks) is also a classic:\n```python\nclass QueueUsingStacks:\n    def __init__(self):\n        self.in_stack = []\n        self.out_stack = []\n    \n    def push(self, x: int) -> None:\n        self.in_stack.append(x)\n    \n    def pop(self) -> int:\n        self._transfer()\n        return self.out_stack.pop()\n    \n    def _transfer(self):\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n```"}]}
