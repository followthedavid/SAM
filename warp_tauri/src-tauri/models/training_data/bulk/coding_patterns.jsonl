{"conversations": [{"from": "human", "value": "What's the difference between == and === in JavaScript?"}, {"from": "gpt", "value": "**`==` (loose equality):**\n- Compares values after type coercion\n- `\"5\" == 5` is `true` (string converted to number)\n- `0 == false` is `true`\n- Can lead to unexpected results\n\n**`===` (strict equality):**\n- Compares value AND type\n- `\"5\" === 5` is `false` (different types)\n- `0 === false` is `false`\n- More predictable\n\n**Use `===` almost always.** The coercion rules of `==` are confusing and error-prone.\n\nSame applies to `!=` vs `!==`."}]}
{"conversations": [{"from": "human", "value": "What's a callback?"}, {"from": "gpt", "value": "**A callback** is a function passed as an argument to another function, to be executed later.\n\n```javascript\nfunction doSomething(callback) {\n  console.log(\"Doing something...\");\n  callback(); // Call it when done\n}\n\ndoSomething(function() {\n  console.log(\"Done!\");\n});\n```\n\n**Why use them:**\n- Handle asynchronous operations (file reads, API calls)\n- Event handling\n- Customizable behavior\n\n**Common example:**\n```javascript\nsetTimeout(function() {\n  console.log(\"This runs after 1 second\");\n}, 1000);\n```\n\n**The problem:**\nNested callbacks get messy (\"callback hell\"). That's why Promises and async/await were introduced."}]}
{"conversations": [{"from": "human", "value": "What's a Promise?"}, {"from": "gpt", "value": "**A Promise** represents a value that may be available now, later, or never.\n\n**States:**\n- Pending: Initial state\n- Fulfilled: Operation succeeded\n- Rejected: Operation failed\n\n**Basic usage:**\n```javascript\nfetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error(error));\n```\n\n**Creating a Promise:**\n```javascript\nconst myPromise = new Promise((resolve, reject) => {\n  if (success) {\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n**Why it's better than callbacks:**\n- Chainable (`.then().then()`)\n- Better error handling (`.catch()`)\n- Avoids nesting\n- Can combine with `Promise.all()`, `Promise.race()`\n\nEven better: use `async/await` syntax for cleaner code."}]}
{"conversations": [{"from": "human", "value": "What's async/await?"}, {"from": "gpt", "value": "**async/await** is syntactic sugar for Promises that makes async code look synchronous.\n\n**Before (Promises):**\n```javascript\nfunction getData() {\n  fetch('/api')\n    .then(response => response.json())\n    .then(data => console.log(data))\n    .catch(err => console.error(err));\n}\n```\n\n**After (async/await):**\n```javascript\nasync function getData() {\n  try {\n    const response = await fetch('/api');\n    const data = await response.json();\n    console.log(data);\n  } catch (err) {\n    console.error(err);\n  }\n}\n```\n\n**Key points:**\n- `async` marks a function as returning a Promise\n- `await` pauses until the Promise resolves\n- `await` only works inside `async` functions\n- Use try/catch for error handling\n- Code reads top-to-bottom like synchronous code\n\n**This is the modern standard** for handling async operations in JavaScript."}]}
{"conversations": [{"from": "human", "value": "What's the difference between let, const, and var?"}, {"from": "gpt", "value": "**`var` (old way):**\n- Function-scoped\n- Hoisted (can use before declaration)\n- Can be redeclared\n- Generally avoid in modern code\n\n**`let` (modern):**\n- Block-scoped `{}`\n- Not hoisted (temporal dead zone)\n- Can be reassigned\n- Cannot be redeclared in same scope\n\n**`const` (modern):**\n- Block-scoped\n- Cannot be reassigned\n- Must be initialized\n- Objects/arrays are still mutable (just can't reassign reference)\n\n**Best practice:**\n```javascript\n// Use const by default\nconst PI = 3.14;\nconst user = { name: 'John' };\n\n// Use let when you need to reassign\nlet count = 0;\ncount += 1;\n\n// Don't use var\n```\n\n**Rule:** `const` first, `let` when necessary, `var` never."}]}
{"conversations": [{"from": "human", "value": "What's a REST API?"}, {"from": "gpt", "value": "**REST** (Representational State Transfer) is an architectural style for designing networked applications.\n\n**Key principles:**\n\n1. **Stateless** - Each request contains all needed info\n2. **Client-Server** - Separation of concerns\n3. **Uniform Interface** - Consistent way to interact\n4. **Resources** - Everything is a resource with a URL\n\n**HTTP Methods:**\n- `GET` - Retrieve data\n- `POST` - Create new resource\n- `PUT` - Update entire resource\n- `PATCH` - Partial update\n- `DELETE` - Remove resource\n\n**Example:**\n```\nGET    /users        - List all users\nGET    /users/123    - Get user 123\nPOST   /users        - Create new user\nPUT    /users/123    - Update user 123\nDELETE /users/123    - Delete user 123\n```\n\n**Response typically JSON:**\n```json\n{\n  \"id\": 123,\n  \"name\": \"John\",\n  \"email\": \"john@example.com\"\n}\n```\n\n**Status codes:**\n- 200: OK\n- 201: Created\n- 400: Bad Request\n- 401: Unauthorized\n- 404: Not Found\n- 500: Server Error"}]}
{"conversations": [{"from": "human", "value": "What's the difference between null and undefined?"}, {"from": "gpt", "value": "**`undefined`:**\n- Variable declared but not assigned\n- Function parameter not provided\n- Function with no return value\n- Accessing non-existent property\n- Default, unintentional absence of value\n\n**`null`:**\n- Intentionally empty/no value\n- Explicitly assigned\n- \"I deliberately set this to nothing\"\n\n**Examples:**\n```javascript\nlet a;           // undefined\nlet b = null;    // null (intentional)\n\nfunction foo() {}\nfoo();           // returns undefined\n\nconst obj = {};\nobj.name;        // undefined\n\nlet user = null; // \"no user yet\" (intentional)\n```\n\n**Comparison:**\n```javascript\nnull == undefined   // true (loose)\nnull === undefined  // false (strict)\ntypeof null         // \"object\" (historical bug)\ntypeof undefined    // \"undefined\"\n```\n\n**Best practice:**\n- Use `null` for intentional absence\n- `undefined` happens naturally\n- Check for both: `value == null` catches both"}]}
{"conversations": [{"from": "human", "value": "What's a closure?"}, {"from": "gpt", "value": "**A closure** is when a function retains access to its outer scope, even after the outer function has returned.\n\n```javascript\nfunction outer() {\n  let count = 0;\n  \n  return function inner() {\n    count++;\n    return count;\n  };\n}\n\nconst counter = outer();\ncounter(); // 1\ncounter(); // 2\ncounter(); // 3\n```\n\n**Why it works:**\n- `inner` was created inside `outer`\n- `inner` references `count` from outer scope\n- When `outer` returns, `count` persists because `inner` still references it\n\n**Common uses:**\n\n*Private variables:*\n```javascript\nfunction createBankAccount(initial) {\n  let balance = initial; // private\n  \n  return {\n    deposit: (amount) => balance += amount,\n    getBalance: () => balance\n  };\n}\n```\n\n*Callbacks with state:*\n```javascript\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1000);\n  // Logs 0, 1, 2 (let creates new scope each iteration)\n}\n```\n\nClosures are fundamental to JavaScript patterns like modules, callbacks, and React hooks."}]}
{"conversations": [{"from": "human", "value": "What's destructuring?"}, {"from": "gpt", "value": "**Destructuring** is syntax for extracting values from arrays/objects into variables.\n\n**Array destructuring:**\n```javascript\nconst [a, b, c] = [1, 2, 3];\n// a = 1, b = 2, c = 3\n\nconst [first, ...rest] = [1, 2, 3, 4];\n// first = 1, rest = [2, 3, 4]\n\nconst [x, , z] = [1, 2, 3];\n// x = 1, z = 3 (skip second)\n```\n\n**Object destructuring:**\n```javascript\nconst { name, age } = { name: 'John', age: 30 };\n// name = 'John', age = 30\n\n// Rename:\nconst { name: userName } = { name: 'John' };\n// userName = 'John'\n\n// Default values:\nconst { name = 'Unknown' } = {};\n// name = 'Unknown'\n\n// Nested:\nconst { address: { city } } = { address: { city: 'NYC' } };\n// city = 'NYC'\n```\n\n**In function parameters:**\n```javascript\nfunction greet({ name, age }) {\n  return `Hi ${name}, you're ${age}`;\n}\n\ngreet({ name: 'John', age: 30 });\n```\n\n**Why it's useful:**\n- Cleaner code\n- Extract only what you need\n- Default values\n- Common in React and modern JS"}]}
{"conversations": [{"from": "human", "value": "What's the spread operator?"}, {"from": "gpt", "value": "**Spread operator `...`** expands arrays/objects into individual elements.\n\n**Arrays:**\n```javascript\n// Copy array\nconst copy = [...original];\n\n// Combine arrays\nconst combined = [...arr1, ...arr2];\n\n// Add elements\nconst newArr = [...arr, 4, 5];\n\n// Function arguments\nMath.max(...numbers);\n```\n\n**Objects:**\n```javascript\n// Copy object\nconst copy = { ...original };\n\n// Merge objects (later wins)\nconst merged = { ...obj1, ...obj2 };\n\n// Override properties\nconst updated = { ...user, name: 'New Name' };\n```\n\n**Rest parameters (looks same, different use):**\n```javascript\n// Collect remaining arguments\nfunction sum(...numbers) {\n  return numbers.reduce((a, b) => a + b, 0);\n}\n\n// Collect remaining properties\nconst { id, ...rest } = obj;\n```\n\n**Key difference:**\n- Spread: Expands (unpacks)\n- Rest: Collects (packs)\n\n**Note:** These are shallow copies. Nested objects are still references."}]}
{"conversations": [{"from": "human", "value": "What's map, filter, reduce?"}, {"from": "gpt", "value": "**Array methods for transforming data without mutating the original.**\n\n**map** - Transform each element:\n```javascript\nconst numbers = [1, 2, 3];\nconst doubled = numbers.map(n => n * 2);\n// [2, 4, 6]\n```\n\n**filter** - Keep elements that pass test:\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\nconst evens = numbers.filter(n => n % 2 === 0);\n// [2, 4]\n```\n\n**reduce** - Combine into single value:\n```javascript\nconst numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((acc, n) => acc + n, 0);\n// 10\n\n// More complex:\nconst items = [{price: 10}, {price: 20}];\nconst total = items.reduce((sum, item) => sum + item.price, 0);\n// 30\n```\n\n**Chaining:**\n```javascript\nconst result = users\n  .filter(u => u.active)\n  .map(u => u.name)\n  .reduce((acc, name) => acc + name + ', ', '');\n```\n\n**Why use them:**\n- Immutable (don't change original)\n- Chainable\n- Declarative (what, not how)\n- Functional programming style"}]}
{"conversations": [{"from": "human", "value": "What's a higher-order function?"}, {"from": "gpt", "value": "**A higher-order function** either:\n1. Takes a function as an argument, OR\n2. Returns a function\n\n**Takes function as argument:**\n```javascript\n// map, filter, reduce are HOFs\n[1, 2, 3].map(x => x * 2);\n\n// setTimeout\nsetTimeout(() => console.log('hi'), 1000);\n\n// Event handlers\nbutton.addEventListener('click', handleClick);\n```\n\n**Returns a function:**\n```javascript\nfunction multiply(a) {\n  return function(b) {\n    return a * b;\n  };\n}\n\nconst double = multiply(2);\ndouble(5); // 10\ndouble(10); // 20\n```\n\n**Why they matter:**\n- Enable abstraction\n- Create reusable logic\n- Enable functional programming\n- Callbacks, middleware, decorators\n\n**Common examples:**\n- `Array.map`, `filter`, `reduce`\n- `setTimeout`, `setInterval`\n- `Promise.then`\n- React's `useState`, `useEffect`"}]}
{"conversations": [{"from": "human", "value": "What's a class in programming?"}, {"from": "gpt", "value": "**A class** is a blueprint for creating objects with shared structure and behavior.\n\n**JavaScript class:**\n```javascript\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  \n  greet() {\n    return `Hi, I'm ${this.name}`;\n  }\n  \n  static species() {\n    return 'Homo sapiens';\n  }\n}\n\nconst john = new Person('John', 30);\njohn.greet();        // \"Hi, I'm John\"\nPerson.species();    // \"Homo sapiens\"\n```\n\n**Python class:**\n```python\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def greet(self):\n        return f\"Hi, I'm {self.name}\"\n```\n\n**Key concepts:**\n- **Constructor**: Initializes new instance\n- **Methods**: Functions attached to the class\n- **Properties**: Data stored on instance\n- **Static methods**: Belong to class, not instance\n- **Inheritance**: `class Child extends Parent`\n\n**Classes vs. objects:**\n- Class = blueprint\n- Object = instance created from blueprint"}]}
{"conversations": [{"from": "human", "value": "What's inheritance?"}, {"from": "gpt", "value": "**Inheritance** lets a class inherit properties and methods from another class.\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    return `${this.name} makes a sound`;\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name);  // Call parent constructor\n    this.breed = breed;\n  }\n  \n  speak() {\n    return `${this.name} barks`;\n  }\n  \n  fetch() {\n    return `${this.name} fetches the ball`;\n  }\n}\n\nconst dog = new Dog('Rex', 'German Shepherd');\ndog.speak();  // \"Rex barks\" (overridden)\ndog.fetch();  // \"Rex fetches the ball\" (new method)\ndog.name;     // \"Rex\" (inherited property)\n```\n\n**Key concepts:**\n- `extends` - Inherit from parent\n- `super()` - Call parent constructor\n- **Override**: Replace parent method\n- **Polymorphism**: Same interface, different behavior\n\n**\"Is-a\" relationship:**\n- A Dog IS AN Animal\n- A Square IS A Shape\n\n**Composition over inheritance:**\nMany favor composing objects from smaller pieces rather than deep inheritance hierarchies."}]}
{"conversations": [{"from": "human", "value": "What's the difference between frontend and backend?"}, {"from": "gpt", "value": "**Frontend (client-side):**\n\nWhat users see and interact with.\n\n- HTML, CSS, JavaScript\n- Frameworks: React, Vue, Angular\n- Runs in browser\n- UI/UX, design\n- Sends requests to backend\n\n**Backend (server-side):**\n\nLogic, data, and processing users don't see.\n\n- Servers, databases, APIs\n- Languages: Python, Node.js, Java, Go, Ruby\n- Handles business logic\n- Authentication, data storage\n- Responds to frontend requests\n\n**Simple flow:**\n```\nUser → Frontend → API Request → Backend → Database\n                               ↓\nUser ← Frontend ← API Response ← Backend\n```\n\n**Example:**\n- User clicks \"Login\" (frontend)\n- Frontend sends credentials to backend\n- Backend checks database, validates\n- Backend sends response (success/fail)\n- Frontend shows result to user\n\n**Full-stack:**\nDeveloper who does both.\n\n**Technologies overlap:**\n- JavaScript (Node.js) runs on backend too\n- TypeScript used in both\n- API connects them"}]}
{"conversations": [{"from": "human", "value": "What's an ORM?"}, {"from": "gpt", "value": "**ORM = Object-Relational Mapping**\n\nTranslates between database tables and programming objects.\n\n**Without ORM (raw SQL):**\n```python\ncursor.execute(\"SELECT * FROM users WHERE id = 1\")\nrow = cursor.fetchone()\nuser_name = row['name']\n```\n\n**With ORM:**\n```python\nuser = User.query.get(1)\nuser_name = user.name\n```\n\n**Popular ORMs:**\n- Python: SQLAlchemy, Django ORM\n- JavaScript: Prisma, Sequelize, TypeORM\n- Ruby: ActiveRecord\n- Java: Hibernate\n\n**Benefits:**\n- Write database logic in your language\n- Database-agnostic (can switch databases)\n- Type safety\n- Less SQL to write\n- Relationships handled automatically\n\n**Drawbacks:**\n- Performance overhead\n- Complex queries can be harder\n- Abstraction hides what's happening\n- Learning curve\n\n**Example (Prisma):**\n```javascript\nconst users = await prisma.user.findMany({\n  where: { active: true },\n  include: { posts: true }\n});\n```\n\n**Use it when:** Standard CRUD operations, rapid development.\n**Maybe avoid when:** Complex queries, performance-critical."}]}
{"conversations": [{"from": "human", "value": "What's a virtual environment?"}, {"from": "gpt", "value": "**A virtual environment** isolates project dependencies so they don't conflict.\n\n**The problem:**\n- Project A needs library v1.0\n- Project B needs library v2.0\n- Both on same computer - conflict!\n\n**The solution:**\nEach project gets its own isolated set of packages.\n\n**Python (venv):**\n```bash\n# Create\npython -m venv myenv\n\n# Activate (Mac/Linux)\nsource myenv/bin/activate\n\n# Activate (Windows)\nmyenv\\Scripts\\activate\n\n# Install packages (goes to this env only)\npip install requests\n\n# Deactivate\ndeactivate\n```\n\n**Node.js:**\nDoes this automatically with `node_modules` folder. Each project has its own.\n\n**Why it matters:**\n- No version conflicts between projects\n- Reproducible environments\n- Can specify exact versions\n- `requirements.txt` or `package.json` tracks dependencies\n\n**Best practice:**\n- Always use virtual environments\n- Don't install packages globally\n- Include `requirements.txt` or `package-lock.json` in version control\n- `.gitignore` the environment folder itself"}]}
{"conversations": [{"from": "human", "value": "What's the difference between SQL and NoSQL?"}, {"from": "gpt", "value": "**SQL (Relational):**\n\n- Data in tables with rows and columns\n- Structured schema (defined upfront)\n- Relationships via foreign keys\n- ACID transactions\n- SQL query language\n- Examples: PostgreSQL, MySQL, SQLite\n\n**NoSQL:**\n\n- Various formats (document, key-value, graph)\n- Flexible schema\n- Optimized for specific use cases\n- Often sacrifices some consistency for scale\n- Examples: MongoDB, Redis, Cassandra, Neo4j\n\n**Types of NoSQL:**\n- **Document**: MongoDB (JSON-like documents)\n- **Key-value**: Redis (simple key → value)\n- **Wide-column**: Cassandra (big data)\n- **Graph**: Neo4j (relationships)\n\n**When to use SQL:**\n- Complex relationships\n- Need transactions\n- Structured data\n- Most traditional applications\n\n**When to use NoSQL:**\n- Flexible/changing schema\n- Massive scale\n- Document/JSON-centric\n- Specific use case (caching, graphs, time series)\n\n**Reality:**\nSQL handles most use cases. NoSQL for specific needs. Many apps use both."}]}
{"conversations": [{"from": "human", "value": "What's CRUD?"}, {"from": "gpt", "value": "**CRUD = Create, Read, Update, Delete**\n\nThe four basic operations for persistent data.\n\n**In database terms:**\n- **Create**: `INSERT INTO users (name) VALUES ('John')`\n- **Read**: `SELECT * FROM users WHERE id = 1`\n- **Update**: `UPDATE users SET name = 'Jane' WHERE id = 1`\n- **Delete**: `DELETE FROM users WHERE id = 1`\n\n**In REST API terms:**\n- **Create**: `POST /users`\n- **Read**: `GET /users` or `GET /users/1`\n- **Update**: `PUT /users/1` or `PATCH /users/1`\n- **Delete**: `DELETE /users/1`\n\n**In ORM terms:**\n```javascript\n// Create\nUser.create({ name: 'John' })\n\n// Read\nUser.findById(1)\n\n// Update\nUser.update({ name: 'Jane' }, { where: { id: 1 } })\n\n// Delete\nUser.destroy({ where: { id: 1 } })\n```\n\n**Why it matters:**\nMost applications are fundamentally CRUD operations on data. Understanding this helps you think about app architecture.\n\n\"CRUD app\" = app that mostly does these operations (admin panels, content management, etc.)"}]}
{"conversations": [{"from": "human", "value": "What's a race condition?"}, {"from": "gpt", "value": "**A race condition** occurs when code behavior depends on timing of uncontrolled events (like which thread runs first).\n\n**Example problem:**\n```\nAccount balance: $100\n\nThread 1: Read balance ($100), add $50\nThread 2: Read balance ($100), subtract $20\nThread 1: Write $150\nThread 2: Write $80\n\nFinal: $80 (should be $130!)\n```\n\nBoth threads read the old value before either wrote.\n\n**In JavaScript (async):**\n```javascript\nlet count = 0;\n\nasync function increment() {\n  const current = count;  // Read\n  await someAsyncWork();  // Other code might run here\n  count = current + 1;    // Write (based on stale data)\n}\n\n// If called twice quickly, might only increment once\n```\n\n**Solutions:**\n- **Locks/Mutexes**: One thread at a time\n- **Atomic operations**: Read-modify-write as single operation\n- **Queuing**: Process one at a time\n- **Transactions**: Database handles atomicity\n\n**How to prevent:**\n- Be aware when sharing mutable state\n- Use proper synchronization\n- Prefer immutable data\n- Test under concurrent conditions\n\nRace conditions are hard to debug because they're timing-dependent."}]}
{"conversations": [{"from": "human", "value": "What's a memory leak?"}, {"from": "gpt", "value": "**A memory leak** is when a program holds onto memory it no longer needs, causing memory usage to grow over time.\n\n**Common causes:**\n\n**JavaScript:**\n```javascript\n// Forgotten event listeners\nelement.addEventListener('click', handler);\n// Element removed, but listener keeps references alive\n\n// Closures holding references\nfunction createClosure() {\n  const hugeData = new Array(1000000);\n  return function() {\n    // hugeData can never be garbage collected\n  };\n}\n\n// Global variables accumulating\nwindow.cache = []; // Keeps growing\n\n// Forgotten timers\nsetInterval(() => {...}, 1000); // Never cleared\n```\n\n**Symptoms:**\n- App gets slower over time\n- Browser tab uses more and more memory\n- Eventually crashes or freezes\n\n**How to find:**\n- Browser DevTools → Memory tab\n- Take heap snapshots\n- Look for objects that should be gone\n\n**How to prevent:**\n- Clean up event listeners\n- Clear intervals/timeouts\n- Be careful with closures\n- Use WeakMap/WeakSet when appropriate\n- Avoid global state accumulation\n\nIn garbage-collected languages, \"leak\" usually means keeping unintended references, not truly lost memory."}]}
