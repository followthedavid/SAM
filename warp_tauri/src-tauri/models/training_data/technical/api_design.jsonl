{"conversations": [{"from": "human", "value": "How do I design a good REST API?"}, {"from": "gpt", "value": "**Core principles:**\n\n**1. Resources, not actions**\n```\n# Bad\nPOST /getUsers\nPOST /createUser\n\n# Good\nGET /users\nPOST /users\n```\n\n**2. Use HTTP methods correctly**\n- GET: Read (idempotent)\n- POST: Create\n- PUT: Replace entire resource\n- PATCH: Partial update\n- DELETE: Remove\n\n**3. Consistent naming**\n```\n# Use plural nouns\n/users, /products, /orders\n\n# Nested resources\n/users/123/orders\n/orders/456/items\n\n# Query params for filtering\n/users?status=active&limit=10\n```\n\n**4. Proper status codes**\n```\n200 OK - Success (GET, PUT, PATCH)\n201 Created - Resource created (POST)\n204 No Content - Success, no body (DELETE)\n400 Bad Request - Client error, invalid input\n401 Unauthorized - Not authenticated\n403 Forbidden - Authenticated but not permitted\n404 Not Found - Resource doesn't exist\n409 Conflict - State conflict\n422 Unprocessable Entity - Validation failed\n500 Internal Server Error - Server bug\n```\n\n**5. Response format**\n```json\n{\n  \"data\": { ... },\n  \"meta\": { \"total\": 100, \"page\": 1 },\n  \"errors\": null\n}\n```\n\n**6. Versioning**\n- URL path: `/v1/users`\n- Header: `Accept: application/vnd.api+json;version=1`\n\n**7. Pagination**\n```\n/users?page=2&limit=20\n/users?cursor=abc123&limit=20\n```\n\nWhat kind of API are you designing?"}]}
{"conversations": [{"from": "human", "value": "REST vs GraphQL vs gRPC?"}, {"from": "gpt", "value": "**REST:**\n\nPros:\n- Simple, well-understood\n- HTTP caching works out of the box\n- Wide tooling support\n- Stateless\n\nCons:\n- Over-fetching (get whole resource when you need 2 fields)\n- Under-fetching (need multiple requests for related data)\n- No built-in schema\n\nBest for: Public APIs, simple CRUD, when caching matters\n\n**GraphQL:**\n\nPros:\n- Client specifies exact data needed\n- Single endpoint, single request for complex data\n- Strong typing, introspection\n- Great for mobile (minimize payloads)\n\nCons:\n- Caching is harder\n- N+1 query problems on backend\n- Complexity overhead for simple cases\n- Learning curve\n\nBest for: Complex UIs, mobile apps, multiple clients with different needs\n\n**gRPC:**\n\nPros:\n- Fast (binary protocol, HTTP/2)\n- Strongly typed (Protocol Buffers)\n- Bi-directional streaming\n- Code generation\n\nCons:\n- Not browser-friendly (needs proxy)\n- Harder to debug (binary)\n- More complex setup\n\nBest for: Internal microservices, high-performance systems, streaming\n\n**TL;DR:**\n- Public API with simple needs → REST\n- Complex data requirements, multiple clients → GraphQL\n- Internal services, need performance → gRPC\n- Many companies use all three for different purposes\n\nWhat's your use case?"}]}
{"conversations": [{"from": "human", "value": "How do I handle API errors properly?"}, {"from": "gpt", "value": "**Consistent error format:**\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Human readable message\",\n    \"details\": [\n      {\n        \"field\": \"email\",\n        \"message\": \"Invalid email format\"\n      }\n    ],\n    \"request_id\": \"abc123\"\n  }\n}\n```\n\n**Error codes:**\n- Machine-readable, stable\n- Don't change between versions\n- Document all possible codes\n\n```python\nclass ErrorCodes:\n    VALIDATION_ERROR = \"VALIDATION_ERROR\"\n    NOT_FOUND = \"NOT_FOUND\"\n    UNAUTHORIZED = \"UNAUTHORIZED\"\n    RATE_LIMITED = \"RATE_LIMITED\"\n    INTERNAL_ERROR = \"INTERNAL_ERROR\"\n```\n\n**HTTP status alignment:**\n```python\nerror_status_map = {\n    ErrorCodes.VALIDATION_ERROR: 400,\n    ErrorCodes.NOT_FOUND: 404,\n    ErrorCodes.UNAUTHORIZED: 401,\n    ErrorCodes.RATE_LIMITED: 429,\n    ErrorCodes.INTERNAL_ERROR: 500,\n}\n```\n\n**What NOT to expose:**\n- Stack traces (security risk)\n- Database errors directly\n- Internal system names\n- Sensitive data in error messages\n\n**What TO include:**\n- Request ID (for correlation in logs)\n- Retry-After header for rate limits\n- Documentation link for complex errors\n- Enough detail to fix the request\n\n**Implementation:**\n```python\n@app.exception_handler(APIError)\nasync def api_error_handler(request, exc):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\n            \"error\": {\n                \"code\": exc.code,\n                \"message\": exc.message,\n                \"details\": exc.details,\n                \"request_id\": request.state.request_id\n            }\n        }\n    )\n```"}]}
{"conversations": [{"from": "human", "value": "How do I version my API?"}, {"from": "gpt", "value": "**Options:**\n\n**1. URL path (most common)**\n```\n/v1/users\n/v2/users\n```\nPros: Obvious, easy routing\nCons: Duplicates code paths\n\n**2. Query parameter**\n```\n/users?version=1\n```\nPros: Same URL structure\nCons: Feels wrong, easy to forget\n\n**3. Header**\n```\nAccept: application/vnd.myapi.v1+json\n```\nPros: Clean URLs, semantic\nCons: Less visible, harder to test\n\n**4. No versioning (evolve carefully)**\n- Only add fields, never remove\n- New behavior behind feature flags\n- Eventually deprecate old patterns\n\n**Practical advice:**\n\n**Go with URL path versioning** unless you have good reason not to.\n- It's the most common\n- Easy to understand and implement\n- Works with all tooling\n\n**When to create a new version:**\n- Breaking change to response format\n- Removing a field\n- Changing authentication\n- Changing fundamental behavior\n\n**When NOT to:**\n- Adding fields (backward compatible)\n- Adding new endpoints\n- Bug fixes\n\n**Migration strategy:**\n```\n1. Build v2 alongside v1\n2. Deprecation notice in v1 responses\n3. Give clients migration window (6-12 months)\n4. Monitor v1 usage\n5. Remove v1 when usage is negligible\n```\n\nHow stable does your API need to be?"}]}
{"conversations": [{"from": "human", "value": "How should I handle authentication in APIs?"}, {"from": "gpt", "value": "**Common patterns:**\n\n**API Keys:**\n```\nAuthorization: Api-Key sk_live_abc123\n# or\nX-API-Key: sk_live_abc123\n```\n- Simple to implement\n- Good for server-to-server\n- Don't use in frontend (exposed in browser)\n\n**JWT (JSON Web Tokens):**\n```\nAuthorization: Bearer eyJhbGciOi...\n```\n- Self-contained (includes claims)\n- Stateless (no server lookup needed)\n- Has expiration built in\n- Good for user authentication\n\n**JWT structure:**\n```json\n// Header\n{\"alg\": \"HS256\", \"typ\": \"JWT\"}\n// Payload\n{\"sub\": \"user123\", \"exp\": 1700000000, \"roles\": [\"admin\"]}\n// Signature\nHMAC-SHA256(header + payload, secret)\n```\n\n**OAuth 2.0:**\n- Use for third-party access (\"Sign in with Google\")\n- User grants limited access without sharing credentials\n- Different flows for different client types\n\n**Implementation:**\n```python\n@app.middleware(\"http\")\nasync def auth_middleware(request, call_next):\n    auth = request.headers.get(\"Authorization\")\n    if not auth or not auth.startswith(\"Bearer \"):\n        return JSONResponse({\"error\": \"Unauthorized\"}, 401)\n    \n    token = auth.replace(\"Bearer \", \"\")\n    try:\n        payload = jwt.decode(token, SECRET, algorithms=[\"HS256\"])\n        request.state.user = payload[\"sub\"]\n    except jwt.ExpiredSignatureError:\n        return JSONResponse({\"error\": \"Token expired\"}, 401)\n    except jwt.InvalidTokenError:\n        return JSONResponse({\"error\": \"Invalid token\"}, 401)\n    \n    return await call_next(request)\n```\n\n**Security checklist:**\n- HTTPS only (never send tokens over HTTP)\n- Short expiration (15 min for access, days for refresh)\n- Refresh token rotation\n- Rate limit auth endpoints\n- Don't log tokens\n\nWhat's your authentication scenario?"}]}
{"conversations": [{"from": "human", "value": "How do I handle rate limiting?"}, {"from": "gpt", "value": "**Algorithms:**\n\n**Token bucket (most common):**\n- Bucket fills at constant rate\n- Request takes a token\n- Empty bucket = rejected\n- Allows bursts up to bucket size\n\n**Sliding window:**\n- Track requests in rolling time window\n- More precise than fixed windows\n\n**Implementation (Redis):**\n```python\nimport redis\nimport time\n\ndef is_rate_limited(user_id: str, limit: int = 100, window: int = 60) -> bool:\n    r = redis.Redis()\n    key = f\"rate_limit:{user_id}\"\n    now = time.time()\n    \n    # Remove old entries\n    r.zremrangebyscore(key, 0, now - window)\n    \n    # Count current\n    count = r.zcard(key)\n    \n    if count >= limit:\n        return True\n    \n    # Add this request\n    r.zadd(key, {str(now): now})\n    r.expire(key, window)\n    \n    return False\n```\n\n**Response headers:**\n```\nX-RateLimit-Limit: 100\nX-RateLimit-Remaining: 42\nX-RateLimit-Reset: 1640000000\nRetry-After: 30  # On 429\n```\n\n**Different limits by:**\n- Endpoint sensitivity\n- User plan (free vs paid)\n- Authentication level\n- IP vs user vs API key\n\n**When rate limited (429):**\n```json\n{\n  \"error\": {\n    \"code\": \"RATE_LIMITED\",\n    \"message\": \"Too many requests\",\n    \"retry_after\": 30\n  }\n}\n```\n\n**Client-side handling:**\n```javascript\nasync function fetchWithRetry(url, options, maxRetries = 3) {\n  for (let i = 0; i < maxRetries; i++) {\n    const res = await fetch(url, options);\n    if (res.status !== 429) return res;\n    \n    const retryAfter = res.headers.get('Retry-After') || 60;\n    await sleep(retryAfter * 1000);\n  }\n  throw new Error('Rate limited');\n}\n```\n\nWhat kind of traffic patterns are you expecting?"}]}
{"conversations": [{"from": "human", "value": "How do I document my API?"}, {"from": "gpt", "value": "**OpenAPI/Swagger (standard):**\n```yaml\nopenapi: 3.0.0\ninfo:\n  title: My API\n  version: 1.0.0\npaths:\n  /users:\n    get:\n      summary: List users\n      parameters:\n        - name: limit\n          in: query\n          schema:\n            type: integer\n            default: 20\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/User'\n```\n\n**Generate from code:**\n```python\n# FastAPI does this automatically\n@app.get(\"/users\", response_model=List[User])\nasync def get_users(limit: int = 20):\n    \"\"\"List all users with pagination.\"\"\"\n    ...\n```\n\n**Documentation should include:**\n\n1. **Authentication** - How to get and use tokens\n2. **Base URL** - Different for staging/production\n3. **Rate limits** - What they are, how they work\n4. **Errors** - All error codes and meanings\n5. **Examples** - Real request/response examples\n6. **Changelog** - What changed between versions\n\n**Per-endpoint:**\n- Description of what it does\n- All parameters (required/optional)\n- Request body schema\n- Response schema\n- Example request (curl)\n- Example response\n- Possible errors\n\n**Tools:**\n- Swagger UI - Interactive docs from OpenAPI\n- Redoc - Beautiful docs from OpenAPI\n- Postman - Collections as documentation\n- ReadMe - Full documentation platform\n\n**Best practices:**\n- Docs live with code (auto-generated when possible)\n- Examples that actually work\n- Update docs in same PR as API changes\n- Test your examples in CI\n\nWhat's your tech stack?"}]}
