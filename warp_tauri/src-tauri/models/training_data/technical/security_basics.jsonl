{"conversations": [{"from": "human", "value": "How do I secure my web application?"}, {"from": "gpt", "value": "**The OWASP Top 10 (most common vulnerabilities):**\n\n**1. Injection (SQL, Command, etc.):**\n```python\n# BAD\nquery = f\"SELECT * FROM users WHERE id = {user_input}\"\n\n# GOOD - Parameterized query\ncursor.execute(\"SELECT * FROM users WHERE id = ?\", (user_input,))\n```\n\n**2. Broken Authentication:**\n- Strong password requirements\n- Rate limiting on login\n- MFA\n- Secure session management\n- httpOnly, Secure cookies\n\n**3. Sensitive Data Exposure:**\n- HTTPS everywhere\n- Hash passwords (bcrypt, argon2)\n- Encrypt sensitive data at rest\n- Don't log sensitive data\n\n**4. XSS (Cross-Site Scripting):**\n```javascript\n// BAD\nelement.innerHTML = userInput;\n\n// GOOD\nelement.textContent = userInput;\n// Or use framework's auto-escaping\n```\n\n**5. Broken Access Control:**\n```python\n# BAD - Only checks if logged in\n@login_required\ndef get_document(doc_id):\n    return Document.query.get(doc_id)\n\n# GOOD - Checks ownership\n@login_required\ndef get_document(doc_id):\n    doc = Document.query.get(doc_id)\n    if doc.owner_id != current_user.id:\n        abort(403)\n    return doc\n```\n\n**6. Security Misconfiguration:**\n- Disable debug mode in production\n- Remove default credentials\n- Keep dependencies updated\n- Harden server configs\n\n**Security headers:**\n```python\n# Express/Node\napp.use(helmet());\n\n# Manual\nContent-Security-Policy: default-src 'self'\nX-Content-Type-Options: nosniff\nX-Frame-Options: DENY\nStrict-Transport-Security: max-age=31536000\n```\n\n**Checklist:**\n- [ ] HTTPS only\n- [ ] Parameterized queries\n- [ ] Input validation\n- [ ] Output encoding\n- [ ] Authentication rate limiting\n- [ ] Authorization checks on every endpoint\n- [ ] Security headers\n- [ ] Dependencies updated\n- [ ] Secrets not in code\n\nWhat's your stack?"}]}
{"conversations": [{"from": "human", "value": "How do I hash passwords properly?"}, {"from": "gpt", "value": "**The rules:**\n1. NEVER store plaintext passwords\n2. NEVER use MD5 or SHA for passwords (too fast)\n3. USE purpose-built password hashing algorithms\n4. USE a library, don't implement yourself\n\n**Recommended algorithms (in order):**\n1. Argon2id (winner of Password Hashing Competition)\n2. bcrypt (proven, widely supported)\n3. scrypt (memory-hard)\n\n**Python with bcrypt:**\n```python\nimport bcrypt\n\n# Hashing\ndef hash_password(password: str) -> str:\n    salt = bcrypt.gensalt(rounds=12)  # Work factor\n    return bcrypt.hashpw(password.encode(), salt).decode()\n\n# Verification\ndef verify_password(password: str, hashed: str) -> bool:\n    return bcrypt.checkpw(password.encode(), hashed.encode())\n\n# Usage\nhashed = hash_password(\"user_password\")\n# Store `hashed` in database\n\n# On login\nif verify_password(submitted_password, stored_hash):\n    # Success\n```\n\n**Python with Argon2:**\n```python\nfrom argon2 import PasswordHasher\n\nph = PasswordHasher()\n\n# Hash\nhashed = ph.hash(\"password\")\n\n# Verify\ntry:\n    ph.verify(hashed, \"password\")\n    # Success\nexcept:\n    # Failed\n```\n\n**Node.js:**\n```javascript\nimport bcrypt from 'bcrypt';\n\nconst hash = await bcrypt.hash(password, 12);\nconst match = await bcrypt.compare(password, hash);\n```\n\n**Why these work:**\n- Slow by design (adjustable work factor)\n- Include salt automatically\n- Resistant to GPU attacks\n- Constant-time comparison\n\n**Never do this:**\n```python\n# TERRIBLE\nhash = md5(password)\nhash = sha256(password)\nhash = sha256(password + \"static_salt\")\n```\n\nThese are cryptographic hashes, not password hashes. They're designed to be fast."}]}
{"conversations": [{"from": "human", "value": "What is CSRF and how do I prevent it?"}, {"from": "gpt", "value": "**CSRF (Cross-Site Request Forgery):**\nAttacker tricks user's browser into making authenticated requests to your site.\n\n**How it works:**\n1. User logs into yourbank.com (has session cookie)\n2. User visits evil.com\n3. Evil.com has: `<img src=\"https://yourbank.com/transfer?to=attacker&amount=1000\">`\n4. Browser sends request WITH user's cookies\n5. Bank processes transfer\n\n**Prevention methods:**\n\n**1. CSRF Tokens (most common):**\n```html\n<!-- Server generates unique token per session/request -->\n<form method=\"POST\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"random_token_here\">\n  ...\n</form>\n```\n\n```python\n# Server validates\nif request.form['csrf_token'] != session['csrf_token']:\n    abort(403)\n```\n\n**2. SameSite Cookies:**\n```python\n# Set on session cookie\nSet-Cookie: session=abc123; SameSite=Strict; Secure; HttpOnly\n```\n- `Strict`: Never sent cross-site\n- `Lax`: Sent on top-level navigations (default in modern browsers)\n\n**3. Check Origin/Referer headers:**\n```python\ndef check_origin(request):\n    origin = request.headers.get('Origin') or request.headers.get('Referer')\n    if not origin or not origin.startswith('https://yoursite.com'):\n        abort(403)\n```\n\n**Framework implementations:**\n\n**Flask:**\n```python\nfrom flask_wtf.csrf import CSRFProtect\ncsrf = CSRFProtect(app)\n```\n\n**Django:** Built-in, enabled by default\n```python\nMIDDLEWARE = ['django.middleware.csrf.CsrfViewMiddleware', ...]\n```\n\n**Express:**\n```javascript\nimport csrf from 'csurf';\napp.use(csrf({ cookie: true }));\n```\n\n**For APIs:**\n- Use token-based auth (Bearer tokens) instead of cookies\n- No cookies = no CSRF\n- Or use custom headers (can't be sent cross-origin)\n\nWhat's your setup?"}]}
{"conversations": [{"from": "human", "value": "How do I prevent SQL injection?"}, {"from": "gpt", "value": "**The problem:**\n```python\n# User input: \"' OR '1'='1\"\nquery = f\"SELECT * FROM users WHERE username = '{username}'\"\n# Becomes: SELECT * FROM users WHERE username = '' OR '1'='1'\n# Returns ALL users!\n```\n\n**The solution: NEVER concatenate user input into queries.**\n\n**Use parameterized queries:**\n\n**Python (sqlite3):**\n```python\n# BAD\ncursor.execute(f\"SELECT * FROM users WHERE id = {user_id}\")\n\n# GOOD\ncursor.execute(\"SELECT * FROM users WHERE id = ?\", (user_id,))\n```\n\n**Python (psycopg2/PostgreSQL):**\n```python\ncursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))\n```\n\n**Python (SQLAlchemy):**\n```python\n# ORM - automatically safe\nUser.query.filter_by(username=username).first()\n\n# Raw SQL - use text()\nfrom sqlalchemy import text\ndb.execute(text(\"SELECT * FROM users WHERE id = :id\"), {\"id\": user_id})\n```\n\n**Node.js (pg):**\n```javascript\n// BAD\nawait client.query(`SELECT * FROM users WHERE id = ${userId}`);\n\n// GOOD\nawait client.query('SELECT * FROM users WHERE id = $1', [userId]);\n```\n\n**Java (JDBC):**\n```java\n// BAD\nStatement stmt = conn.createStatement();\nstmt.executeQuery(\"SELECT * FROM users WHERE id = \" + userId);\n\n// GOOD\nPreparedStatement pstmt = conn.prepareStatement(\"SELECT * FROM users WHERE id = ?\");\npstmt.setInt(1, userId);\n```\n\n**Additional protections:**\n- Input validation (but NOT as primary defense)\n- Least privilege database accounts\n- Web Application Firewall (WAF)\n- Escape output (defense in depth)\n\n**Testing:**\n```bash\n# Try these in input fields\n' OR '1'='1\n'; DROP TABLE users;--\n1; SELECT * FROM users\n```\n\nIf your app breaks or shows unexpected data, you have a problem."}]}
{"conversations": [{"from": "human", "value": "What is XSS and how do I prevent it?"}, {"from": "gpt", "value": "**XSS (Cross-Site Scripting):**\nAttacker injects malicious JavaScript that runs in victims' browsers.\n\n**Types:**\n\n**Stored XSS:**\n- Malicious script saved in database\n- Every user who views the page executes it\n- Example: Forum post containing `<script>steal(document.cookie)</script>`\n\n**Reflected XSS:**\n- Script in URL parameter, reflected back in page\n- Example: `https://site.com/search?q=<script>alert('xss')</script>`\n\n**DOM XSS:**\n- Client-side JavaScript unsafely handles data\n- Example: `document.innerHTML = location.hash`\n\n**Prevention:**\n\n**1. Output encoding (primary defense):**\n```javascript\n// BAD\nelement.innerHTML = userInput;\n\n// GOOD\nelement.textContent = userInput;\n// Or use framework's escaping\n```\n\n**2. Use frameworks that auto-escape:**\n```jsx\n// React - auto-escaped\n<div>{userInput}</div>\n\n// Dangerous - explicitly required\n<div dangerouslySetInnerHTML={{__html: userInput}} />\n```\n\n**3. Content Security Policy:**\n```http\nContent-Security-Policy: default-src 'self'; script-src 'self'\n```\nBlocks inline scripts, only allows scripts from your domain.\n\n**4. Sanitize HTML if you must allow it:**\n```javascript\nimport DOMPurify from 'dompurify';\nconst clean = DOMPurify.sanitize(dirtyHTML);\n```\n\n**5. HttpOnly cookies:**\n```http\nSet-Cookie: session=abc; HttpOnly\n```\nPrevents JavaScript from reading cookies.\n\n**Context-specific encoding:**\n```html\n<!-- HTML context -->\n&lt;script&gt;alert('xss')&lt;/script&gt;\n\n<!-- JavaScript context -->\nvar x = \"user\\x22input\";\n\n<!-- URL context -->\nhttps://site.com/search?q=user%22input\n\n<!-- CSS context -->\nbackground: url(user\\22input);\n```\n\n**Testing:**\n```html\n<script>alert('XSS')</script>\n<img src=x onerror=alert('XSS')>\n<svg onload=alert('XSS')>\n```\n\nIf these execute, you have a vulnerability."}]}
{"conversations": [{"from": "human", "value": "How do I manage secrets securely?"}, {"from": "gpt", "value": "**Rule #1: Never commit secrets to version control.**\n\n**Environment variables (basic):**\n```bash\n# .env file (NOT committed)\nDATABASE_URL=postgres://user:pass@host/db\nAPI_KEY=sk_live_xxxxx\nJWT_SECRET=random_secure_string\n```\n\n```python\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\ndb_url = os.getenv('DATABASE_URL')\n```\n\n**Git protection:**\n```gitignore\n# .gitignore\n.env\n.env.local\n*.pem\n*_secret*\nconfig/secrets.yml\n```\n\n**Pre-commit hook:**\n```bash\n# Prevent committing secrets\npip install detect-secrets\ndetect-secrets scan > .secrets.baseline\ndetect-secrets-hook --baseline .secrets.baseline\n```\n\n**Secrets managers (production):**\n\n**AWS Secrets Manager:**\n```python\nimport boto3\n\nclient = boto3.client('secretsmanager')\nresponse = client.get_secret_value(SecretId='my-app/prod')\nsecrets = json.loads(response['SecretString'])\n```\n\n**HashiCorp Vault:**\n```python\nimport hvac\n\nclient = hvac.Client(url='https://vault.example.com')\nsecret = client.secrets.kv.v2.read_secret_version(path='my-app/config')\n```\n\n**12-Factor App approach:**\n- Config in environment, not code\n- Different values per environment\n- Easy to change without deploy\n\n**Rotation:**\n- Rotate secrets regularly\n- Use short-lived credentials when possible\n- Have a plan for compromised secrets\n\n**What to do if you committed a secret:**\n1. Rotate the secret immediately\n2. Remove from Git history (git filter-branch or BFG)\n3. Force push (coordinate with team)\n4. Check access logs\n\n```bash\n# Remove from history\ngit filter-branch --force --index-filter \\\n  'git rm --cached --ignore-unmatch path/to/file' \\\n  HEAD\n```\n\nWhat's your deployment environment?"}]}
{"conversations": [{"from": "human", "value": "How do I implement rate limiting?"}, {"from": "gpt", "value": "**Why rate limit:**\n- Prevent abuse/DoS\n- Protect expensive operations\n- Enforce API quotas\n- Prevent brute force attacks\n\n**Express.js with express-rate-limit:**\n```javascript\nimport rateLimit from 'express-rate-limit';\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // 100 requests per window\n  message: { error: 'Too many requests' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(limiter);\n\n// Stricter for auth endpoints\nconst authLimiter = rateLimit({\n  windowMs: 60 * 60 * 1000, // 1 hour\n  max: 5, // 5 attempts\n});\n\napp.use('/api/auth', authLimiter);\n```\n\n**Python/Flask with Flask-Limiter:**\n```python\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\nlimiter = Limiter(\n    app,\n    key_func=get_remote_address,\n    default_limits=[\"200 per day\", \"50 per hour\"]\n)\n\n@app.route(\"/api/expensive\")\n@limiter.limit(\"10 per minute\")\ndef expensive_operation():\n    pass\n\n@app.route(\"/api/auth/login\")\n@limiter.limit(\"5 per minute\")\ndef login():\n    pass\n```\n\n**Redis-backed (distributed):**\n```python\nimport redis\nimport time\n\nr = redis.Redis()\n\ndef is_rate_limited(user_id, limit=100, window=60):\n    key = f\"rate_limit:{user_id}\"\n    current = r.get(key)\n    \n    if current is None:\n        r.setex(key, window, 1)\n        return False\n    \n    if int(current) >= limit:\n        return True\n    \n    r.incr(key)\n    return False\n```\n\n**Response headers:**\n```http\nX-RateLimit-Limit: 100\nX-RateLimit-Remaining: 45\nX-RateLimit-Reset: 1640000000\n```\n\n**When limited (429):**\n```http\nHTTP/1.1 429 Too Many Requests\nRetry-After: 60\nContent-Type: application/json\n\n{\"error\": \"Rate limit exceeded\", \"retry_after\": 60}\n```\n\n**Different limits for:**\n- Anonymous users (strict)\n- Authenticated users (moderate)\n- Paid plans (generous)\n- Auth endpoints (very strict)\n\nWhat's your use case?"}]}
