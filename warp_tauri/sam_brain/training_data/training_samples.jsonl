{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def transform", "output": "def transform(self, input_data, return_phase=False):\n\"\"\"Take input data (audio) to STFT domain.\n\nArguments:\ninput_data {tensor} -- Tensor of floats, with shape (num_batch, num_samples)\n\nReturns:\nmagnitude {tensor} -- Magnitude of STFT with shape (num_batch,\nnum_frequencies, num_frames)\nphase {tensor} -- Phase of STFT with shape (num_batch,", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def inverse", "output": "def inverse(self, magnitude, phase):\n\"\"\"Call the inverse STFT (iSTFT), given magnitude and phase tensors produced\nby the ```transform``` function.\n\nArguments:\nmagnitude {tensor} -- Magnitude of STFT with shape (num_batch,\nnum_frequencies, num_frames)\nphase {tensor} -- Phase of STFT with shape (num_batch,\nnum_frequencies, num_frames)\n", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, agg, model_path, device, is_half, tta=False):", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, agg, model_path, device, is_half, tta=False):", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def uvr", "output": "def uvr(model_name, inp_root, save_root_vocal, paths, save_root_ins, agg, format0):", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def cache_harvest_f0", "output": "def cache_harvest_f0(input_audio_path, fs, f0max, f0min, frame_period):", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def change_rms", "output": "def change_rms(data1, sr1, data2, sr2, rate):  # 1\u662f\u8f93\u5165\u97f3\u9891\uff0c2\u662f\u8f93\u51fa\u97f3\u9891,rate\u662f2\u7684\u5360\u6bd4", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, orig_func, sub_func, cond_func):", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def ipex_init", "output": "def ipex_init():  # pylint: disable=too-many-statements", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def unscale_", "output": "def unscale_(self, optimizer):\n\"\"\"\nDivides (\"unscales\") the optimizer's gradient tensors by the scale factor.\n:meth:`unscale_` is optional, serving cases where you need to\n:ref:`modify or inspect gradients<working-with-unscaled-gradients>`\nbetween the backward pass(es) and :meth:`step`.\nIf :meth:`unscale_` is not called explicitly,  gradients will be unscaled  automatically during :meth:`step`.\nSimple example, using :meth:`unscale_` to enable clipping of unscaled gradients::\n...\nscaler.scale(loss).backward()", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def update", "output": "def update(self, new_scale=None):\n\"\"\"\nUpdates the scale factor.\nIf any optimizer steps were skipped the scale is multiplied by ``backoff_factor``\nto reduce it. If ``growth_interval`` unskipped iterations occurred consecutively,\nthe scale is multiplied by ``growth_factor`` to increase it.\nPassing ``new_scale`` sets the new scale value manually. (``new_scale`` is not\nused directly, it's used to fill GradScaler's internal scale tensor. So if\n``new_scale`` was a tensor, later in-place changes to that tensor will not further\naffect the scale GradScaler uses internally.)", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, samplerate=16000, hop_size=160):", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, samplerate=16000, hop_size=160):", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, samplerate=16000, hop_size=160):", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def kl_divergence", "output": "def kl_divergence(m_p, logs_p, m_q, logs_q):\n\"\"\"KL(P||Q)\"\"\"\nkl = (logs_q - logs_p) - 0.5\nkl += (\n0.5 * (torch.exp(2.0 * logs_p) + ((m_p - m_q) ** 2)) * torch.exp(-2.0 * logs_q)\n)\nreturn kl\n\n\ndef rand_gumbel(shape):", "source": "rvc-webui"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_and_install", "output": "def download_and_install(version_prefix = None, install_root = None, arch = 'x86_64'):", "source": "flare-bypasser-arm"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, page: zendriver.Tab, center_coords):", "source": "flare-bypasser-arm"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_attrs", "output": "def _make_attrs(self):  # override for exclude exception on __init__", "source": "flare-bypasser-arm"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_class_command_processors", "output": "def parse_class_command_processors(custom_command_processors_str: str):", "source": "flare-bypasser-arm"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_entrypoint_command_processors", "output": "def parse_entrypoint_command_processors(extension: str):", "source": "flare-bypasser-arm"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, proxy_storage: object, local_port: int, url: str):", "source": "flare-bypasser-arm"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_and_install", "output": "def download_and_install(version_prefix = None, install_root = None, arch = 'x86_64'):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, page: zendriver.Tab, center_coords):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_attrs", "output": "def _make_attrs(self):  # override for exclude exception on __init__", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_class_command_processors", "output": "def parse_class_command_processors(custom_command_processors_str: str):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_entrypoint_command_processors", "output": "def parse_entrypoint_command_processors(extension: str):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, proxy_storage: object, local_port: int, url: str):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, driver: ChromiumPage, max_retries=-1, log=True):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def search_recursively_shadow_root_with_iframe", "output": "def search_recursively_shadow_root_with_iframe(self, ele):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def search_recursively_shadow_root_with_cf_input", "output": "def search_recursively_shadow_root_with_cf_input(self, ele):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, model, config=None, device='cuda:0'):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, testpath='/ps/scratch/yfeng/Data/AFLW2000/GT', crop_size=224):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, K, image_size, scale, trans_scale = 0, dataname='vox2', n_train=100000, isTemporal=False, isEval=False, isSingle=False):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, K, image_size, scale, trans_scale = 0, isTemporal=False, isEval=False, isSingle=False):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, testpath, iscrop=True, crop_size=224, scale=1.25, face_detector='fan', sample_step=10):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, ring_elements=6, crop_size=224, scale=1.6):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, K, image_size, scale, trans_scale = 0, dataname='vox2', n_train=100000, isTemporal=False, isEval=False, isSingle=False):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, K, image_size, scale, trans_scale = 0, isTemporal=False, isEval=False, isSingle=False):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_cfg_defaults", "output": "def get_cfg_defaults():\n\"\"\"Get a yacs CfgNode object with default values for my_project.\"\"\"\n# Return a clone so that the defaults will not be altered\n# This is for the \"local variable\" use pattern\nreturn cfg.clone()\n\ndef update_cfg(cfg, cfg_file):\ncfg.merge_from_file(cfg_file)\nreturn cfg.clone()\n", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def upsample_mesh", "output": "def upsample_mesh(vertices, normals, faces, displacement_map, texture_map, dense_template):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_obj", "output": "def load_obj(obj_filename):\n\"\"\" Ref: https://github.com/facebookresearch/pytorch3d/blob/25c065e9dafa90163e7cec873dbb324a637c68b7/pytorch3d/io/obj_io.py\nLoad a mesh from a file-like object.\n\"\"\"", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, height, width=None):\n\"\"\"\nuse fixed raster_settings for rendering faces\n\"\"\"", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def forward", "output": "def forward(self, vertices, faces, attributes=None, h=None, w=None):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def rad2deg", "output": "def rad2deg(tensor):\n\"\"\"Function that converts angles from radians to degrees.\n\nSee :class:`~torchgeometry.RadToDeg` for details.\n\nArgs:\ntensor (Tensor): Tensor of arbitrary shape.\n\nReturns:\nTensor: Tensor with same shape as input.", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def deg2rad", "output": "def deg2rad(tensor):\n\"\"\"Function that converts angles from degrees to radians.\n\nSee :class:`~torchgeometry.DegToRad` for details.\n\nArgs:\ntensor (Tensor): Tensor of arbitrary shape.\n\nReturns:\nTensor: Tensor with same shape as input.", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def augment_bbox", "output": "def augment_bbox(center, bbox_size, scale=[1.0, 1.0], trans_scale=0.):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def crop_tensor", "output": "def crop_tensor(image, center, bbox_size, crop_size, interpolation = 'bilinear', align_corners=False):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def kl_loss", "output": "def kl_loss(texcode):\n\"\"\"\nrecon_x: generating images\nx: origin images\nmu: latent mean\nlogvar: latent log variance\n\"\"\"", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, model, config=None, device='cuda:0'):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def conv3x3", "output": "def conv3x3(in_planes, out_planes, stride=1):\n\"\"\"3x3 convolution with padding\"\"\"\nreturn nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride,\npadding=1, bias=False)\n\nclass BasicBlock(nn.Module):\nexpansion = 1\n\ndef __init__(self, inplanes, planes, stride=1, downsample=None):\nsuper(BasicBlock, self).__init__()", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, inplanes, planes, stride=1, downsample=None):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, latent_dim=100, out_channels=1, out_scale=0.01, sample_mode = 'bilinear'):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def find_dynamic_lmk_idx_and_bcoords", "output": "def find_dynamic_lmk_idx_and_bcoords(vertices, pose, dynamic_lmk_faces_idx,", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def vertices2landmarks", "output": "def vertices2landmarks(vertices, faces, lmk_faces_idx, lmk_bary_coords):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, block, layers, num_classes=1000):", "source": "DECA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_layer", "output": "def _make_layer(self, block, planes, blocks, stride=1):", "source": "DECA"}
{"instruction": "Write a Rust function.", "input": "Function: fn empty_state", "output": "fn empty_state() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn fresh_state", "output": "fn fresh_state() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn advance", "output": "fn advance() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn sanity_check_odd_allocator", "output": "fn sanity_check_odd_allocator() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_bytes_from_vec_drop", "output": "fn test_bytes_from_vec_drop() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_bytes_clone_drop", "output": "fn test_bytes_clone_drop() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_sync<T: Sync>", "output": "fn is_sync<T: Sync>() {}", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_send<T: Send>", "output": "fn is_send<T: Send>() {}", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_bounds", "output": "fn test_bounds() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn iter_len", "output": "fn iter_len() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn empty_iter_len", "output": "fn empty_iter_len() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn read", "output": "fn read() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn buf_read", "output": "fn buf_read() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn insert", "output": "fn insert(&self, ptr: *mut u8, size: usize) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn remove", "output": "fn remove(&self, ptr: *mut u8) -> usize {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_bytes_advance", "output": "fn test_bytes_advance() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn collect_two_bufs", "output": "fn collect_two_bufs() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn writing_chained", "output": "fn writing_chained() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn iterating_two_bufs", "output": "fn iterating_two_bufs() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_ser_de_empty", "output": "fn test_ser_de_empty() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_ser_de", "output": "fn test_ser_de() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_vec_as_mut_buf", "output": "fn test_vec_as_mut_buf() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_vec_put_bytes", "output": "fn test_vec_put_bytes() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_put_u8", "output": "fn test_put_u8() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn long_take", "output": "fn long_take() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn take_copy_to_bytes", "output": "fn take_copy_to_bytes() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn take_copy_to_bytes_panics", "output": "fn take_copy_to_bytes_panics() {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new(buf: &'static [u8], readlens: &'static [usize], init_pos: usize) -> TestBuf {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn reset", "output": "fn reset(&mut self) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn next_readlen", "output": "fn next_readlen(&mut self) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn alloc_small", "output": "fn alloc_small(b: &mut Bencher) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn alloc_mid", "output": "fn alloc_mid(b: &mut Bencher) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn alloc_big", "output": "fn alloc_big(b: &mut Bencher) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref_unique", "output": "fn deref_unique(b: &mut Bencher) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref_shared", "output": "fn deref_shared(b: &mut Bencher) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref_static", "output": "fn deref_static(b: &mut Bencher) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize<S>", "output": "fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn expecting", "output": "fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn visit_seq<V>", "output": "fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn reserve_inner", "output": "fn reserve_inner(&mut self, additional: usize, allocate: bool) -> bool {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_slice", "output": "fn as_slice(&self) -> &[u8] {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_slice_mut", "output": "fn as_slice_mut(&mut self) -> &mut [u8] {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn abort", "output": "fn abort() -> ! {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn saturating_sub_usize_u64", "output": "fn saturating_sub_usize_u64(a: usize, b: u64) -> usize {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn new_empty_with_ptr", "output": "fn new_empty_with_ptr(ptr: *const u8) -> Self {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_slice", "output": "fn as_slice(&self) -> &[u8] {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn with_mut<F, R>", "output": "fn with_mut<F, R>(&mut self, f: F) -> R", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn with_mut<F, R>", "output": "fn with_mut<F, R>(&mut self, f: F) -> R", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining_mut", "output": "fn remaining_mut(&self) -> usize {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunk_mut", "output": "fn chunk_mut(&mut self) -> &mut UninitSlice {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining", "output": "fn remaining(&self) -> usize {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunk", "output": "fn chunk(&self) -> &[u8] {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn advance", "output": "fn advance(&mut self, mut cnt: usize) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<u8> {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn size_hint", "output": "fn size_hint(&self) -> (usize, Option<usize>) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn sign_extend", "output": "fn sign_extend(val: u64, nbytes: usize) -> i64 {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining", "output": "fn remaining(&self) -> usize;", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunk", "output": "fn chunk(&self) -> &[u8];", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining", "output": "fn remaining(&self) -> usize {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunk", "output": "fn chunk(&self) -> &[u8] {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunks_vectored<'a>", "output": "fn chunks_vectored<'a>(&'a self, dst: &mut [io::IoSlice<'a>]) -> usize {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn uninit_ref", "output": "fn uninit_ref(slice: &[MaybeUninit<u8>]) -> &UninitSlice {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(slice: &'a mut [u8]) -> Self {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining_mut", "output": "fn remaining_mut(&self) -> usize;", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn has_remaining_mut", "output": "fn has_remaining_mut(&self) -> bool {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunk_mut", "output": "fn chunk_mut(&mut self) -> &mut UninitSlice;", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining", "output": "fn remaining(&self) -> usize {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunk", "output": "fn chunk(&self) -> &[u8] {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn advance", "output": "fn advance(&mut self, cnt: usize) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn write", "output": "fn write(&mut self, src: &[u8]) -> io::Result<usize> {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn flush", "output": "fn flush(&mut self) -> io::Result<()> {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn read", "output": "fn read(&mut self, dst: &mut [u8]) -> io::Result<usize> {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn fill_buf", "output": "fn fill_buf(&mut self) -> io::Result<&[u8]> {", "source": "bytes-1.10.1"}
{"instruction": "Write a Rust function.", "input": "Function: fn consume", "output": "fn consume(&mut self, amt: usize) {", "source": "bytes-1.10.1"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def aes_cbc_decrypt_bytes", "output": "def aes_cbc_decrypt_bytes(data, key, iv):\n\"\"\"Decrypt bytes with AES-CBC using pycryptodome\"\"\"\nreturn Cryptodome_AES.new(\nkey, Cryptodome_AES.MODE_CBC, iv).decrypt(data)\n\ndef aes_gcm_decrypt_and_verify_bytes(data, key, tag, nonce):\n\"\"\"Decrypt bytes with AES-GCM using pycryptodome\"\"\"", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def aes_gcm_decrypt_and_verify_bytes", "output": "def aes_gcm_decrypt_and_verify_bytes(data, key, tag, nonce):\n\"\"\"Decrypt bytes with AES-GCM using pycryptodome\"\"\"\nreturn Cryptodome_AES.new(\nkey, Cryptodome_AES.MODE_GCM, nonce).decrypt_and_verify(data, tag)\nelse:\ndef aes_cbc_decrypt_bytes(data, key, iv):\n\"\"\"Decrypt bytes with AES-CBC using native implementation\"\"\"", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def aes_cbc_decrypt_bytes", "output": "def aes_cbc_decrypt_bytes(data, key, iv):\n\"\"\"Decrypt bytes with AES-CBC using native implementation\"\"\"\nreturn intlist_to_bytes(aes_cbc_decrypt(\nbytes_to_intlist(data),\nbytes_to_intlist(key),\nbytes_to_intlist(iv),\n))\n\ndef aes_gcm_decrypt_and_verify_bytes(data, key, tag, nonce):\n\"\"\"Decrypt bytes with AES-GCM using native implementation\"\"\"", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, path, keygen, table=None, pragma=None, cache_key=None):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_cookies_firefox", "output": "def load_cookies_firefox(browser_name, profile=None,", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_cookies_webkit", "output": "def load_cookies_webkit(browser_name, profile=None, domain=None):\n\"\"\"Ref.: https://github.com/libyal/dtformats/blob\n/main/documentation/Safari%20Cookies.asciidoc\n- This data appears to be out of date\nbut the important parts of the database structure is the same\n- There are a few bytes here and there\nwhich are skipped during parsing\n\"\"\"", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse", "output": "def parse(format_string, default=NONE, fmt=format):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, format_string, default=NONE, fmt=format):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def format_map", "output": "def format_map(self, kwdict):\n\"\"\"Apply 'kwdict' to the initial format_string and return its result\"\"\"\nresult = self.result\nfor index, func in self.fields:\nresult[index] = func(kwdict)\nreturn \"\".join(result)\n\ndef _field_access(self, field_name, format_spec, conversion):\nfmt = self._parse_format_spec(format_spec, conversion)\n", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def run", "output": "def run(self):\n\"\"\"Execute or run the job\"\"\"\nextractor = self.extractor\nlog = extractor.log\nmsg = None\n\nself._init()\n\n# sleep before extractor start\nsleep = util.build_duration_func(", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def nonce", "output": "def nonce(size, alphabet=string.ascii_letters):\n\"\"\"Generate a nonce value with 'size' characters\"\"\"\nreturn \"\".join(random.choice(alphabet) for _ in range(size))\n\n\ndef quote(value, quote=urllib.parse.quote):\n\"\"\"Quote 'value' according to the OAuth1.0 standard\"\"\"", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def quote", "output": "def quote(value, quote=urllib.parse.quote):\n\"\"\"Quote 'value' according to the OAuth1.0 standard\"\"\"\nreturn quote(value, \"~\")\n\n\ndef concat(*args):\n\"\"\"Concatenate 'args' as expected by OAuth1.0\"\"\"", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def concat", "output": "def concat(*args):\n\"\"\"Concatenate 'args' as expected by OAuth1.0\"\"\"\nreturn \"&\".join(quote(item) for item in args)\n\n\nclass OAuth1Session(requests.Session):\n\"\"\"Extension to requests.Session to support OAuth 1.0\"\"\"", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __call__", "output": "def __call__(self, parser, namespace, values, option_string=None):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __call__", "output": "def __call__(self, parser, namespace, values, option_string=None):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __call__", "output": "def __call__(self, parser, namespace, values, option_string=None):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def makeRecord", "output": "def makeRecord(self, name, level, fn, lno, msg, args, exc_info,", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def open", "output": "def open(self, mode=\"wb\"):\n\"\"\"Open file and return a corresponding file object\"\"\"\ntry:\nreturn open(self.temppath, mode)\nexcept FileNotFoundError:\nif \"r\" in mode:\n# '.part' file no longer exists\nreturn util.NullContext()\nos.makedirs(self.realdirectory)\nreturn open(self.temppath, mode)", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def re", "output": "def re(pattern):\n\"\"\"Compile a regular expression pattern\"\"\"\ntry:\nreturn PATTERN_CACHE[pattern]\nexcept KeyError:\np = PATTERN_CACHE[pattern] = re_compile(pattern)\nreturn p\n\n\ndef remove_html(txt, repl=\" \", sep=\" \"):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def remove_html", "output": "def remove_html(txt, repl=\" \", sep=\" \"):\n\"\"\"Remove html-tags from a string\"\"\"\ntry:\ntxt = HTML_RE.sub(repl, txt)\nexcept TypeError:\nreturn \"\"\nif sep:\nreturn sep.join(txt.split())\nreturn txt.strip()\n", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def split_html", "output": "def split_html(txt):\n\"\"\"Split input string by HTML tags\"\"\"\ntry:\nreturn [\nunescape(x).strip()\nfor x in HTML_RE.split(txt)\nif x and not x.isspace()\n]\nexcept TypeError:\nreturn []", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def bencode", "output": "def bencode(num, alphabet=\"0123456789\"):\n\"\"\"Encode an integer into a base-N encoded string\"\"\"\ndata = \"\"\nbase = len(alphabet)\nwhile num:\nnum, remainder = divmod(num, base)\ndata = alphabet[remainder] + data\nreturn data\n\n", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def bdecode", "output": "def bdecode(data, alphabet=\"0123456789\"):\n\"\"\"Decode a base-N encoded string ( N = len(alphabet) )\"\"\"\nnum = 0\nbase = len(alphabet)\nfor c in data:\nnum = num * base + alphabet.find(c)\nreturn num\n\n\ndef decrypt_xor(encrypted, key, base64=True, fromhex=False):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def decrypt_xor", "output": "def decrypt_xor(encrypted, key, base64=True, fromhex=False):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def construct_YoutubeDL", "output": "def construct_YoutubeDL(module, obj, user_opts, system_opts=None):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def pyprint", "output": "def pyprint(obj, indent=0, sort=None, oneline=True, lmin=0, lmax=16):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def domain", "output": "def domain(cls):\n\"\"\"Return the domain name associated with an extractor class\"\"\"\ntry:\nurl = sys.modules[cls.__module__].__doc__.split()[-1]\nif url.startswith(\"http\"):\nreturn url\nexcept Exception:\npass\n\nif hasattr(cls, \"root\") and cls.root:", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def category_text", "output": "def category_text(c):\n\"\"\"Return a human-readable representation of a category\"\"\"\nreturn CATEGORY_MAP.get(c) or c.capitalize()\n\n\ndef subcategory_text(bc, c, sc):\n\"\"\"Return a human-readable representation of a subcategory\"\"\"", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def subcategory_text", "output": "def subcategory_text(bc, c, sc):\n\"\"\"Return a human-readable representation of a subcategory\"\"\"\nif c in SUBCATEGORY_MAP:\nscm = SUBCATEGORY_MAP[c]\nif sc in scm:\ntxt = scm[sc]\nif not isinstance(txt, str):\ntxt = \", \".join(txt)\nreturn txt\n", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_shorten_noop", "output": "def test_shorten_noop(self, f=output.shorten_string):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_shorten_separator", "output": "def test_shorten_separator(self, f=output.shorten_string):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, extr=extractor.find(\"generic:https://example.org/\")):", "source": "gallery-dl"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_synthesizer", "output": "def get_synthesizer(cpt: OrderedDict, device=torch.device(\"cpu\")):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def float_to_int16", "output": "def float_to_int16(audio: np.ndarray) -> np.ndarray:", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def float_np_array_to_wav_buf", "output": "def float_np_array_to_wav_buf(wav: np.ndarray, sr: int, f32=False) -> BytesIO:", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def save_audio", "output": "def save_audio(path: str, audio: np.ndarray, sr: int, f32=False, format=\"wav\"):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, agg, model_path, device, is_half, tta=False):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _path_audio_", "output": "def _path_audio_(self, music_file, ins_root=None, vocal_root=None, format=\"flac\"):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def uvr", "output": "def uvr(model_name, inp_root, save_root_vocal, paths, save_root_ins, agg, format0):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def change_rms", "output": "def change_rms(data1, sr1, data2, sr2, rate):  # 1\u662f\u8f93\u5165\u97f3\u9891\uff0c2\u662f\u8f93\u51fa\u97f3\u9891,rate\u662f2\u7684\u5360\u6bd4", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _generate_mask_smoothing_filter", "output": "def _generate_mask_smoothing_filter(self) -> Union[torch.Tensor, None]:\n\"\"\"\nA PyTorch module that applies a spectral gate to an input signal using the STFT.\n\nReturns:\nsmoothing_filter (torch.Tensor): a 2D tensor representing the smoothing filter,\nwith shape (n_grad_freq, n_grad_time), where n_grad_freq is the number of frequency\nbins to smooth and n_grad_time is the number of time frames to smooth.\nIf both self.freq_mask_smooth_hz and self.time_mask_smooth_ms are None, returns None.\n\"\"\"", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def temperature_sigmoid", "output": "def temperature_sigmoid(x: torch.Tensor, x0: float, temp_coeff: float) -> torch.Tensor:\n\"\"\"\nApply a sigmoid function with temperature scaling.\n\nArguments:\nx {[torch.Tensor]} -- [Input tensor.]\nx0 {[float]} -- [Parameter that controls the threshold of the sigmoid.]\ntemp_coeff {[float]} -- [Parameter that controls the slope of the sigmoid.]\n\nReturns:", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, is_half: bool, device=\"cpu\", samplerate=16000, hop_size=160):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def inference", "output": "def inference(X_spec, device, model, aggressiveness, data):\n\"\"\"\ndata \uff1a dic configs\n\"\"\"", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def dynamic_range_compression_torch", "output": "def dynamic_range_compression_torch(x, C=1, clip_val=1e-5):\n\"\"\"\nPARAMS\n------\nC: compression factor\n\"\"\"", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def dynamic_range_decompression_torch", "output": "def dynamic_range_decompression_torch(x, C=1):\n\"\"\"\nPARAMS\n------\nC: compression factor used to compress\n\"\"\"", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def save_small_model", "output": "def save_small_model(ckpt, sr, if_f0, name, epoch, version, hps):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def extract_small_model", "output": "def extract_small_model(path, name, author, sr, if_f0, info, version):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _filter", "output": "def _filter(self):\n\"\"\"\nFilter text & store spec lengths\n\"\"\"", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_checkpoint", "output": "def load_checkpoint(checkpoint_path, model, optimizer=None, load_opt=1):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def save_checkpoint", "output": "def save_checkpoint(model, optimizer, learning_rate, iteration, checkpoint_path):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def discriminator_loss", "output": "def discriminator_loss(disc_real_outputs, disc_generated_outputs):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def split_lr_waves", "output": "def split_lr_waves(wave, mid_side=False, mid_side_b2=False, reverse=False):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def run_librosa_stft", "output": "def run_librosa_stft(wv, n_fft, hop_length, reverse):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, ch, dilations=(4, 8, 16, 32)):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, activ=nn.LeakyReLU):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_and_install", "output": "def download_and_install(version_prefix = None, install_root = None, arch = 'x86_64'):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, driver: ChromiumPage, max_retries=-1, log=True):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def search_recursively_shadow_root_with_iframe", "output": "def search_recursively_shadow_root_with_iframe(self, ele):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def search_recursively_shadow_root_with_cf_input", "output": "def search_recursively_shadow_root_with_cf_input(self, ele):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, page: zendriver.Tab, center_coords):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_attrs", "output": "def _make_attrs(self):  # override for exclude exception on __init__", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_class_command_processors", "output": "def parse_class_command_processors(custom_command_processors_str: str):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_entrypoint_command_processors", "output": "def parse_entrypoint_command_processors(extension: str):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, proxy_storage: object, local_port: int, url: str):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_and_install", "output": "def download_and_install(version_prefix = None, install_root = None, arch = 'x86_64'):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, driver: ChromiumPage, max_retries=-1, log=True):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def search_recursively_shadow_root_with_iframe", "output": "def search_recursively_shadow_root_with_iframe(self, ele):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def search_recursively_shadow_root_with_cf_input", "output": "def search_recursively_shadow_root_with_cf_input(self, ele):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, page: zendriver.Tab, center_coords):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_attrs", "output": "def _make_attrs(self):  # override for exclude exception on __init__", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_class_command_processors", "output": "def parse_class_command_processors(custom_command_processors_str: str):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_entrypoint_command_processors", "output": "def parse_entrypoint_command_processors(extension: str):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, proxy_storage: object, local_port: int, url: str):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_and_install", "output": "def download_and_install(version_prefix = None, install_root = None, arch = 'x86_64'):", "source": "flare-bypasser-arm"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, page: zendriver.Tab, center_coords):", "source": "flare-bypasser-arm"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_attrs", "output": "def _make_attrs(self):  # override for exclude exception on __init__", "source": "flare-bypasser-arm"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_class_command_processors", "output": "def parse_class_command_processors(custom_command_processors_str: str):", "source": "flare-bypasser-arm"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_entrypoint_command_processors", "output": "def parse_entrypoint_command_processors(extension: str):", "source": "flare-bypasser-arm"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, proxy_storage: object, local_port: int, url: str):", "source": "flare-bypasser-arm"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_and_install", "output": "def download_and_install(version_prefix = None, install_root = None, arch = 'x86_64'):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, driver: ChromiumPage, max_retries=-1, log=True):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def search_recursively_shadow_root_with_iframe", "output": "def search_recursively_shadow_root_with_iframe(self, ele):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def search_recursively_shadow_root_with_cf_input", "output": "def search_recursively_shadow_root_with_cf_input(self, ele):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, page: zendriver.Tab, center_coords):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_attrs", "output": "def _make_attrs(self):  # override for exclude exception on __init__", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_class_command_processors", "output": "def parse_class_command_processors(custom_command_processors_str: str):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_entrypoint_command_processors", "output": "def parse_entrypoint_command_processors(extension: str):", "source": "flare-bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, proxy_storage: object, local_port: int, url: str):", "source": "flare-bypasser"}
{"instruction": "Write a Rust function.", "input": "Function: fn bench_is_nfc_ascii", "output": "fn bench_is_nfc_ascii(b: &mut Bencher) {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn bench_is_nfc_normalized", "output": "fn bench_is_nfc_normalized(b: &mut Bencher) {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn bench_is_nfc_not_normalized", "output": "fn bench_is_nfc_not_normalized(b: &mut Bencher) {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn u8_lookup_fk", "output": "fn u8_lookup_fk(kv: u32) -> u32 {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn u8_lookup_fv", "output": "fn u8_lookup_fv(kv: u32) -> u8 {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn bool_lookup_fk", "output": "fn bool_lookup_fk(kv: u32) -> u32 {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_nfd", "output": "fn test_nfd() {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_nfkd", "output": "fn test_nfkd() {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_nfc", "output": "fn test_nfc() {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn decompose<D, F>", "output": "fn decompose<D, F>(c: char, decompose_char: D, mut emit_char: F)", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn compose_hangul", "output": "fn compose_hangul(a: char, b: char) -> Option<char> {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_hangul_composition", "output": "fn test_hangul_composition() {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn nfd", "output": "fn nfd(self) -> Decompositions<I>;", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn nfkd", "output": "fn nfkd(self) -> Decompositions<I>;", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn nfc", "output": "fn nfc(self) -> Recompositions<I>;", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn push_back", "output": "fn push_back(&mut self, ch: char) {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn sort_pending", "output": "fn sort_pending(&mut self) {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn reset_buffer", "output": "fn reset_buffer(&mut self) {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn quick_check<F, I>", "output": "fn quick_check<F, I>(s: I, is_allowed: F, stream_safe: bool) -> IsNormalized", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_stream_safe_nfd", "output": "fn test_stream_safe_nfd() {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_stream_safe_nfc", "output": "fn test_stream_safe_nfc() {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<char> {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<char> {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn size_hint", "output": "fn size_hint(&self) -> (usize, Option<usize>) {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn my_hash", "output": "fn my_hash(key: u32, salt: u32, n: usize) -> usize {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<char> {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn stream_safe", "output": "fn stream_safe(s: &str) -> String {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_simple", "output": "fn test_simple() {", "source": "unicode-normalization-0.1.25"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_a_vec", "output": "fn test_a_vec() {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn ArrayVec_push_pop", "output": "fn ArrayVec_push_pop() {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn ArrayVec_push_overflow", "output": "fn ArrayVec_push_overflow() {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn TinyVec_swap_remove", "output": "fn TinyVec_swap_remove() {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn TinyVec_capacity", "output": "fn TinyVec_capacity() {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn TinyVec_drain", "output": "fn TinyVec_drain() {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn __break", "output": "fn __break() {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_debugger_visualizer", "output": "fn test_debugger_visualizer() {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn tinyvec_benches", "output": "fn tinyvec_benches(c: &mut Criterion) {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn smallvec_benches", "output": "fn smallvec_benches(c: &mut Criterion) {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn bench_tinyvec_macro", "output": "fn bench_tinyvec_macro(c: &mut Criterion) {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone", "output": "fn clone(&self) -> Self {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone_from", "output": "fn clone_from(&mut self, o: &Self) {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next_back", "output": "fn next_back(&mut self) -> Option<Self::Item> {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn nth_back", "output": "fn nth_back(&mut self, n: usize) -> Option<Self::Item> {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<Self::Item> {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone", "output": "fn clone(&self) -> Self {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone_from", "output": "fn clone_from(&mut self, o: &Self) {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref", "output": "fn deref(&self) -> &Self::Target {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref_mut", "output": "fn deref_mut(&mut self) -> &mut Self::Target {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_slice", "output": "fn as_slice(&self) -> &[Self::Item];", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_slice_mut", "output": "fn as_slice_mut(&mut self) -> &mut [Self::Item];", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self;", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_slice", "output": "fn as_slice(&self) -> &[T] {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_slice_mut", "output": "fn as_slice_mut(&mut self) -> &mut [T] {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_slice", "output": "fn as_slice(&self) -> &[T] {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_slice_mut", "output": "fn as_slice_mut(&mut self) -> &mut [T] {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "tinyvec-1.10.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn one_test", "output": "fn one_test(decoded: &str, encoded: &str) {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_string<'a>", "output": "fn get_string<'a>(map: &'a Map<String, Value>, key: &str) -> &'a str {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn check<F>", "output": "fn check<F>(source: &str, expected: (&str, &[&str]), actual: Result<String, Errors>, ignore: F)", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn unescape", "output": "fn unescape(input: &str) -> String {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn status", "output": "fn status(status: &str) -> Vec<&str> {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_punycode_prefix_with_length_check", "output": "fn test_punycode_prefix_with_length_check() {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_punycode_prefix_without_length_check", "output": "fn test_punycode_prefix_without_length_check() {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_examples", "output": "fn test_examples() {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_unicode_puny_label", "output": "fn to_unicode_puny_label(bench: &mut Bencher) {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_unicode_ascii", "output": "fn to_unicode_ascii(bench: &mut Bencher) {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_unicode_merged_label", "output": "fn to_unicode_merged_label(bench: &mut Bencher) {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn adapt", "output": "fn adapt(mut delta: u32, num_points: u32, first_time: bool) -> u32 {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<Self::Item> {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn size_hint", "output": "fn size_hint(&self) -> (usize, Option<usize>) {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn decode_slice", "output": "fn decode_slice(slice: &StringTableSlice) -> &'static str {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn find_char", "output": "fn find_char(codepoint: char) -> &'static Mapping {", "source": "idna-0.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<Self::Item> {", "source": "idna-0.3.0"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def keychain_service_name", "output": "def keychain_service_name(service: str) -> str:\n\"\"\"Generate keychain service name for a given service.\"\"\"\nreturn f\"{KEYCHAIN_PREFIX}.{service.lower()}.apikey\"\n\ndef env_var_name(service: str) -> str:\n\"\"\"Generate environment variable name for a service.\"\"\"", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def env_var_name", "output": "def env_var_name(service: str) -> str:\n\"\"\"Generate environment variable name for a service.\"\"\"\nreturn f\"{service.upper()}_API_KEY\"\n\ndef docker_service_url(service: str) -> str:\n\"\"\"Generate Docker service URL.\"\"\"", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def docker_service_url", "output": "def docker_service_url(service: str) -> str:\n\"\"\"Generate Docker service URL.\"\"\"\nconfig = SUPPORTED_SERVICES.get(service.lower())\nif config:\nreturn f\"http://localhost:{config['port']}\"\nreturn \"\"\n\n# Service Status Categories\nSERVICE_STATUS = {\n'configured': ['sonarr', 'radarr', 'lidarr', 'prowlarr', 'bazarr'],", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_api_key_from_keychain", "output": "def get_api_key_from_keychain(service: str) -> Optional[str]:\n\"\"\"Get API key from Keychain using arrkeyctl.\"\"\"\ntry:\nresult = subprocess.run(\n['/Users/davidquinton/bin/arrkeyctl', 'get', service],\ncapture_output=True,\ntext=True,\ncheck=True\n)\nreturn result.stdout.strip()", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def update_bazarr_config", "output": "def update_bazarr_config(config_path: str = \"/Users/davidquinton/docker-media/bazarr/config/config.yaml\"):\n\"\"\"Update Bazarr configuration with API keys and service settings.\"\"\"\nconfig_file = Path(config_path)\n\nif not config_file.exists():\nprint(f\"\u274c Bazarr config file not found: {config_path}\")\nreturn False\n\n# Load current configuration\ntry:", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def main", "output": "def main():\n\"\"\"Main function.\"\"\"\nimport argparse\n\nparser = argparse.ArgumentParser(description='Update Bazarr configuration with API keys from Keychain')\nparser.add_argument('--config', default='/Users/davidquinton/docker-media/bazarr/config/config.yaml',\nhelp='Path to Bazarr config.yaml file')\nparser.add_argument('--dry-run', action='store_true',\nhelp='Show what would be updated without making changes')\n", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def extract_xml_api_key", "output": "def extract_xml_api_key(config_path: Path, xpath: str) -> Optional[str]:\n\"\"\"Extract API key from XML config file.\"\"\"\ntry:\ntree = ET.parse(config_path)\nroot = tree.getroot()\napi_key_element = root.find(xpath.replace('.//',''))\nreturn api_key_element.text if api_key_element is not None else None\nexcept Exception as e:\nprint(f\"Error parsing {config_path}: {e}\")\nreturn None", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def extract_yaml_api_key", "output": "def extract_yaml_api_key(config_path: Path, key_path: list) -> Optional[str]:\n\"\"\"Extract API key from YAML config file.\"\"\"\ntry:\nwith open(config_path, 'r') as f:\ndata = yaml.safe_load(f)\n\n# Navigate through nested keys\ncurrent = data\nfor key in key_path:\nif isinstance(current, dict) and key in current:", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def inventory_api_keys", "output": "def inventory_api_keys(base_path: str = \"/Users/davidquinton/docker-media\") -> Dict[str, Any]:\n\"\"\"Inventory all API keys from arr stack services.\"\"\"\nbase_path = Path(base_path)\ninventory = {\n'base_path': str(base_path),\n'services': {},\n'summary': {\n'total_services': 0,\n'keys_found': 0,\n'keys_missing': 0", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def run_command", "output": "def run_command(cmd, capture_output=True):\n\"\"\"Run a command and return the result.\"\"\"\ntry:\nreturn subprocess.run(cmd, capture_output=capture_output, text=True, check=True, shell=True)\nexcept subprocess.CalledProcessError as e:\nif capture_output:\nreturn e\nelse:\nraise\n", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def check_file_exists", "output": "def check_file_exists(path):\n\"\"\"Check if a file exists and is executable.\"\"\"\np = Path(path)\nreturn p.exists(), p.is_file() and p.stat().st_mode & 0o111\n\ndef main():\nprint(\"\ud83c\udf89 *arr Stack API Management System\")\nprint(\"=\" * 60)\nprint()\n", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_and_install", "output": "def download_and_install(version_prefix = None, install_root = None, arch = 'x86_64'):", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, page: zendriver.Tab, center_coords):", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_attrs", "output": "def _make_attrs(self):  # override for exclude exception on __init__", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_class_command_processors", "output": "def parse_class_command_processors(custom_command_processors_str: str):", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_entrypoint_command_processors", "output": "def parse_entrypoint_command_processors(extension: str):", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, proxy_storage: object, local_port: int, url: str):", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, driver: ChromiumPage, max_retries=-1, log=True):", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def search_recursively_shadow_root_with_iframe", "output": "def search_recursively_shadow_root_with_iframe(self, ele):", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def search_recursively_shadow_root_with_cf_input", "output": "def search_recursively_shadow_root_with_cf_input(self, ele):", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_and_install", "output": "def download_and_install(version_prefix = None, install_root = None, arch = 'x86_64'):", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, page: zendriver.Tab, center_coords):", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_attrs", "output": "def _make_attrs(self):  # override for exclude exception on __init__", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_class_command_processors", "output": "def parse_class_command_processors(custom_command_processors_str: str):", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_entrypoint_command_processors", "output": "def parse_entrypoint_command_processors(extension: str):", "source": "docker-media"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, proxy_storage: object, local_port: int, url: str):", "source": "docker-media"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_mut", "output": "fn get_mut(&mut self, domain: &str, path: &str, name: &str) -> Option<&mut Cookie<'static>> {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_mut_any", "output": "fn get_mut_any(", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn map_remove<K, V, Q>", "output": "fn map_remove<K, V, Q>(map: &mut Map<K, V>, key: &Q) -> Option<V>", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(e: idna::Errors) -> Self {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, other: &Self) -> bool {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(max_age: u64) -> CookieExpiration {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(utc_tm: OffsetDateTime) -> CookieExpiration {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_ref", "output": "fn as_ref(&self) -> &str {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref", "output": "fn deref(&self) -> &Self::Target {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(cp: &CookiePath) -> String {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_from", "output": "fn try_from(value: &str) -> Result<CookieDomain, Self::Error> {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_from", "output": "fn try_from(cookie: &'a RawCookie<'c>) -> Result<CookieDomain, Self::Error> {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(c: &'a CookieDomain) -> String {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(_: ParseError) -> Error {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref", "output": "fn deref(&self) -> &Self::Target {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_url", "output": "fn into_url(self) -> Result<Url, UrlError>;", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_url", "output": "fn into_url(self) -> Result<Url, UrlError> {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_url", "output": "fn into_url(self) -> Result<Url, UrlError> {", "source": "cookie_store-0.20.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn start", "output": "fn start(&self) -> usize {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn end", "output": "fn end(&self) -> usize {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Algorithm {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn adjust", "output": "fn adjust(&mut self, adjust_offset: (usize, bool), adjust_len: (usize, bool)) {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<Self::Item> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<Self::Item> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new(source: &'x T, slices: &[&'x T]) -> SliceRemapper<'x, T> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn slice", "output": "fn slice(&self, range: Range<usize>) -> Option<&'x T> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn index", "output": "fn index(&self, range: Range<usize>) -> &Self::Output {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_non_string_iter_change", "output": "fn test_non_string_iter_change() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn equal", "output": "fn equal(&mut self, old_index: usize, new_index: usize, len: usize) -> Result<(), Self::Error> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn delete", "output": "fn delete(", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn insert", "output": "fn insert(", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_ref", "output": "fn as_ref(&self) -> &D {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_mut", "output": "fn as_mut(&mut self) -> &mut D {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn equal", "output": "fn equal(&mut self, old_index: usize, new_index: usize, len: usize) -> Result<(), Self::Error> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn make_table<Old, New>", "output": "fn make_table<Old, New>(", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_table", "output": "fn test_table() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_diff", "output": "fn test_diff() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new(max_d: usize) -> Self {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn len", "output": "fn len(&self) -> usize {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn index", "output": "fn index(&self, index: isize) -> &Self::Output {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn flush_eq", "output": "fn flush_eq(&mut self) -> Result<(), D::Error> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn flush_del_ins", "output": "fn flush_del_ins(&mut self) -> Result<(), D::Error> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_ref", "output": "fn as_ref(&self) -> &D {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn equal", "output": "fn equal(&mut self, old: usize, new: usize, len: usize) -> Result<(), D::Error> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn finish", "output": "fn finish(&mut self) -> Result<(), D::Error> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_patience", "output": "fn test_patience() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, other: &UniqueItem<'a, A>) -> bool {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn index", "output": "fn index(&self, index: usize) -> &Self::Output {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn equal", "output": "fn equal(&mut self, old_index: usize, new_index: usize, len: usize) -> Result<(), Self::Error> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn delete", "output": "fn delete(", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn insert", "output": "fn insert(", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_diffable_str", "output": "fn as_diffable_str(&self) -> &Self::Output;", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_diffable_str", "output": "fn as_diffable_str(&self) -> &T {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_diffable_str", "output": "fn as_diffable_str(&self) -> &str {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_instant", "output": "fn into_instant(self) -> Option<Instant> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn diff<'old, 'new, 'bufs, T: DiffableStr + ?Sized>", "output": "fn diff<'old, 'new, 'bufs, T: DiffableStr + ?Sized>(", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_captured_ops", "output": "fn test_captured_ops() {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new(strings: &'bufs [&'s T]) -> MultiLookup<'bufs, 's, T> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_original_slices", "output": "fn get_original_slices(&self, idx: usize, len: usize) -> Vec<(usize, &'s T)> {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn index", "output": "fn index(&self, index: usize) -> &Self::Output {", "source": "similar-2.7.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn identify_bracket_pairs<'a, T: TextSource<'a> + ?Sized, D: BidiDataSource>", "output": "fn identify_bracket_pairs<'a, T: TextSource<'a> + ?Sized, D: BidiDataSource>(", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_NI", "output": "fn is_NI(class: BidiClass) -> bool {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn len", "output": "fn len(&self) -> usize;", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn char_at", "output": "fn char_at(&self, index: usize) -> Option<(char, usize)>;", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn subrange", "output": "fn subrange(&self, range: Range<usize>) -> &Self;", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn bidi_class", "output": "fn bidi_class(&self, c: char) -> BidiClass;", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn bidi_matched_opening_bracket", "output": "fn bidi_matched_opening_bracket(&self, c: char) -> Option<BidiMatchedOpeningBracket> {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn level_runs", "output": "fn level_runs(levels: &[Level], original_classes: &[BidiClass]) -> Vec<LevelRun> {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_level_runs", "output": "fn test_level_runs() {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_isolating_run_sequences", "output": "fn test_isolating_run_sequences() {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn reorder_line", "output": "fn reorder_line(", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_high_surrogate", "output": "fn is_high_surrogate(code: u16) -> bool {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_low_surrogate", "output": "fn is_low_surrogate(code: u16) -> bool {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(val: Level) -> Self {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(number: u8) -> Level {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, s: &&'a str) -> bool {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn bidi_class", "output": "fn bidi_class(&self, c: char) -> BidiClass {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn bsearch_range_value_table", "output": "fn bsearch_range_value_table(c: char, r: &'static [(char, char, BidiClass)]) -> BidiClass {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_ascii", "output": "fn test_ascii() {", "source": "unicode-bidi-0.3.18"}
{"instruction": "Write a Rust function.", "input": "Function: fn empty_state", "output": "fn empty_state() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fresh_state", "output": "fn fresh_state() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn advance", "output": "fn advance() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn sanity_check_odd_allocator", "output": "fn sanity_check_odd_allocator() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_bytes_from_vec_drop", "output": "fn test_bytes_from_vec_drop() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_bytes_clone_drop", "output": "fn test_bytes_clone_drop() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_sync<T: Sync>", "output": "fn is_sync<T: Sync>() {}", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_send<T: Send>", "output": "fn is_send<T: Send>() {}", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_bounds", "output": "fn test_bounds() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn iter_len", "output": "fn iter_len() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn empty_iter_len", "output": "fn empty_iter_len() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn read", "output": "fn read() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn buf_read", "output": "fn buf_read() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_mut", "output": "fn get_mut() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn insert", "output": "fn insert(&self, ptr: *mut u8, size: usize) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn remove", "output": "fn remove(&self, ptr: *mut u8) -> usize {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_bytes_advance", "output": "fn test_bytes_advance() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn long_limit", "output": "fn long_limit() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn limit_get_mut", "output": "fn limit_get_mut() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn limit_set_limit", "output": "fn limit_set_limit() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn collect_two_bufs", "output": "fn collect_two_bufs() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn writing_chained", "output": "fn writing_chained() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn iterating_two_bufs", "output": "fn iterating_two_bufs() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_ser_de_empty", "output": "fn test_ser_de_empty() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_ser_de", "output": "fn test_ser_de() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_vec_as_mut_buf", "output": "fn test_vec_as_mut_buf() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_vec_put_bytes", "output": "fn test_vec_put_bytes() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_put_u8", "output": "fn test_put_u8() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn long_take", "output": "fn long_take() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn take_copy_to_bytes", "output": "fn take_copy_to_bytes() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn take_copy_to_bytes_panics", "output": "fn take_copy_to_bytes_panics() {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new(buf: &'static [u8], readlens: &'static [usize], init_pos: usize) -> TestBuf {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn reset", "output": "fn reset(&mut self) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next_readlen", "output": "fn next_readlen(&mut self) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn alloc_small", "output": "fn alloc_small(b: &mut Bencher) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn alloc_mid", "output": "fn alloc_mid(b: &mut Bencher) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn alloc_big", "output": "fn alloc_big(b: &mut Bencher) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref_unique", "output": "fn deref_unique(b: &mut Bencher) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref_shared", "output": "fn deref_shared(b: &mut Bencher) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref_static", "output": "fn deref_static(b: &mut Bencher) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize<S>", "output": "fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn expecting", "output": "fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn visit_seq<V>", "output": "fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn reserve_inner", "output": "fn reserve_inner(&mut self, additional: usize, allocate: bool) -> bool {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_slice", "output": "fn as_slice(&self) -> &[u8] {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_slice_mut", "output": "fn as_slice_mut(&mut self) -> &mut [u8] {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn abort", "output": "fn abort() -> ! {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn saturating_sub_usize_u64", "output": "fn saturating_sub_usize_u64(a: usize, b: u64) -> usize {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn new_empty_with_ptr", "output": "fn new_empty_with_ptr(ptr: *const u8) -> Self {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_slice", "output": "fn as_slice(&self) -> &[u8] {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn with_mut<F, R>", "output": "fn with_mut<F, R>(&mut self, f: F) -> R", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn with_mut<F, R>", "output": "fn with_mut<F, R>(&mut self, f: F) -> R", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining_mut", "output": "fn remaining_mut(&self) -> usize {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunk_mut", "output": "fn chunk_mut(&mut self) -> &mut UninitSlice {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining", "output": "fn remaining(&self) -> usize {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunk", "output": "fn chunk(&self) -> &[u8] {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn advance", "output": "fn advance(&mut self, mut cnt: usize) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<u8> {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn size_hint", "output": "fn size_hint(&self) -> (usize, Option<usize>) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn sign_extend", "output": "fn sign_extend(val: u64, nbytes: usize) -> i64 {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining", "output": "fn remaining(&self) -> usize;", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunk", "output": "fn chunk(&self) -> &[u8];", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining", "output": "fn remaining(&self) -> usize {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunk", "output": "fn chunk(&self) -> &[u8] {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunks_vectored<'a>", "output": "fn chunks_vectored<'a>(&'a self, dst: &mut [io::IoSlice<'a>]) -> usize {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn uninit_ref", "output": "fn uninit_ref(slice: &[MaybeUninit<u8>]) -> &UninitSlice {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(slice: &'a mut [u8]) -> Self {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining_mut", "output": "fn remaining_mut(&self) -> usize;", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn has_remaining_mut", "output": "fn has_remaining_mut(&self) -> bool {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunk_mut", "output": "fn chunk_mut(&mut self) -> &mut UninitSlice;", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining", "output": "fn remaining(&self) -> usize {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn chunk", "output": "fn chunk(&self) -> &[u8] {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn advance", "output": "fn advance(&mut self, cnt: usize) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn write", "output": "fn write(&mut self, src: &[u8]) -> io::Result<usize> {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn flush", "output": "fn flush(&mut self) -> io::Result<()> {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn read", "output": "fn read(&mut self, dst: &mut [u8]) -> io::Result<usize> {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fill_buf", "output": "fn fill_buf(&mut self) -> io::Result<&[u8]> {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn consume", "output": "fn consume(&mut self, amt: usize) {", "source": "bytes-1.11.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(option: T) -> Self {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn indexed", "output": "fn indexed(needle: &str, haystack: &str) -> Option<CookieStr<'static>> {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_str<'s>", "output": "fn to_str<'s>(&'s self, string: Option<&'s Cow<str>>) -> &'s str {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_raw_str<'s, 'b: 's>", "output": "fn to_raw_str<'s, 'b: 's>(&'s self, string: &'s Cow<'b, str>) -> Option<&'b str> {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<&'a Cookie<'static>> {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<&'a Cookie<'static>> {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn simple", "output": "fn simple() {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(error: Utf8Error) -> ParseError {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn description", "output": "fn description(&self) -> &str {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref", "output": "fn deref(&self) -> &Cookie<'static> {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref_mut", "output": "fn deref_mut(&mut self) -> &mut Cookie<'static> {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, other: &DeltaCookie) -> bool {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, other: &Self) -> bool {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_from", "output": "fn try_from(key: &[u8]) -> Result<Self, Self::Error> {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn encrypt_cookie", "output": "fn encrypt_cookie(&self, cookie: &mut Cookie) {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn unseal", "output": "fn unseal(&self, name: &str, value: &str) -> Result<String, &'static str> {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn simple", "output": "fn simple() {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn sign_cookie", "output": "fn sign_cookie(&self, cookie: &mut Cookie) {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn _verify", "output": "fn _verify(&self, cookie_value: &str) -> Result<String, &'static str> {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn simple", "output": "fn simple() {", "source": "cookie-0.17.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn list_behaviour", "output": "fn list_behaviour() {", "source": "publicsuffix-2.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn msg", "output": "fn msg(s: String) -> &'static str {", "source": "publicsuffix-2.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn val", "output": "fn val(s: &Option<String>) -> String {", "source": "publicsuffix-2.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn bench_find", "output": "fn bench_find(b: &mut Bencher) {", "source": "publicsuffix-2.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn bench_suffix", "output": "fn bench_suffix(b: &mut Bencher) {", "source": "publicsuffix-2.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn bench_domain", "output": "fn bench_domain(b: &mut Bencher) {", "source": "publicsuffix-2.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "publicsuffix-2.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn append", "output": "fn append(&mut self, mut rule: &str, typ: Type) -> Result<(), Error> {", "source": "publicsuffix-2.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn find<'a, T>", "output": "fn find<'a, T>(&self, mut labels: T) -> Info", "source": "publicsuffix-2.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from_str", "output": "fn from_str(s: &str) -> Result<Self, Self::Err> {", "source": "publicsuffix-2.3.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn prompt<'a>", "output": "fn prompt<'a>(", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn strdup_string", "output": "fn strdup_string(s: &str) -> *mut c_char {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn inner", "output": "fn inner(&self) -> MutexGuard<SessionInner> {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn check", "output": "fn check(b: Cow<[u8]>) -> Result<Cow<[u8]>, Error> {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn lock", "output": "fn lock(&self) -> LockedChannel {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn write", "output": "fn write(&mut self, buf: &[u8]) -> io::Result<usize> {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn flush", "output": "fn flush(&mut self) -> io::Result<()> {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(err: Error) -> io::Error {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(host_type: HostKeyType) -> KnownHostKeyFormat {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(op: PtyModeOpcode) -> ExtensiblePtyModeOpcode {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(op: u8) -> ExtensiblePtyModeOpcode {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn resolve_to_raw_host", "output": "fn resolve_to_raw_host(", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn check_port_", "output": "fn check_port_(&self, host: &str, port: i32, key: &[u8]) -> CheckResult {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn readlink_op", "output": "fn readlink_op(&self, path: &Path, op: c_int) -> Result<PathBuf, Error> {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn lock", "output": "fn lock(&self) -> Result<LockedSftp, Error> {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn error_code_into_error", "output": "fn error_code_into_error(", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn resolve_raw_identity", "output": "fn resolve_raw_identity(", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn session_is_send", "output": "fn session_is_send() {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn must_be_send<T: Send>", "output": "fn must_be_send<T: Send>(_: &T) -> bool {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn smoke", "output": "fn smoke() {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn consume_stdio", "output": "fn consume_stdio(channel: &mut Channel) -> (String, String) {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn smoke", "output": "fn smoke() {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn must_be_send<T: Send>", "output": "fn must_be_send<T: Send>(_: &T) -> bool {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn smoke", "output": "fn smoke() {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn reading", "output": "fn reading() {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn smoke", "output": "fn smoke() {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn ops", "output": "fn ops() {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn not_found", "output": "fn not_found() {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn smoke", "output": "fn smoke() {", "source": "ssh2-0.9.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn do_stuff", "output": "fn do_stuff() -> io::Result<()> {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() -> io::Result<()> {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn write_chars", "output": "fn write_chars() -> io::Result<()> {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn with_inner", "output": "fn with_inner(inner: TermInner) -> Term {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn read_line_internal", "output": "fn read_line_internal(slf: &Term, initial: &str) -> io::Result<String> {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn write_through", "output": "fn write_through(&self, bytes: &[u8]) -> io::Result<()> {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn c_result<F: FnOnce", "output": "fn c_result<F: FnOnce() -> libc::c_int>(f: F) -> io::Result<()> {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn buffered", "output": "fn buffered() -> io::Result<Self> {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn unbuffered", "output": "fn unbuffered() -> io::Result<Self> {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_final", "output": "fn is_final(&self) -> bool {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_trapped", "output": "fn is_trapped(&self) -> bool {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn strip_ansi_codes", "output": "fn strip_ansi_codes(s: &str) -> &str {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn default_colors_enabled", "output": "fn default_colors_enabled(out: &Term) -> bool {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn ansi_num", "output": "fn ansi_num(self) -> usize {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn set_console_mode", "output": "fn set_console_mode(handle: HANDLE, mode: CONSOLE_MODE, enable: bool) -> Option<CONSOLE_MODE> {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn set", "output": "fn set(handle: HANDLE, mode: CONSOLE_MODE, enable: bool) -> Option<Self> {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn handle", "output": "fn handle(&self) -> HANDLE {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn create_for_stream", "output": "fn create_for_stream(kind: HandleKind) -> io::Result<Console> {", "source": "console-0.15.11"}
{"instruction": "Write a Rust function.", "input": "Function: fn set", "output": "fn set(&mut self) -> io::Result<()> {", "source": "console-0.15.11"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def query", "output": "def query(self, q: str, variables: dict = None) -> dict:", "source": "StashGrid"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def query", "output": "def query(self, query: str, variables: dict = None) -> dict:", "source": "StashGrid"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_scene", "output": "def get_scene(self, scene_id: str) -> dict:\nresult = self.query(\"\"\"\nquery GetScene($id: ID!) {\nfindScene(id: $id) {\nid\ntitle\ndetails\nfiles { path duration width height }\nperformers { id name }\ntags { id name }", "source": "StashGrid"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def analyze_frame", "output": "def analyze_frame(self, image_path: str, timestamp: float, frame_num: int,", "source": "StashGrid"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _parse_analysis", "output": "def _parse_analysis(self, data: Dict, timestamp: float, frame_num: int) -> FrameAnalysis:\n\"\"\"Parse API response into structured FrameAnalysis\"\"\"\nposes = []\nexpressions = []\n\nfor person in data.get(\"people\", []):\npose_data = person.get(\"pose\", {})\nposes.append(BodyPose(\nposture_type=pose_data.get(\"posture_type\", \"unknown\"),\nposture_openness=pose_data.get(\"posture_openness\", 0.5),", "source": "StashGrid"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def extract", "output": "def extract(analysis_result: Dict) -> np.ndarray:\n\"\"\"\nExtract a feature vector from an analysis result.\nReturns a normalized vector that captures the signature of this content.\n\"\"\"", "source": "StashGrid"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_state", "output": "def load_state(self):\n\"\"\"Load learned state from disk\"\"\"\n# Load feature vectors\nif FEATURE_VECTORS.exists():\ntry:\nwith open(FEATURE_VECTORS) as f:\ndata = json.load(f)\nself.vectors = {\nk: np.array(v[\"vector\"])\nfor k, v in data.get(\"vectors\", {}).items()", "source": "StashGrid"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def query", "output": "def query(self, q: str, variables: dict = None) -> dict:", "source": "StashGrid"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_video_duration", "output": "def get_video_duration(video_path: str) -> float:\n\"\"\"Get video duration in seconds using ffprobe\"\"\"\ntry:\nresult = subprocess.run([\n\"ffprobe\", \"-v\", \"quiet\",\n\"-show_entries\", \"format=duration\",\n\"-of\", \"json\",\nvideo_path\n], capture_output=True, text=True, timeout=30)\n", "source": "StashGrid"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_master_preview", "output": "def generate_master_preview(video_path: str, output_path: str, duration: float) -> bool:\n\"\"\"Generate a full-video master preview as animated WebP\"\"\"\ntry:\n# Calculate time-lapse factor to fit video into reasonable size\n# Aim for ~30 seconds of preview for any length video\ntarget_duration = min(30, duration)\nspeed_factor = duration / target_duration if duration > 30 else 1\n\n# Use select filter to pick frames at intervals\nframe_interval = max(1, int(speed_factor))", "source": "StashGrid"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_segment_preview", "output": "def generate_segment_preview(video_path: str, output_path: str,", "source": "StashGrid"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def process", "output": "def process(args, app, image_size=224, draw_bbox=False):", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nfc_model, config=None, device=None):", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def render_mesh", "output": "def render_mesh(self, vertices, faces=None, verts_rgb=None):", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, config=None, device=None, tag=''):", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nfc_model, config=None, device=None):", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, model='retinaface', device='cuda:0'):", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def visualize_grid", "output": "def visualize_grid(visdict, savepath=None, size=224, dim=1, return_gird=True):", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def find_dynamic_lmk_idx_and_bcoords", "output": "def find_dynamic_lmk_idx_and_bcoords(vertices, pose, dynamic_lmk_faces_idx,", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def vertices2landmarks", "output": "def vertices2landmarks(vertices, faces, lmk_faces_idx, lmk_bary_coords):", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, z_dim, map_hidden_dim, map_output_dim, hidden=2):", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def conv3x3", "output": "def conv3x3(in_planes, out_planes, stride=1, groups=1, dilation=1):\n\"\"\"3x3 convolution with padding\"\"\"\nreturn nn.Conv2d(in_planes,\nout_planes,\nkernel_size=3,\nstride=stride,\npadding=dilation,\ngroups=groups,\nbias=False,\ndilation=dilation)", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def conv1x1", "output": "def conv1x1(in_planes, out_planes, stride=1):\n\"\"\"1x1 convolution\"\"\"\nreturn nn.Conv2d(in_planes,\nout_planes,\nkernel_size=1,\nstride=stride,\nbias=False)\n\n\nclass IBasicBlock(nn.Module):", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, inplanes, planes, stride=1, downsample=None,", "source": "MICA"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, config=None, device=None, tag='MICA'):", "source": "MICA"}
{"instruction": "Write a Rust function.", "input": "Function: fn enabled", "output": "fn enabled(&self, _: &Metadata) -> bool {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn log", "output": "fn log(&self, _: &Record) {}", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn flush", "output": "fn flush(&self) {}", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn enabled", "output": "fn enabled(&self, _: &Metadata) -> bool {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn log", "output": "fn log(&self, record: &Record) {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn flush", "output": "fn flush(&self) {}", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn u8_to_value", "output": "fn u8_to_value(b: &mut test::Bencher) {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn u8_to_value_debug", "output": "fn u8_to_value_debug(b: &mut test::Bencher) {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn str_to_value_debug", "output": "fn str_to_value_debug(b: &mut test::Bencher) {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize<S>", "output": "fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn deserialize<D>", "output": "fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn expecting", "output": "fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_kvs", "output": "fn into_kvs(self) -> Option<&'a [(&'a str, super::Value<'a>)]>;", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_kvs", "output": "fn into_kvs(self) -> Option<&'a [(&'a str, Value<'a>)]> {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_kvs", "output": "fn into_kvs(self) -> Option<&'a [(&'a str, Value<'a>)]> {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn load", "output": "fn load(&self, _order: Ordering) -> usize {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn store", "output": "fn store(&self, val: usize, _order: Ordering) {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, other: &LevelFilter) -> bool {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_key", "output": "fn to_key(&self) -> Key;", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_key", "output": "fn to_key(&self) -> Key {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_key", "output": "fn to_key(&self) -> Key {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(_: fmt::Error) -> Self {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(err: io::Error) -> Self {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn visit<'kvs>", "output": "fn visit<'kvs>(&'kvs self, visitor: &mut dyn VisitSource<'kvs>) -> Result<(), Error>;", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn get", "output": "fn get(&self, key: Key) -> Option<Value<'_>> {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn count", "output": "fn count(&self) -> usize {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_value", "output": "fn to_value(&self) -> Value;", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_value", "output": "fn to_value(&self) -> Value {", "source": "log-0.4.28"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_value", "output": "fn to_value(&self) -> Value {", "source": "log-0.4.28"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_pixel_coords", "output": "def get_pixel_coords(self, name: str, frame_width: int, frame_height: int) -> Tuple[int, int]:\n\"\"\"Get pixel coordinates for a keypoint.\"\"\"\nif name not in self.keypoints:\nreturn (0, 0)\nx, y = self.keypoints[name]\nreturn (int(x * frame_width), int(y * frame_height))\n\n\nclass AnatomicalHumanGenerator:\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, height_ratio: float = 0.8):\n\"\"\"\nArgs:\nheight_ratio: Human height relative to frame height (0.8 = 80% of frame)\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def check_whisper_cpp", "output": "def check_whisper_cpp() -> bool:\n\"\"\"Check if whisper.cpp is installed.\"\"\"\ntry:\n# Check for whisper-cli (homebrew) or whisper-cpp\nfor cmd in ['whisper-cli', 'whisper-cpp']:\nresult = subprocess.run(\n['which', cmd],\ncapture_output=True,\ntext=True\n)", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def check_argos_translate", "output": "def check_argos_translate() -> bool:\n\"\"\"Check if Argos Translate is available.\"\"\"\ntry:\nimport argostranslate.package\nimport argostranslate.translate\nreturn True\nexcept ImportError:\nreturn False\n\n", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, models_dir: str = '/app/models'):", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def enhance_video", "output": "def enhance_video(self, input_path: str, output_path: str,", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _get_profile_params", "output": "def _get_profile_params(self, profile: str) -> dict:\n\"\"\"Get enhancement parameters for a profile.\"\"\"\nprofiles = {\n'quality': {\n'upscale': True,\n'upscale_model': 'realesrgan',\n'denoise': True,\n'denoise_strength': 0.5,\n'face_enhance': True,\n'stabilize': True,", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _write_skeleton", "output": "def _write_skeleton(self, f):\n\"\"\"Write BVH skeleton hierarchy.\"\"\"\n# Build parent-child relationships\nchildren = {name: [] for name, _, _, _, _ in BVH_SKELETON}\nfor name, parent, _, _, _ in BVH_SKELETON:\nif parent:\nchildren[parent].append(name)\n\n# Find root\nroot = None", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_video_metadata", "output": "def get_video_metadata(video_path: str) -> Dict:\n\"\"\"\nExtract video metadata using FFprobe.\nReturns dict with duration, dimensions, fps, etc.\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, channels: int, use_bn: bool = False):", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def forward", "output": "def forward(self, x: torch.Tensor) -> torch.Tensor:", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def from_profile", "output": "def from_profile(cls, profile: EnhancementProfile) -> 'EnhancementConfig':\n\"\"\"Create config from a preset profile\"\"\"\nprofiles = {\nEnhancementProfile.PROTEUS: cls(\nupscale=True, upscale_factor=4, denoise=True, denoise_strength=0.5,\nsharpen=True, sharpen_strength=0.3, face_enhance=True,\ntemporal_consistency=True, stabilize=True\n),\nEnhancementProfile.ARTEMIS: cls(\nupscale=True, upscale_factor=4, denoise=True, denoise_strength=0.3,", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _get_device", "output": "def _get_device(self) -> str:\n\"\"\"Determine best available device\"\"\"\nif torch.backends.mps.is_available():\nreturn \"mps\"  # Apple Silicon\nelif torch.cuda.is_available():\nreturn \"cuda\"\nreturn \"cpu\"\n\n@property\ndef upscaler(self):", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def from_dict", "output": "def from_dict(cls, data: Dict) -> 'EvolutionaryConfig':", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, output_dir: str):\n\"\"\"\nInitialize exporter.\n\nArgs:\noutput_dir: Output directory for dataset\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _convert_keypoints", "output": "def _convert_keypoints(self, keypoints: List[Dict]) -> Tuple[List[float], int]:\n\"\"\"\nConvert MediaPipe keypoints to COCO format.\n\nReturns:\nTuple of (flattened keypoint list, num visible keypoints)\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def estimate_transforms", "output": "def estimate_transforms(self, video_path: str) -> List[np.ndarray]:\n\"\"\"\nEstimate frame-to-frame transforms.\n\nArgs:\nvideo_path: Path to video\n\nReturns:\nList of 2x3 affine transform matrices\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def compute_trajectory", "output": "def compute_trajectory(self, transforms: List[np.ndarray]) -> np.ndarray:\n\"\"\"\nCompute cumulative camera trajectory from transforms.\n\nArgs:\ntransforms: List of frame-to-frame transforms\n\nReturns:\nNx3 array of (x, y, rotation) trajectory\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_db_path", "output": "def get_db_path() -> Path:\n\"\"\"Get the database path.\"\"\"\nreturn Path(__file__).parent.parent / \"data\" / \"pipeline.db\"\n\n\ndef get_connection() -> sqlite3.Connection:\n\"\"\"Get a database connection with row factory.\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_connection", "output": "def get_connection() -> sqlite3.Connection:\n\"\"\"Get a database connection with row factory.\"\"\"\nconn = sqlite3.connect(get_db_path())\nconn.row_factory = sqlite3.Row\nreturn conn\n\n\ndef init_database():\n\"\"\"Initialize the database schema.\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def init_database", "output": "def init_database():\n\"\"\"Initialize the database schema.\"\"\"\nconn = get_connection()\ncursor = conn.cursor()\n\n# Videos table - stores metadata about input videos\ncursor.execute(\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def compute_blur_score", "output": "def compute_blur_score(frame: np.ndarray) -> float:\n\"\"\"\nCompute blur score using Laplacian variance.\nHigher score = sharper image. Returns 0-1 normalized score.\n\nArgs:\nframe: BGR or grayscale image\n\nReturns:\nBlur quality score (0 = very blurry, 1 = very sharp)", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def reset", "output": "def reset(self):\n\"\"\"Reset the estimator state.\"\"\"\nself.prev_gray = None\n\ndef compute(\nself,\nframe1: np.ndarray,\nframe2: np.ndarray\n) -> np.ndarray:\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def compute_joint_angles", "output": "def compute_joint_angles(keypoints):\n\"\"\"\nCompute joint angles from 2D keypoints.\nReturns array of angles for BVH motion data.\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def export_person_bvh", "output": "def export_person_bvh(poses_data, person_idx, output_path, fps=1):\n\"\"\"\nExport BVH file for a specific person across all frames.\n\nArgs:\nposes_data: List of frame pose data\nperson_idx: Which person to export (0, 1, 2...)\noutput_path: Output BVH file path\nfps: Frame rate\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_model_path", "output": "def get_model_path(model_complexity: int = 1) -> str:\n\"\"\"\nGet path to MediaPipe pose model, downloading if needed.\n\nArgs:\nmodel_complexity: 0=Lite, 1=Full, 2=Heavy\n\nReturns:\nPath to model file\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def scan_input_directory", "output": "def scan_input_directory(self, limit: int = None) -> List[Dict]:\n\"\"\"\nScan input directory for new videos.\n\nArgs:\nlimit: Maximum number of videos to return (None for all)\n\nReturns:\nList of video metadata dicts\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def ingest_videos", "output": "def ingest_videos(self) -> int:\n\"\"\"\nIngest new videos from input directory.\n\nReturns:\nNumber of videos ingested\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def separate_vocals_from_background", "output": "def separate_vocals_from_background(audio_path: str, output_dir: str) -> dict:\n\"\"\"\nUse Demucs to separate vocals from background sounds.\nThis removes water splashing, floor squeaks, ambient noise.\n\nReturns paths to: vocals, drums, bass, other (background)\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def analyze_voice_segments", "output": "def analyze_voice_segments(vocals_path: str, sr: int = 22050) -> list:\n\"\"\"\nAnalyze vocal track to identify voice segments and their characteristics.\nReturns list of segments with start_time, end_time, pitch_stats\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def remove_female_voice_segments", "output": "def remove_female_voice_segments(vocals_path: str, output_path: str,", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def lift", "output": "def lift(self, keypoints_2d: List[Dict]) -> Optional[Pose3D]:\n\"\"\"\nLift 2D keypoints to 3D.\n\nArgs:\nkeypoints_2d: List of 2D keypoints with x, y, visibility, (z optional)\n\nReturns:\nPose3D or None if lifting failed\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _estimate_height", "output": "def _estimate_height(self, kp_dict: Dict) -> Optional[float]:\n\"\"\"Estimate person height from keypoints.\"\"\"\n# Try different height estimation methods\n\n# Method 1: Head to ankle\nif 'nose' in kp_dict and 'left_ankle' in kp_dict:\nnose = kp_dict['nose']\nankle = kp_dict['left_ankle']\nif nose['visibility'] > 0.5 and ankle['visibility'] > 0.5:\nreturn abs(ankle['y'] - nose['y']) * 1.1  # Head above nose", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup_upscaler", "output": "def setup_upscaler():\n\"\"\"Initialize Real-ESRGAN upscaler.\"\"\"\nmodel = RRDBNet(\nnum_in_ch=3, num_out_ch=3,\nnum_feat=64, num_block=23, num_grow_ch=32, scale=4\n)\n\nupsampler = RealESRGANer(\nscale=4,\nmodel_path='/app/models/upscale/RealESRGAN_x4plus.pth',", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_progress", "output": "def load_progress(progress_file):\n\"\"\"Load progress from file.\"\"\"\nif progress_file.exists():\nwith open(progress_file) as f:\nreturn json.load(f)\nreturn {'completed': [], 'failed': [], 'start_time': None}\n\n\ndef save_progress(progress_file, progress):\n\"\"\"Save progress to file.\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def save_progress", "output": "def save_progress(progress_file, progress):\n\"\"\"Save progress to file.\"\"\"\nwith open(progress_file, 'w') as f:\njson.dump(progress, f, indent=2)\n\n\ndef upscale_batch(input_dir, output_dir, start_idx=0, max_frames=None):\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def draw_skeleton", "output": "def draw_skeleton(frame, person, color, thickness=2):\n\"\"\"Draw skeleton on frame for one person.\"\"\"\nh, w = frame.shape[:2]\nkeypoints = person.get('keypoints', {})\n\n# Draw connections\nfor start, end in SIMPLE_CONNECTIONS:\nif start in keypoints and end in keypoints:\npt1 = keypoints[start]\npt2 = keypoints[end]", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def create_skeleton_video", "output": "def create_skeleton_video(poses_file, frames_dir, output_path, fps=1):\n\"\"\"\nCreate video with skeleton overlay.\n\nArgs:\nposes_file: Path to all_poses.json\nframes_dir: Directory with frame images\noutput_path: Output video path\nfps: Output video FPS\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _detect_capabilities", "output": "def _detect_capabilities(self) -> M2Capabilities:\n\"\"\"Detect Apple Silicon capabilities.\"\"\"\ncaps = M2Capabilities()\n\n# Check MPS availability\ncaps.has_mps = torch.backends.mps.is_available()\n\n# Check Neural Engine (via CoreML)\nif COREML_AVAILABLE:\ntry:", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _setup_device", "output": "def _setup_device(self) -> torch.device:\n\"\"\"Set up optimal device.\"\"\"\nif self.capabilities.has_mps:\nreturn torch.device(\"mps\")\nreturn torch.device(\"cpu\")\n\ndef _enable_optimizations(self):\n\"\"\"Enable Apple Silicon optimizations.\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _pose_to_detection", "output": "def _pose_to_detection(self, pose_result) -> Optional[Detection]:\n\"\"\"\nConvert a PoseResult to Norfair Detection.\n\nArgs:\npose_result: PoseResult from pose estimation\n\nReturns:\nNorfair Detection or None\n\"\"\"", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def reset", "output": "def reset(self):\n\"\"\"Reset estimator state.\"\"\"\nself.prev_gray = None\nself.prev_keypoints = None\nself.prev_descriptors = None\n\ndef estimate(\nself,\nframe1: np.ndarray,\nframe2: np.ndarray", "source": "motion-pipeline"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def from_dict", "output": "def from_dict(cls, data: Dict) -> 'ProcessingState':", "source": "motion-pipeline"}
{"instruction": "Write a Rust function.", "input": "Function: fn CGRequestScreenCaptureAccess", "output": "fn CGRequestScreenCaptureAccess() -> boolean_t;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn CGPreflightScreenCaptureAccess", "output": "fn CGPreflightScreenCaptureAccess() -> boolean_t;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop = CGDisplayModeRelease;", "output": "fn drop = CGDisplayModeRelease;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone = |p| CFRetain", "output": "fn clone = |p| CFRetain(p as *const _) as *mut _;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop = |p| CFRelease", "output": "fn drop = |p| CFRelease(p as *mut _);", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone = |p| CFRetain", "output": "fn clone = |p| CFRetain(p as *const _) as *mut _;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn CGFontCreateWithDataProvider", "output": "fn CGFontCreateWithDataProvider(", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop = |p| CFRelease", "output": "fn drop = |p| CFRelease(p as *mut _);", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone = |p| CFRetain", "output": "fn clone = |p| CFRetain(p as *const _) as *mut _;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn CGGradientCreateWithColorComponents", "output": "fn CGGradientCreateWithColorComponents(", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn CGColorCreateGenericRGB", "output": "fn CGColorCreateGenericRGB(", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn CGColorGetTypeID", "output": "fn CGColorGetTypeID() -> CFTypeID;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop = |p| CFRelease", "output": "fn drop = |p| CFRelease(p as *mut _);", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone = |p| CFRetain", "output": "fn clone = |p| CFRetain(p as *const _) as *mut _;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn CGEventSourceGetTypeID", "output": "fn CGEventSourceGetTypeID() -> CFTypeID;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop = |p| CFRelease", "output": "fn drop = |p| CFRelease(p as *mut _);", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone = |p| CFRetain", "output": "fn clone = |p| CFRetain(p as *const _) as *mut _;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn CGEventGetTypeID", "output": "fn CGEventGetTypeID() -> CFTypeID;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop = CGImageRelease;", "output": "fn drop = CGImageRelease;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone = |p| CFRetain", "output": "fn clone = |p| CFRetain(p as *const _) as *mut _;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn CGImageGetTypeID", "output": "fn CGImageGetTypeID() -> CFTypeID;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop = |p| CFRelease", "output": "fn drop = |p| CFRelease(p as *mut _);", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone = |p| CFRetain", "output": "fn clone = |p| CFRetain(p as *const _) as *mut _;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn new<'b>", "output": "fn new<'b>(element: *const CGPathElement) -> CGPathElementRef<'b> {", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop = |cs| CFRelease", "output": "fn drop = |cs| CFRelease(cs as *mut _);", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone = |p| CFRetain", "output": "fn clone = |p| CFRetain(p as *const _) as *mut _;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_data_provider", "output": "fn test_data_provider() {", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop = |p| CFRelease", "output": "fn drop = |p| CFRelease(p as *mut _);", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone = |p| CFRetain", "output": "fn clone = |p| CFRetain(p as *const _) as *mut _;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn CGColorSpaceCreateDeviceRGB", "output": "fn CGColorSpaceCreateDeviceRGB() -> crate::sys::CGColorSpaceRef;", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop = |cs| CGContextRelease", "output": "fn drop = |cs| CGContextRelease(cs);", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone = |p| CGContextRetain", "output": "fn clone = |p| CGContextRetain(p);", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn create_bitmap_context_test", "output": "fn create_bitmap_context_test() {", "source": "core-graphics-0.23.2"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def tensor_to_filelike", "output": "def tensor_to_filelike(tensor, max_pixels: int = 2048*2048):\n\"\"\"\nConverts a PyTorch tensor to a file-like object.\n\nArgs:\n- tensor (torch.Tensor): A tensor representing an image of shape (H, W, C)\nwhere C is the number of channels (3 for RGB), H is height, and W is width.\n\nReturns:\n- io.BytesIO: A file-like object containing the image data.", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def check_rodin_status", "output": "def check_rodin_status(response: Rodin3DCheckStatusResponse) -> str:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_video_url_from_task_status", "output": "def get_video_url_from_task_status(response: TaskStatusResponse) -> str | None:\n\"\"\"Returns the video URL from the task status response if it exists.\"\"\"\nif hasattr(response, \"output\") and len(response.output) > 0:\nreturn response.output[0]\nreturn None\n\n\ndef extract_progress_from_task_status(\nresponse: TaskStatusResponse,\n) -> float | None:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_image_url_from_task_status", "output": "def get_image_url_from_task_status(response: TaskStatusResponse) -> str | None:\n\"\"\"Returns the image URL from the task status response if it exists.\"\"\"\nif hasattr(response, \"output\") and len(response.output) > 0:\nreturn response.output[0]\nreturn None\n\n\nasync def get_response(\ncls: type[IO.ComfyNode], task_id: str, estimated_duration: int | None = None\n) -> TaskStatusResponse:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_video_url_from_response", "output": "def get_video_url_from_response(response) -> Optional[str]:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_video_from_response", "output": "def get_video_from_response(response) -> TaskResult:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_parts_by_type", "output": "def get_parts_by_type(response: GeminiGenerateContentResponse, part_type: Literal[\"text\"] | str) -> list[GeminiPart]:\n\"\"\"\nFilter response parts by their type.\n\nArgs:\nresponse: The API response from Gemini.\npart_type: Type of parts to extract (\"text\" or a MIME type).\n\nReturns:\nList of response parts matching the requested type.", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_text_from_response", "output": "def get_text_from_response(response: GeminiGenerateContentResponse) -> str:\n\"\"\"\nExtract and concatenate all text parts from the response.\n\nArgs:\nresponse: The API response from Gemini.\n\nReturns:\nCombined text from all text parts in the response.\n\"\"\"", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def calculate_tokens_price", "output": "def calculate_tokens_price(response: GeminiGenerateContentResponse) -> float | None:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_async_dummy_status", "output": "def get_async_dummy_status(x: StabilityResultsGetResponse):", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def convert_mask_to_image", "output": "def convert_mask_to_image(mask: Input.Image):\n\"\"\"\nMake mask have the expected amount of dims (4) and channels (3) to be recognized as an image.\n\"\"\"", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def normalize_omni_prompt_references", "output": "def normalize_omni_prompt_references(prompt: str) -> str:\n\"\"\"\nRewrites Kling Omni-style placeholders used in the app, like:\n\n@image, @image1, @image2, ... @imageN\n@video, @video1, @video2, ... @videoN\n\ninto the API-compatible form:\n\n<<<image_1>>>, <<<image_2>>>, ...", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_model_url_from_response", "output": "def get_model_url_from_response(response: TripoTaskResponse) -> str:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def is_valid_task_creation_response", "output": "def is_valid_task_creation_response(response: MoonvalleyPromptResponse) -> bool:\n\"\"\"Verifies that the initial response contains a task ID.\"\"\"\nreturn bool(response.id)\n\n\ndef validate_task_creation_response(response) -> None:\nif not is_valid_task_creation_response(response):\nerror_msg = f\"Moonvalley Marey API: Initial request failed. Code: {response.code}, Message: {response.message}, Data: {response}\"\nlogging.error(error_msg)\nraise RuntimeError(error_msg)", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def validate_task_creation_response", "output": "def validate_task_creation_response(response) -> None:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def validate_video_to_video_input", "output": "def validate_video_to_video_input(video: Input.Video) -> Input.Video:\n\"\"\"\nValidates and processes video input for Moonvalley Video-to-Video generation.\n\nArgs:\nvideo: Input video to validate\n\nReturns:\nValidated and potentially trimmed video\n", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def execute", "output": "def execute(cls, image: torch.Tensor, weight: float, luma_ref: LumaReferenceChain = None) -> IO.NodeOutput:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def handle_converted_lists", "output": "def handle_converted_lists(item, parent_key, lists_to_check=list[list]):", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _create_base_config", "output": "def _create_base_config(field_info: FieldInfo) -> InputTypeOptions:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _get_number_constraints_config", "output": "def _get_number_constraints_config(field_info: FieldInfo) -> dict:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _model_field_to_image_input", "output": "def _model_field_to_image_input(field_info: FieldInfo, **kwargs) -> NodeInput:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def calculate_tokens_price_image_1", "output": "def calculate_tokens_price_image_1(response: OpenAIImageGenerationResponse) -> float | None:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_image_url_from_response", "output": "def get_image_url_from_response(response: ImageTaskCreationResponse) -> str:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, image: torch.Tensor, weight: float):", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_stability_style_presets", "output": "def get_stability_style_presets(include_none=True):", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _generate_operation_id", "output": "def _generate_operation_id(method: str, url: str, attempt: int, op_uuid: str) -> str:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_log_directory", "output": "def get_log_directory():\n\"\"\"Ensures the API log directory exists within ComfyUI's temp directory and returns its path.\"\"\"\nbase_temp_dir = folder_paths.get_temp_directory()\nlog_dir = os.path.join(base_temp_dir, \"api_logs\")\ntry:\nos.makedirs(log_dir, exist_ok=True)\nexcept Exception as e:\nlogger.error(\"Error creating API log directory %s: %s\", log_dir, str(e))\n# Fallback to base temp directory if sub-directory creation fails\nreturn base_temp_dir", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _sanitize_filename_component", "output": "def _sanitize_filename_component(name: str) -> str:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _short_hash", "output": "def _short_hash(*parts: str, length: int = 10) -> str:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def bytesio_to_image_tensor", "output": "def bytesio_to_image_tensor(image_bytesio: BytesIO, mode: str = \"RGBA\") -> torch.Tensor:\n\"\"\"Converts image data from BytesIO to a torch.Tensor.\n\nArgs:\nimage_bytesio: BytesIO object containing the image data.\nmode: The PIL mode to convert the image to (e.g., \"RGB\", \"RGBA\").\n\nReturns:\nA torch.Tensor representing the image (1, H, W, C).\n", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def image_tensor_pair_to_batch", "output": "def image_tensor_pair_to_batch(image1: torch.Tensor, image2: torch.Tensor) -> torch.Tensor:\n\"\"\"\nConverts a pair of image tensors to a batch tensor.\nIf the images are not the same size, the smaller image is resized to\nmatch the larger image.\n\"\"\"", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _generate_operation_id", "output": "def _generate_operation_id(method: str, url: str, attempt: int) -> str:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_image_dimensions", "output": "def get_image_dimensions(image: torch.Tensor) -> tuple[int, int]:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def is_processing_interrupted", "output": "def is_processing_interrupted() -> bool:\n\"\"\"Return True if user/runtime requested interruption.\"\"\"\nreturn processing_interrupted()\n\n\ndef get_node_id(node_cls: type[IO.ComfyNode]) -> str:\nreturn node_cls.hidden.unique_id\n\n\ndef get_auth_header(node_cls: type[IO.ComfyNode]) -> dict[str, str]:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_node_id", "output": "def get_node_id(node_cls: type[IO.ComfyNode]) -> str:", "source": "comfy_api_nodes"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_auth_header", "output": "def get_auth_header(node_cls: type[IO.ComfyNode]) -> dict[str, str]:", "source": "comfy_api_nodes"}
{"instruction": "Write a Rust function.", "input": "Function: fn timeout_closes_connection", "output": "fn timeout_closes_connection() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn timeout_blocking_request", "output": "fn timeout_blocking_request() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn blocking_request_timeout_body", "output": "fn blocking_request_timeout_body() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_redirect_307_does_not_try_if_reader_cannot_reset", "output": "fn test_redirect_307_does_not_try_if_reader_cannot_reset() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn log", "output": "fn log(s: &str);", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn use_preconfigured_tls_with_bogus_backend", "output": "fn use_preconfigured_tls_with_bogus_backend() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn use_preconfigured_native_tls_default", "output": "fn use_preconfigured_native_tls_default() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn use_preconfigured_rustls_default", "output": "fn use_preconfigured_rustls_default() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn blocking_file_part", "output": "fn blocking_file_part() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_response_text", "output": "fn test_response_text() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_response_non_utf_8_text", "output": "fn test_response_non_utf_8_text() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_response_json", "output": "fn test_response_json() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {}", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {}", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() -> Result<(), Box<dyn std::error::Error>> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {}", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn url", "output": "fn url(self, url: Url) -> Self;", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn url", "output": "fn url(self, url: Url) -> Self {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_response_builder_ext", "output": "fn test_response_builder_ext() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn maybe_http_auth", "output": "fn maybe_http_auth(&self) -> Option<&HeaderValue> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_proxy_scheme", "output": "fn into_proxy_scheme(self) -> crate::Result<ProxyScheme>;", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_proxy_scheme", "output": "fn into_proxy_scheme(self) -> crate::Result<ProxyScheme> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Policy {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn seed", "output": "fn seed() -> u64 {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn source", "output": "fn source(&self) -> Option<&(dyn StdError + 'static)> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn _assert_impls", "output": "fn _assert_impls() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn assert_send<T: Send>", "output": "fn assert_send<T: Send>() {}", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn assert_sync<T: Sync>", "output": "fn assert_sync<T: Sync>() {}", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_uri", "output": "fn into_uri(scheme: Scheme, host: Authority) -> Uri {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn poll_ready", "output": "fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn call", "output": "fn call(&mut self, dst: Uri) -> Self::Future {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_url", "output": "fn into_url(self) -> crate::Result<Url>;", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_str", "output": "fn as_str(&self) -> &str;", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_url", "output": "fn into_url(self) -> crate::Result<Url> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn read_pem_certs", "output": "fn read_pem_certs(reader: &mut impl BufRead) -> crate::Result<Vec<Vec<u8>>> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn set_cookies", "output": "fn set_cookies(&self, cookie_headers: &mut dyn Iterator<Item = &HeaderValue>, url: &url::Url);", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn cookies", "output": "fn cookies(&self, url: &url::Url) -> Option<HeaderValue>;", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn parse", "output": "fn parse(value: &'a HeaderValue) -> Result<Cookie<'a>, CookieParseError> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(r: http::Response<T>) -> Response {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(r: Response) -> Body {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn header_sensitive<K, V>", "output": "fn header_sensitive<K, V>(mut self, key: K, value: V, sensitive: bool) -> RequestBuilder", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn poll_read", "output": "fn poll_read(", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn poll_write", "output": "fn poll_write(", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn poll_write_vectored", "output": "fn poll_write_vectored(", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn user_agent", "output": "fn user_agent(headers: &HeaderMap) -> Option<HeaderValue> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(body: hyper::Body) -> Body {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(bytes: Bytes) -> Body {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(vec: Vec<u8>) -> Body {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn value_len", "output": "fn value_len(&self) -> Option<u64>;", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn metadata", "output": "fn metadata(&self) -> &PartMetadata;", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn plain_text", "output": "fn plain_text(body: Body) -> Decoder {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn gzip", "output": "fn gzip(body: Body) -> Decoder {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn body_mut", "output": "fn body_mut(&mut self) -> Pin<&mut dyn futures_util::io::AsyncRead> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn read", "output": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn header_sensitive<K, V>", "output": "fn header_sensitive<K, V>(mut self, key: K, value: V, sensitive: bool) -> RequestBuilder", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_from", "output": "fn try_from(req: HttpRequest<T>) -> crate::Result<Self> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn wake_by_ref", "output": "fn wake_by_ref(arc_self: &Arc<Self>) {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn enter", "output": "fn enter() {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn with_inner<F>", "output": "fn with_inner<F>(mut self, func: F) -> ClientBuilder", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(builder: async_impl::ClientBuilder) -> Self {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_clone", "output": "fn try_clone(&self) -> Option<Kind> {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(v: Vec<u8>) -> Body {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(s: String) -> Body {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn with_inner<F>", "output": "fn with_inner<F>(self, func: F) -> Self", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt_request_fields<'a, 'b>", "output": "fn fmt_request_fields<'a, 'b>(", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn fetch_with_request", "output": "fn fetch_with_request(input: &web_sys::Request) -> Promise;", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn js_fetch", "output": "fn js_fetch(req: &web_sys::Request) -> Promise {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn merge_headers", "output": "fn merge_headers(&self, req: &mut Request) {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_bytes", "output": "fn as_bytes(&self) -> &[u8] {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_empty", "output": "fn is_empty(&self) -> bool {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(bytes: Bytes) -> Body {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn metadata", "output": "fn metadata(&self) -> &PartMetadata;", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn with_inner<F>", "output": "fn with_inner<F>(self, func: F) -> Self", "source": "reqwest-0.11.27"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn issue_392", "output": "fn issue_392() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn notify_one_slow", "output": "fn notify_one_slow(&self, mutex: *mut RawMutex) -> bool {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn notify_all_slow", "output": "fn notify_all_slow(&self, mutex: *mut RawMutex) -> usize {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn wait_until_internal", "output": "fn wait_until_internal(&self, mutex: &RawMutex, timeout: Option<Instant>) -> WaitTimeoutResult {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn check_deadlock", "output": "fn check_deadlock() -> bool {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_mutex_deadlock", "output": "fn test_mutex_deadlock() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_mutex_deadlock_reentrant", "output": "fn test_mutex_deadlock_reentrant() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn lock", "output": "fn lock(&self) {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_lock", "output": "fn try_lock(&self) -> bool {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_locked", "output": "fn is_locked(&self) -> bool {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn nonzero_thread_id", "output": "fn nonzero_thread_id(&self) -> NonZeroUsize {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn smoke", "output": "fn smoke() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_mutex", "output": "fn is_mutex() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn smoke", "output": "fn smoke() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn frob", "output": "fn frob() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_rw_arc_no_poison_wr", "output": "fn test_rw_arc_no_poison_wr() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn smoke", "output": "fn smoke() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn lots_and_lots", "output": "fn lots_and_lots() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn inc", "output": "fn inc(m: &Mutex<u32>) {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn lock_exclusive", "output": "fn lock_exclusive(&self) {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_lock_exclusive", "output": "fn try_lock_exclusive(&self) -> bool {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn lock_shared", "output": "fn lock_shared(&self) {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn elision_compare_exchange_acquire", "output": "fn elision_compare_exchange_acquire(", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn elision_fetch_sub_release", "output": "fn elision_fetch_sub_release(&self, val: Self::IntType) -> Self::IntType;", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn elision_compare_exchange_acquire", "output": "fn elision_compare_exchange_acquire(&self, _: usize, _: usize) -> Result<usize, usize> {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn smoke", "output": "fn smoke() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn lots_and_lots", "output": "fn lots_and_lots() {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn inc", "output": "fn inc(m: &FairMutex<u32>) {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn call_once_slow", "output": "fn call_once_slow(&self, ignore_poison: bool, f: &mut dyn FnMut(OnceState)) {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Once {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn lock", "output": "fn lock(&self) {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_lock", "output": "fn try_lock(&self) -> bool {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_locked", "output": "fn is_locked(&self) -> bool {", "source": "parking_lot-0.12.5"}
{"instruction": "Write a Rust function.", "input": "Function: fn smoke", "output": "fn smoke() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn reserve_over_capacity", "output": "fn reserve_over_capacity() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn with_capacity_max", "output": "fn with_capacity_max() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn from_bytes", "output": "fn from_bytes() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn equates_with_u16", "output": "fn equates_with_u16() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn roundtrip", "output": "fn roundtrip() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn header_map_fuzz", "output": "fn header_map_fuzz() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn prop", "output": "fn prop(fuzz: Fuzz) -> TestResult {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new(seed: [u8; 32]) -> Fuzz {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Response<T> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new() -> Parts {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Request<T> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new() -> Parts {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn deref", "output": "fn deref(&self) -> &str {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(src: String) -> ByteStr {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(src: &'a str) -> ByteStr {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn source", "output": "fn source(&self) -> Option<&(dyn error::Error + 'static)> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Version {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn _assert_types", "output": "fn _assert_types() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn assert_send<T: Send>", "output": "fn assert_send<T: Send>() {}", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn assert_sync<T: Sync>", "output": "fn assert_sync<T: Sync>() {}", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> StatusCode {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn extension_inline", "output": "fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_ref", "output": "fn as_ref(&self) -> &str {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, other: &&'a Method) -> bool {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn write", "output": "fn write(&mut self, _: &[u8]) {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn write_u64", "output": "fn write_u64(&mut self, id: u64) {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn finish", "output": "fn finish(&self) -> u64 {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(port: Port<T>) -> Self {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_from", "output": "fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_from", "output": "fn try_from(s: &'a str) -> Result<Self, Self::Error> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn from_str", "output": "fn from_str(s: &str) -> Result<Self, Self::Err> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_from", "output": "fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_from", "output": "fn try_from(s: &'a str) -> Result<Self, Self::Error> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_from", "output": "fn try_from(vec: Vec<u8>) -> Result<Self, Self::Error> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn from_shared", "output": "fn from_shared(s: Bytes) -> Result<Uri, InvalidUri> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn has_path", "output": "fn has_path(&self) -> bool {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_from", "output": "fn try_from(t: &'a [u8]) -> Result<Self, Self::Error> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_char_table", "output": "fn test_char_table() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn $test_name", "output": "fn $test_name() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_uri_parse_error", "output": "fn test_uri_parse_error() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn parse_non_empty", "output": "fn parse_non_empty(s: &[u8]) -> Result<usize, InvalidUri> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_ref", "output": "fn as_ref(&self) -> &str {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, other: &Authority) -> bool {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn map<F>", "output": "fn map<F>(self, func: F) -> Self", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Builder {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn build_from_str", "output": "fn build_from_str() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn from_shared", "output": "fn from_shared(src: Bytes) -> Result<HeaderValue, InvalidHeaderValue> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_from_generic<T: AsRef<[u8]>, F: FnOnce", "output": "fn try_from_generic<T: AsRef<[u8]>, F: FnOnce(T) -> Bytes>(src: T, into: F) -> Result<HeaderValue, InvalidHeaderValue> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_ref", "output": "fn as_ref(&self) -> &[u8] {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_str", "output": "fn as_str(&self) -> &'static str {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_parse_standard_headers", "output": "fn test_parse_standard_headers() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_standard_headers_into_bytes", "output": "fn test_standard_headers_into_bytes() {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn get2<K>", "output": "fn get2<K>(&self, key: &K) -> Option<&T>", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn value_iter", "output": "fn value_iter(&self, idx: Option<usize>) -> ValueIter<'_, T> {", "source": "http-0.2.12"}
{"instruction": "Write a Rust function.", "input": "Function: fn value_iter_mut", "output": "fn value_iter_mut(&mut self, idx: usize) -> ValueIterMut<'_, T> {", "source": "http-0.2.12"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def build_read_buffer", "output": "def build_read_buffer(user_args, read_buffer, videogen):", "source": "RIFE"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def build_read_buffer", "output": "def build_read_buffer(user_args, read_buffer, videogen):", "source": "RIFE"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_and_install", "output": "def download_and_install(version_prefix = None, install_root = None, arch = 'x86_64'):", "source": "flare-bypasser-0.1.52"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, page: zendriver.Tab, center_coords):", "source": "flare-bypasser-0.1.52"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_attrs", "output": "def _make_attrs(self):  # override for exclude exception on __init__", "source": "flare-bypasser-0.1.52"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_class_command_processors", "output": "def parse_class_command_processors(custom_command_processors_str: str):", "source": "flare-bypasser-0.1.52"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_entrypoint_command_processors", "output": "def parse_entrypoint_command_processors(extension: str):", "source": "flare-bypasser-0.1.52"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, proxy_storage: object, local_port: int, url: str):", "source": "flare-bypasser-0.1.52"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_and_install", "output": "def download_and_install(version_prefix = None, install_root = None, arch = 'x86_64'):", "source": "flare_bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, page: zendriver.Tab, center_coords):", "source": "flare_bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_attrs", "output": "def _make_attrs(self):  # override for exclude exception on __init__", "source": "flare_bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_class_command_processors", "output": "def parse_class_command_processors(custom_command_processors_str: str):", "source": "flare_bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_entrypoint_command_processors", "output": "def parse_entrypoint_command_processors(extension: str):", "source": "flare_bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, proxy_storage: object, local_port: int, url: str):", "source": "flare_bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def build_read_buffer", "output": "def build_read_buffer(user_args, read_buffer, videogen):", "source": "RIFE"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def build_read_buffer", "output": "def build_read_buffer(user_args, read_buffer, videogen):", "source": "RIFE"}
{"instruction": "Write a Rust function.", "input": "Function: fn too_large_allocation", "output": "fn too_large_allocation() {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn too_large_allocation_2", "output": "fn too_large_allocation_2() {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn empty_offset_table", "output": "fn empty_offset_table() {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn source", "output": "fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn u64_to_usize", "output": "fn u64_to_usize(len_u64: u64) -> Option<usize> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn custom<T: Display>", "output": "fn custom<T: Display>(msg: T) -> Self {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize_with_option_mode<T: ?Sized + ser::Serialize>", "output": "fn serialize_with_option_mode<T: ?Sized + ser::Serialize>(", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn maybe_write_pending_struct_field_name", "output": "fn maybe_write_pending_struct_field_name(&mut self) -> Result<(), Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_secs_f64", "output": "fn as_secs_f64(d: Duration) -> f64 {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(date: SystemTime) -> Self {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize<S>", "output": "fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn expecting", "output": "fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn custom<T: Display>", "output": "fn custom<T: Display>(msg: T) -> Self {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn with_option_mode<T, F: FnOnce", "output": "fn with_option_mode<T, F: FnOnce(&mut Deserializer<'event, I>) -> Result<T, Error>>(", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn enter_plist_value<T, F: FnOnce", "output": "fn enter_plist_value<T, F: FnOnce(&mut Deserializer<'event, I>) -> Result<T, Error>>(", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(from: Vec<u8>) -> Self {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(from: Data) -> Self {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_ref", "output": "fn as_ref(&self) -> &[u8] {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_writer_inner", "output": "fn to_writer_inner(&self, writer: &mut dyn Writer) -> Result<(), Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize<S>", "output": "fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn deserialize<D>", "output": "fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn write_start_array", "output": "fn write_start_array(&mut self, len: Option<u64>) -> Result<(), Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn write_start_dictionary", "output": "fn write_start_dictionary(&mut self, len: Option<u64>) -> Result<(), Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn write_end_collection", "output": "fn write_end_collection(&mut self) -> Result<(), Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn index", "output": "fn index(&self, index: &str) -> &Value {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn index_mut", "output": "fn index_mut(&mut self, index: &str) -> &mut Value {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(value: i64) -> Integer {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn write_element_and_value", "output": "fn write_element_and_value(&mut self, name: &str, value: &str) -> Result<(), Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn start_element", "output": "fn start_element(&mut self, name: &str) -> Result<(), Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn end_element", "output": "fn end_element(&mut self, name: &str) -> Result<(), Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(err: XmlReaderError) -> Self {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<Result<OwnedEvent, Error>> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn xml_reader_pos", "output": "fn xml_reader_pos(&self) -> FilePosition {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn error", "output": "fn error(&self, kind: ErrorKind) -> Error {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn read_one", "output": "fn read_one(&mut self) -> Result<Option<u8>, Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn advance", "output": "fn advance(&mut self) -> Result<Option<u8>, Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn read_all", "output": "fn read_all(&mut self, buf: &mut [u8]) -> Result<(), Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn seek", "output": "fn seek(&mut self, pos: SeekFrom) -> Result<u64, Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn read", "output": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn write_start_collection", "output": "fn write_start_collection(&mut self, ty: CollectionType) -> Result<(), Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn write_end_collection", "output": "fn write_end_collection(&mut self) -> Result<(), Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn write_value", "output": "fn write_value(&mut self, value: Value) -> Result<(), Error> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<Event<'a>> {", "source": "plist-1.8.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn handle_value<'c, 'b: 'c>", "output": "fn handle_value<'c, 'b: 'c>(", "source": "plist-1.8.0"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_and_install", "output": "def download_and_install(version_prefix = None, install_root = None, arch = 'x86_64'):", "source": "flare-bypasser-0.1.52"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, page: zendriver.Tab, center_coords):", "source": "flare-bypasser-0.1.52"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_attrs", "output": "def _make_attrs(self):  # override for exclude exception on __init__", "source": "flare-bypasser-0.1.52"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_class_command_processors", "output": "def parse_class_command_processors(custom_command_processors_str: str):", "source": "flare-bypasser-0.1.52"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_entrypoint_command_processors", "output": "def parse_entrypoint_command_processors(extension: str):", "source": "flare-bypasser-0.1.52"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, proxy_storage: object, local_port: int, url: str):", "source": "flare-bypasser-0.1.52"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_and_install", "output": "def download_and_install(version_prefix = None, install_root = None, arch = 'x86_64'):", "source": "flare_bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, page: zendriver.Tab, center_coords):", "source": "flare_bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_attrs", "output": "def _make_attrs(self):  # override for exclude exception on __init__", "source": "flare_bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_class_command_processors", "output": "def parse_class_command_processors(custom_command_processors_str: str):", "source": "flare_bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_entrypoint_command_processors", "output": "def parse_entrypoint_command_processors(extension: str):", "source": "flare_bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, proxy_storage: object, local_port: int, url: str):", "source": "flare_bypasser"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_metrics", "output": "def generate_metrics():\n\"\"\"Generate current system metrics.\"\"\"\ntry:\nmem = psutil.virtual_memory()\ndisk = psutil.disk_usage('/')\nnet_io = psutil.net_io_counters(pernic=True)\nreturn {\n'cpu_percent': psutil.cpu_percent(interval=1),\n'memory_percent': mem.percent,\n'disk_percent': disk.percent,", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def send_metrics", "output": "def send_metrics():\n\"\"\"SSE event generator.\"\"\"\ntry:\nwhile True:\nmetrics = generate_metrics()\nyield f\"data: {json.dumps(metrics)}\\n\\n\"\nsleep(2)  # Update every 2 seconds\nexcept GeneratorExit:\npass\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def healthz", "output": "def healthz():\n\"\"\"Health check endpoint.\"\"\"\ntry:\n# Basic system checks\npsutil.cpu_percent()\npsutil.virtual_memory()\npsutil.disk_usage('/')\nreturn jsonify({\n'status': 'healthy',\n'timestamp': datetime.now().isoformat()", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _load_config", "output": "def _load_config(self) -> Dict[str, Any]:\n\"\"\"Load deployment configuration.\"\"\"\nconfig = {\n'production': {\n'host': os.getenv('DEPLOY_HOST', 'localhost'),\n'port': int(os.getenv('DEPLOY_PORT', 8000)),\n'api_key': os.getenv('DEPLOY_KEY'),\n'backup_retention_days': 7\n},\n'staging': {", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def create_backup", "output": "def create_backup(self, env: str) -> str:\n\"\"\"Create backup of current deployment.\"\"\"\nlogger.info(f\"Creating backup for {env} environment\")\n\ntimestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\nbackup_path = self.backup_dir / f\"backup_{env}_{timestamp}.tar.gz\"\n\ntry:\n# Create backup archive\nsubprocess.run([", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_system_status", "output": "def get_system_status() -> Dict:\n\"\"\"Get comprehensive system status including metrics and state.\"\"\"\ntry:\nmetrics = system_metrics.get_all_metrics()\nstatus = 'healthy'\nissues = []\nif metrics['cpu'].get('percent', 0) > 80:\nissues.append(f\"High CPU usage: {metrics['cpu']['percent']}%\")\nstatus = 'warning'\nif metrics['memory'].get('virtual', {}).get('percent', 0) > 80:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_memorycore_stats", "output": "def get_memorycore_stats():\n\"\"\"Get MemoryCore specific statistics.\"\"\"\nbase_path = Path('/Volumes/Mac Mini External/MemoryCore')\nstats = {'total_files': 0, 'total_size': 0, 'categories': {}, 'recent_changes': []}\nfor category in ['docs', 'scripts', 'data', 'models']:\ncat_path = base_path / category\nif cat_path.exists():\nfiles = list(cat_path.rglob('*'))\nfile_count = len([f for f in files if f.is_file()])\ntotal_size = sum((f.stat().st_size for f in files if f.is_file()))", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_recent_events", "output": "def get_recent_events():\n\"\"\"Get most recent events from timeline data and other sources.\"\"\"\nevents = []\nenriched_path = Path('/Volumes/Mac Mini External/MemoryCore/docs/dashboard/data/timeline/timeline_enriched.json')\nraw_path = Path('/Volumes/Mac Mini External/MemoryCore/docs/dashboard/data/timeline/timeline_data.json')\ntimeline_path = enriched_path if enriched_path.exists() else raw_path\nif timeline_path.exists():\ntry:\nwith open(timeline_path) as f:\ndata = json.load(f)", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def format_html_doc", "output": "def format_html_doc(content: str) -> str:\n\"\"\"Wrap content in a complete HTML document structure.\"\"\"\nreturn f\"\"\"<!DOCTYPE html>", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_html_content", "output": "def generate_html_content(metrics: Dict, events: List, timeline_data: Optional[Dict], narrative_data: Optional[Dict]) -> str:\n\"\"\"Generate the main HTML content.\"\"\"\ntry:\n# Build HTML content piece by piece\nparts = []\n\n# Add header\nparts.append(\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup_logging", "output": "def setup_logging():\n\"\"\"Configure logging with rotation and structured format.\"\"\"\n# Create log directory if it doesn't exist\nLOG_DIR.mkdir(parents=True, exist_ok=True)\n\n# Create rotating file handler for debugging\nfile_handler = RotatingFileHandler(\nLOG_FILE,\nmaxBytes=MAX_BYTES,\nbackupCount=BACKUP_COUNT", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def log_with_context", "output": "def log_with_context(logger, level, message, **context):\n\"\"\"\nLog a message with additional context.\n\nArgs:\nlogger: Logger instance\nlevel: Logging level (e.g., INFO, ERROR)\nmessage: Log message\n**context: Additional context as key-value pairs\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get", "output": "def get(self, key: str) -> Optional[Any]:\n\"\"\"\nGet a value from cache if it exists and hasn't expired.\n\nArgs:\nkey: Cache key\n\nReturns:\nCached value if valid, None otherwise\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def set", "output": "def set(self, key: str, value: Any) -> None:\n\"\"\"\nSet a value in cache with current timestamp.\n\nArgs:\nkey: Cache key\nvalue: Value to cache\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _send_request", "output": "def _send_request(self, payload: Dict[str, Any]) -> requests.Response:\n\"\"\"Send request to Pushover API with retry logic\"\"\"\nfor attempt in range(self.retry_attempts):\ntry:\nresponse = requests.post(self.PUSHOVER_API_URL, data=payload)\nresponse.raise_for_status()\nreturn response\nexcept requests.RequestException as e:\nlogger.warning(f'Attempt {attempt + 1} failed: {str(e)}')\nif attempt < self.retry_attempts - 1:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def speak_message", "output": "def speak_message(self, message: str, voice: str='Daniel') -> None:\n\"\"\"\nSpeak the message using macOS text-to-speech\n\nArgs:\nmessage: The message to speak\nvoice: The voice to use (default: Daniel)\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def signal_handler", "output": "def signal_handler(signum, frame):\n\"\"\"Handle signals gracefully.\"\"\"\nlocal_logger = logging.getLogger('Launcher')\nif flask_process:\nlocal_logger.info(\"Stopping dashboard...\")\nflask_process.terminate()\ntry:\nflask_process.wait(timeout=5)\nexcept subprocess.TimeoutExpired:\nflask_process.kill()", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup_logging", "output": "def setup_logging():\n\"\"\"Set up logging.\"\"\"\nlog_dir = Path(__file__).parent / 'logs'\nlog_dir.mkdir(exist_ok=True, parents=True)\n\nlogging.basicConfig(\nlevel=logging.INFO,\nformat='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\nhandlers=[\nlogging.FileHandler(log_dir / 'dashboard.log'),", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def check_dependencies", "output": "def check_dependencies():\n\"\"\"Check and install required Python packages.\"\"\"\nrequired_packages = [\n'flask',\n'werkzeug',\n'aiohttp',\n'psutil'\n]\n\nfor package in required_packages:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def run_tests", "output": "def run_tests(self, test_type: Optional[str] = None, parallel: bool = True) -> bool:\n\"\"\"Run tests and generate reports.\"\"\"\nlogger.info(\"Starting test execution...\")\nstart_time = datetime.now()\n\ntry:\n# Build pytest command\ncmd = [\n'pytest',\n'--cache-clear',", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _save_test_results", "output": "def _save_test_results(self, success: bool, duration: timedelta):\n\"\"\"Save test results to file.\"\"\"\nresults = {\n'timestamp': datetime.now().isoformat(),\n'success': success,\n'duration_seconds': duration.total_seconds(),\n'git_commit': self._get_git_commit()\n}\n\nresults_file = self.report_dir / 'test_results.json'", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_salt", "output": "def generate_salt() -> str:\n\"\"\"Generate a random salt.\"\"\"\nreturn base64.b64encode(secrets.token_bytes(16)).decode('utf-8')\n\ndef hash_password(password: str, salt: str) -> str:\n\"\"\"Hash password with salt using SHA-256.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def hash_password", "output": "def hash_password(password: str, salt: str) -> str:\n\"\"\"Hash password with salt using SHA-256.\"\"\"\ncombined = password.encode() + base64.b64decode(salt)\nreturn base64.b64encode(hashlib.sha256(combined).digest()).decode('utf-8')\n\ndef main():\n\"\"\"Set up dashboard authentication.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def main", "output": "def main():\n\"\"\"Set up dashboard authentication.\"\"\"\nbase_path = Path('/Volumes/Mac Mini External/MemoryCore/docs/dashboard')\nconfig_path = base_path / 'config/auth.json'\n\nif not config_path.parent.exists():\nconfig_path.parent.mkdir(parents=True)\n\n# Get credentials\nprint(\"Setting up dashboard authentication\")", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_cpu_metrics", "output": "def get_cpu_metrics(self) -> Dict:\n\"\"\"Get detailed CPU metrics.\"\"\"\ntry:\ncpu_freq = psutil.cpu_freq()\nreturn {\n'percent': psutil.cpu_percent(interval=1),\n'per_cpu': psutil.cpu_percent(interval=1, percpu=True),\n'count': psutil.cpu_count(),\n'count_logical': psutil.cpu_count(logical=True),\n'freq': {", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_memory_metrics", "output": "def get_memory_metrics(self) -> Dict:\n\"\"\"Get detailed memory metrics.\"\"\"\ntry:\nvm = psutil.virtual_memory()\nsm = psutil.swap_memory()\nreturn {\n'virtual': {\n'total_gb': round(vm.total / (1024**3), 2),\n'available_gb': round(vm.available / (1024**3), 2),\n'used_gb': round(vm.used / (1024**3), 2),", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_disk_metrics", "output": "def get_disk_metrics(self) -> Dict:\n\"\"\"Get detailed disk metrics.\"\"\"\ntry:\npath = '/Volumes/Mac Mini External'\nusage = psutil.disk_usage(path)\nio_counters = psutil.disk_io_counters()\n\nreturn {\n'usage': {\n'total_gb': round(usage.total / (1024**3), 2),", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_configuration", "output": "def test_configuration():\n\"\"\"Test configuration system.\"\"\"\nlogger.info(\"Testing configuration...\")\n\n# Check directory structure\ndirs_to_check = [\nservice_config.log_dir,\nservice_config.state_dir,\nservice_config.config_dir\n]", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_service_registry", "output": "def test_service_registry():\n\"\"\"Test service registry functionality.\"\"\"\nlogger.info(\"Testing service registry...\")\n\n# Register test service\nservice_registry.register_service('test_service', TestService)\n\n# Start service\nsuccess = service_registry.start_service('test_service')\nassert success, \"Failed to start test service\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_error_recovery", "output": "def test_error_recovery():\n\"\"\"Test error recovery mechanisms.\"\"\"\nlogger.info(\"Testing error recovery...\")\n\n# Start service\nservice_registry.start_service('test_service')\n\n# Wait for error (occurs every 10 iterations)\nlogger.info(\"Waiting for error condition...\")\ntime.sleep(12)  # Ensure we hit an error", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _generate_core_commands", "output": "def _generate_core_commands(self) -> List[str]:\n\"\"\"Generate commands for core infrastructure development\"\"\"\nreturn [\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/monitor.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/password_manager.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/docker_manager.py\"\n]\n\ndef _generate_ai_commands(self) -> List[str]:\n\"\"\"Generate commands for AI development\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _generate_ai_commands", "output": "def _generate_ai_commands(self) -> List[str]:\n\"\"\"Generate commands for AI development\"\"\"\nreturn [\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/ai/system_brain.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/ai/model_trainer.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/ai/pattern_analyzer.py\"\n]\n\ndef _generate_automation_commands(self) -> List[str]:\n\"\"\"Generate commands for automation development\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_all", "output": "def generate_all(self):\n\"\"\"Generate all documentation.\"\"\"\ntry:\nself.generate_architecture_docs()\nself.generate_api_docs()\nself.generate_deployment_docs()\nself.generate_troubleshooting_docs()\nself.generate_index()\n\nlogger.info(\"Documentation generation completed successfully\")", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_architecture_docs", "output": "def generate_architecture_docs(self):\n\"\"\"Generate system architecture documentation.\"\"\"\nlogger.info(\"Generating architecture documentation\")\n\ncontent = [\n\"# System Architecture\\n\",\n\"## Overview\\n\",\n\"The dashboard system consists of several key components working together \",\n\"to provide real-time monitoring and visualization capabilities.\\n\",\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_config", "output": "def load_config(self):\n\"\"\"Load authentication configuration.\"\"\"\ntry:\nif not self.config_path.exists():\nraise FileNotFoundError(\"Authentication config not found\")\n\nwith open(self.config_path) as f:\nself.config = json.load(f)\n\n# Validate config", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def hash_password", "output": "def hash_password(self, password: str) -> str:\n\"\"\"Hash password with stored salt.\"\"\"\nsalt = self.config['auth']['credentials']['salt']\ncombined = password.encode() + base64.b64decode(salt)\nreturn base64.b64encode(hashlib.sha256(combined).digest()).decode('utf-8')\n\ndef verify_password(self, password: str) -> bool:\n\"\"\"Verify password against stored hash.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _get_service_info", "output": "def _get_service_info(self, container) -> Dict:\n\"\"\"Get detailed service information\"\"\"\ntry:\nreturn {\n'id': container.id,\n'name': container.name,\n'status': container.status,\n'health': getattr(container, 'health', 'N/A'),\n'image': container.image.tags[0] if container.image.tags else 'none',\n'created': container.attrs['Created'],", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _needs_credential_rotation", "output": "def _needs_credential_rotation(self, service_name: str) -> bool:\n\"\"\"Check if service credentials need rotation\"\"\"\n# Implement credential rotation check logic\nreturn False\n\nasync def _rotate_service_credentials(self, service_name: str):\n\"\"\"Rotate service credentials\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _get_lastpass_entries", "output": "def _get_lastpass_entries(self) -> Dict:\n\"\"\"Get entries from LastPass\"\"\"\ntry:\n# Use lastpass-cli to get entries\nresult = subprocess.run(\n['lpass', 'export'],\ncapture_output=True,\ntext=True\n)\nreturn json.loads(result.stdout)", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _get_keychain_entries", "output": "def _get_keychain_entries(self) -> Dict:\n\"\"\"Get entries from macOS Keychain\"\"\"\ntry:\n# Use security command-line tool to get entries\nresult = subprocess.run(\n['security', 'dump-keychain'],\ncapture_output=True,\ntext=True\n)\n# Parse the output and return structured data", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_dir", "output": "def test_dir() -> Generator[Path, None, None]:\n\"\"\"Create a temporary test directory.\"\"\"\nwith tempfile.TemporaryDirectory() as temp_dir:\nyield Path(temp_dir)\n\n@pytest.fixture(scope='session')\ndef mock_metrics() -> Dict[str, Any]:\n\"\"\"Create mock system metrics.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def mock_metrics", "output": "def mock_metrics() -> Dict[str, Any]:\n\"\"\"Create mock system metrics.\"\"\"\nreturn {\n'cpu': {\n'percent': 50.0,\n'count': 8,\n'count_logical': 16,\n'per_cpu': [45.0, 55.0, 48.0, 52.0, 47.0, 53.0, 46.0, 54.0],\n'load_avg': [2.5, 2.7, 2.6]\n},", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def mock_system_info", "output": "def mock_system_info() -> Dict[str, Any]:\n\"\"\"Create mock system information.\"\"\"\nreturn {\n'os': 'Darwin',\n'version': '21.6.0',\n'arch': 'x86_64',\n'hostname': 'test-host',\n'uptime': 86400,  # 1 day\n'boot_time': 1625097600,  # 2021-07-01 00:00:00\n'users': [", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setUp", "output": "def setUp(self):\n\"\"\"Set up test environment.\"\"\"\n# Set up logging\nlogging.basicConfig(level=logging.DEBUG)\nself.logger = logging.getLogger('TestAutonomousSupervisor')\n\n# Create temp dir for test files\nself.test_dir = Path(tempfile.mkdtemp())\nself.test_service_dir = self.test_dir / 'services'\nself.test_service_dir.mkdir(parents=True)", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def tearDown", "output": "def tearDown(self):\n\"\"\"Clean up test environment.\"\"\"\n# Stop supervisor\nif self.supervisor:\nself.supervisor.stop()\ntime.sleep(0.1)  # Brief pause for cleanup\n\n# Remove test directory\nshutil.rmtree(self.test_dir)\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_initialization", "output": "def test_initialization(self):\n\"\"\"Test supervisor initialization.\"\"\"\nself.assertIsNotNone(self.supervisor)\nself.assertEqual(self.supervisor.service_dir, self.test_service_dir)\nself.assertFalse(self.supervisor.running)\nself.assertTrue(self.supervisor.task_queue.empty())\n\ndef test_task_queue_priority(self):\n\"\"\"Test task queue prioritization.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_health_check_initialization", "output": "def test_health_check_initialization(test_dir: Path):\n\"\"\"Test health check initialization.\"\"\"\nhealth_check = HealthCheck(test_dir)\nassert health_check.base_path == test_dir\nassert (test_dir / 'health').exists()\n\ndef test_check_system_resources(mock_health_check, mock_metrics):\n\"\"\"Test system resource checking.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_check_system_resources", "output": "def test_check_system_resources(mock_health_check, mock_metrics):\n\"\"\"Test system resource checking.\"\"\"\nresources = mock_health_check.check_system_resources()\nassert resources['memory']['healthy'] is True\nassert resources['cpu']['healthy'] is True\nassert resources['disk']['healthy'] is True\n\ndef test_check_component_health(mock_health_check):\n\"\"\"Test component health checking.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_check_component_health", "output": "def test_check_component_health(mock_health_check):\n\"\"\"Test component health checking.\"\"\"\ndef mock_check():\nreturn {'status': 'healthy', 'uptime': 3600}\n\nresult = mock_health_check.check_component_health('test_component', mock_check)\nassert result['healthy'] is True\nassert result['error'] is None\nassert 'response_time' in result\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_chatgpt_export_empty", "output": "def test_chatgpt_export_empty(self):\n\"\"\"Test that ChatGPT export handles empty state properly\"\"\"\nexporter = ChatGPTExporter(self.base_path)\nresult = exporter.export_conversations()\nself.assertEqual(result, [])\n\ndef test_save_and_export_conversation(self):\n\"\"\"Test saving and then exporting a conversation\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_search_exact_match", "output": "def test_search_exact_match(self):\n\"\"\"Test search with exact term matches.\"\"\"\nresults = self.search.search(\"semantic search\")\nself.assertGreater(len(results), 0)\nself.assertEqual(results[0].source_id, 'test1')\nself.assertGreater(results[0].score, 0.7)  # High confidence for exact match\n\ndef test_search_semantic_similarity(self):\n\"\"\"Test search with semantically similar terms.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, name: str, test_mode: bool = False):", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _run", "output": "def _run(self):\n\"\"\"Test run implementation.\"\"\"\nself.run_count += 1\nif self.should_fail:\nraise Exception(\"Test failure\")\nwhile self.running and not self.test_mode:\ntime.sleep(0.1)\n\nclass TestBaseService(unittest.TestCase):\n\"\"\"Test cases for BaseService.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setUp", "output": "def setUp(self):\n\"\"\"Set up test environment.\"\"\"\n# Create temp directory for test files\nself.test_dir = tempfile.mkdtemp()\nself.addCleanup(shutil.rmtree, self.test_dir)\n\n# Configure service paths\nservice_config.base_path = Path(self.test_dir)\nservice_config.create_dirs()\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_visualization_initialization", "output": "def test_visualization_initialization(self, test_dir):\n\"\"\"Test visualization system initialization.\"\"\"\nviz = MemoryVisualizationDashboard(test_dir)\nassert viz.base_path == test_dir\nassert (test_dir / 'visualizations').exists()\n\ndef test_memory_cluster_visualization(self, test_dir):\n\"\"\"Test memory cluster visualization generation.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_memory_cluster_visualization", "output": "def test_memory_cluster_visualization(self, test_dir):\n\"\"\"Test memory cluster visualization generation.\"\"\"\nviz = MemoryVisualizationDashboard(test_dir)\n\n# Sample cluster data\nclusters = {\n'cluster1': {\n'topic': 'Performance',\n'size': 5,\n'coherence': 0.8,", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_relationship_visualization", "output": "def test_relationship_visualization(self, test_dir):\n\"\"\"Test memory relationship visualization.\"\"\"\nviz = MemoryVisualizationDashboard(test_dir)\n\n# Sample relationship data\nrelationships = [\n{'source': 'mem1', 'target': 'mem2', 'strength': 0.8},\n{'source': 'mem2', 'target': 'mem3', 'strength': 0.6}\n]\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _setup_logging", "output": "def _setup_logging(self):\n\"\"\"Set up logging configuration.\"\"\"\nhandler = logging.StreamHandler()\nformatter = logging.Formatter(\n'%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nhandler.setFormatter(formatter)\nself.logger.addHandler(handler)\nself.logger.setLevel(logging.INFO)\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def analyze_file", "output": "def analyze_file(self, file_path: str) -> List[Dict[str, Any]]:\n\"\"\"Analyze a Python file for potential issues.\"\"\"\nself.issues = []\nself.current_file = file_path\n\ntry:\nwith open(file_path, 'r') as f:\ncontent = f.read()\n\n# Parse the content into an AST", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def check_indentation", "output": "def check_indentation(self, file_path: Path) -> List[Dict]:\n\"\"\"Check for indentation issues.\"\"\"\nissues = []\nwith open(file_path) as f:\nlines = f.readlines()\ncurrent_indent = 0\nfor i, line in enumerate(lines, 1):\nif line.strip() and (not line.strip().startswith('#')):\nleading_spaces = len(line) - len(line.lstrip())\nif leading_spaces % 4 != 0:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def check_try_except", "output": "def check_try_except(self, file_path: Path) -> List[Dict]:\n\"\"\"Check for incomplete try/except blocks.\"\"\"\nissues = []\nwith open(file_path) as f:\ncontent = f.read()\ntry:\ntree = ast.parse(content)\nfor node in ast.walk(tree):\nif isinstance(node, ast.Try):\nif not node.handlers:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _count_tokens", "output": "def _count_tokens(self, text: str) -> int:\n\"\"\"Count tokens in text.\"\"\"\nreturn len(self.encoding.encode(text))\n\ndef _format_conversation(self, raw_conversation: Dict) -> Dict:\n\"\"\"Format a raw conversation into our memory format.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _format_conversation", "output": "def _format_conversation(self, raw_conversation: Dict) -> Dict:\n\"\"\"Format a raw conversation into our memory format.\"\"\"\ntry:\nmessages = []\nfor msg in raw_conversation.get('messages', []):\nmessages.append({\n'role': msg.get('role', 'unknown'),\n'content': msg.get('content', ''),\n'tokens': self._count_tokens(msg.get('content', '')),\n'metadata': {", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_memory_usage", "output": "def test_memory_usage(mock_metrics_collector):\n\"\"\"Test memory usage during operation.\"\"\"\ninitial_memory = psutil.Process().memory_info().rss\n\n# Perform memory-intensive operations\ndata = []\nfor i in range(10000):\ndata.append({\n\"name\": \"test_metric\",\n\"value\": i,", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_metrics_collector_initialization", "output": "def test_metrics_collector_initialization(mock_metrics_collector):\n\"\"\"Test metrics collector initialization.\"\"\"\nassert mock_metrics_collector is not None\nassert hasattr(mock_metrics_collector, 'collect_metric')\nassert hasattr(mock_metrics_collector, 'get_metric')\n\ndef test_metric_collection(mock_metrics_collector):\n\"\"\"Test basic metric collection.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_metric_collection", "output": "def test_metric_collection(mock_metrics_collector):\n\"\"\"Test basic metric collection.\"\"\"\n# Collect test metrics\nmock_metrics_collector.collect_metric(\"cpu_usage\", 45.2)\nmock_metrics_collector.collect_metric(\"memory_usage\", 75.5)\n\n# Verify metrics were collected\ncpu_metrics = mock_metrics_collector.get_metric(\"cpu_usage\")\nmemory_metrics = mock_metrics_collector.get_metric(\"memory_usage\")\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_metric_time_range", "output": "def test_metric_time_range(mock_metrics_collector):\n\"\"\"Test metric collection with time ranges.\"\"\"\nstart_time = datetime.now()\n\n# Collect metrics at different times\nmock_metrics_collector.collect_metric(\"cpu_usage\", 45.2, start_time.timestamp())\nmock_metrics_collector.collect_metric(\"cpu_usage\", 48.5, (start_time + timedelta(minutes=1)).timestamp())\nmock_metrics_collector.collect_metric(\"cpu_usage\", 42.1, (start_time + timedelta(minutes=2)).timestamp())\n\n# Query with time range", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _extract_date_from_filename", "output": "def _extract_date_from_filename(self, filename: str) -> Optional[str]:\n\"\"\"Extract date from filename using common patterns.\"\"\"\ndate_patterns = [\nr'(\\d{4}-\\d{2}-\\d{2})',\nr'(\\d{8})',\nr'(\\d{4}\\d{2}\\d{2})',\n]\n\nfor pattern in date_patterns:\nmatch = re.search(pattern, filename)", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _extract_context", "output": "def _extract_context(self, text: str, match_pos: int, context_size: int = 200) -> str:\n\"\"\"Extract context around a match position.\"\"\"\nstart = max(0, match_pos - context_size)\nend = min(len(text), match_pos + context_size)\nreturn text[start:end].strip()\n\ndef _identify_components(self, text: str) -> List[Tuple[str, str]]:\n\"\"\"Identify components and their types from text.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def create_dirs", "output": "def create_dirs(self):\n\"\"\"Create required directories.\"\"\"\nself.config_dir.mkdir(parents=True, exist_ok=True)\nself.data_dir.mkdir(parents=True, exist_ok=True)\nself.log_dir.mkdir(parents=True, exist_ok=True)\nself.state_dir.mkdir(parents=True, exist_ok=True)\n\ndef _load_config(self):\n\"\"\"Load configuration or create default.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _load_config", "output": "def _load_config(self):\n\"\"\"Load configuration or create default.\"\"\"\nconfig_file = self.config_dir / 'services.json'\n\nif config_file.exists():\nwith open(config_file) as f:\nreturn json.load(f)\n\n# Default configuration\ndefault_config = {", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, num_workers: int=4, cache_ttl: int=300):", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _hash_data", "output": "def _hash_data(self, data: Any) -> str:\n\"\"\"Generate a consistent hash for data structures.\"\"\"\nif isinstance(data, (dict, list)):\nreturn hashlib.md5(json.dumps(data, sort_keys=True).encode()).hexdigest()\nreturn hashlib.md5(str(data).encode()).hexdigest()\n\ndef _is_cached(self, data_hash: str) -> bool:\n\"\"\"Check if data is cached and not expired.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_metrics", "output": "def generate_metrics():\n\"\"\"Generate current system metrics.\"\"\"\ntry:\nmem = psutil.virtual_memory()\ndisk = psutil.disk_usage('/')\nnet_io = psutil.net_io_counters(pernic=True)\nreturn {\n'cpu_percent': psutil.cpu_percent(interval=1),\n'memory_percent': mem.percent,\n'disk_percent': disk.percent,", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def send_metrics", "output": "def send_metrics():\n\"\"\"SSE event generator.\"\"\"\ntry:\nwhile True:\nmetrics = generate_metrics()\nyield f\"data: {json.dumps(metrics)}\\n\\n\"\nsleep(2)  # Update every 2 seconds\nexcept GeneratorExit:\npass\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def healthz", "output": "def healthz():\n\"\"\"Health check endpoint.\"\"\"\ntry:\n# Basic system checks\npsutil.cpu_percent()\npsutil.virtual_memory()\npsutil.disk_usage('/')\nreturn jsonify({\n'status': 'healthy',\n'timestamp': datetime.now().isoformat()", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _load_config", "output": "def _load_config(self) -> Dict[str, Any]:\n\"\"\"Load deployment configuration.\"\"\"\nconfig = {\n'production': {\n'host': os.getenv('DEPLOY_HOST', 'localhost'),\n'port': int(os.getenv('DEPLOY_PORT', 8000)),\n'api_key': os.getenv('DEPLOY_KEY'),\n'backup_retention_days': 7\n},\n'staging': {", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def create_backup", "output": "def create_backup(self, env: str) -> str:\n\"\"\"Create backup of current deployment.\"\"\"\nlogger.info(f\"Creating backup for {env} environment\")\n\ntimestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\nbackup_path = self.backup_dir / f\"backup_{env}_{timestamp}.tar.gz\"\n\ntry:\n# Create backup archive\nsubprocess.run([", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_system_status", "output": "def get_system_status() -> Dict:\n\"\"\"Get comprehensive system status including metrics and state.\"\"\"\ntry:\nmetrics = system_metrics.get_all_metrics()\nstatus = 'healthy'\nissues = []\nif metrics['cpu'].get('percent', 0) > 80:\nissues.append(f\"High CPU usage: {metrics['cpu']['percent']}%\")\nstatus = 'warning'\nif metrics['memory'].get('virtual', {}).get('percent', 0) > 80:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_memorycore_stats", "output": "def get_memorycore_stats():\n\"\"\"Get MemoryCore specific statistics.\"\"\"\nbase_path = Path('/Volumes/Mac Mini External/MemoryCore')\nstats = {'total_files': 0, 'total_size': 0, 'categories': {}, 'recent_changes': []}\nfor category in ['docs', 'scripts', 'data', 'models']:\ncat_path = base_path / category\nif cat_path.exists():\nfiles = list(cat_path.rglob('*'))\nfile_count = len([f for f in files if f.is_file()])\ntotal_size = sum((f.stat().st_size for f in files if f.is_file()))", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_recent_events", "output": "def get_recent_events():\n\"\"\"Get most recent events from timeline data and other sources.\"\"\"\nevents = []\nenriched_path = Path('/Volumes/Mac Mini External/MemoryCore/docs/dashboard/data/timeline/timeline_enriched.json')\nraw_path = Path('/Volumes/Mac Mini External/MemoryCore/docs/dashboard/data/timeline/timeline_data.json')\ntimeline_path = enriched_path if enriched_path.exists() else raw_path\nif timeline_path.exists():\ntry:\nwith open(timeline_path) as f:\ndata = json.load(f)", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def format_html_doc", "output": "def format_html_doc(content: str) -> str:\n\"\"\"Wrap content in a complete HTML document structure.\"\"\"\nreturn f\"\"\"<!DOCTYPE html>", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_html_content", "output": "def generate_html_content(metrics: Dict, events: List, timeline_data: Optional[Dict], narrative_data: Optional[Dict]) -> str:\n\"\"\"Generate the main HTML content.\"\"\"\ntry:\n# Build HTML content piece by piece\nparts = []\n\n# Add header\nparts.append(\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup_logging", "output": "def setup_logging():\n\"\"\"Configure logging with rotation and structured format.\"\"\"\n# Create log directory if it doesn't exist\nLOG_DIR.mkdir(parents=True, exist_ok=True)\n\n# Create rotating file handler for debugging\nfile_handler = RotatingFileHandler(\nLOG_FILE,\nmaxBytes=MAX_BYTES,\nbackupCount=BACKUP_COUNT", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def log_with_context", "output": "def log_with_context(logger, level, message, **context):\n\"\"\"\nLog a message with additional context.\n\nArgs:\nlogger: Logger instance\nlevel: Logging level (e.g., INFO, ERROR)\nmessage: Log message\n**context: Additional context as key-value pairs\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get", "output": "def get(self, key: str) -> Optional[Any]:\n\"\"\"\nGet a value from cache if it exists and hasn't expired.\n\nArgs:\nkey: Cache key\n\nReturns:\nCached value if valid, None otherwise\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def set", "output": "def set(self, key: str, value: Any) -> None:\n\"\"\"\nSet a value in cache with current timestamp.\n\nArgs:\nkey: Cache key\nvalue: Value to cache\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _send_request", "output": "def _send_request(self, payload: Dict[str, Any]) -> requests.Response:\n\"\"\"Send request to Pushover API with retry logic\"\"\"\nfor attempt in range(self.retry_attempts):\ntry:\nresponse = requests.post(self.PUSHOVER_API_URL, data=payload)\nresponse.raise_for_status()\nreturn response\nexcept requests.RequestException as e:\nlogger.warning(f'Attempt {attempt + 1} failed: {str(e)}')\nif attempt < self.retry_attempts - 1:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def speak_message", "output": "def speak_message(self, message: str, voice: str='Daniel') -> None:\n\"\"\"\nSpeak the message using macOS text-to-speech\n\nArgs:\nmessage: The message to speak\nvoice: The voice to use (default: Daniel)\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def signal_handler", "output": "def signal_handler(signum, frame):\n\"\"\"Handle signals gracefully.\"\"\"\nlocal_logger = logging.getLogger('Launcher')\nif flask_process:\nlocal_logger.info(\"Stopping dashboard...\")\nflask_process.terminate()\ntry:\nflask_process.wait(timeout=5)\nexcept subprocess.TimeoutExpired:\nflask_process.kill()", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup_logging", "output": "def setup_logging():\n\"\"\"Set up logging.\"\"\"\nlog_dir = Path(__file__).parent / 'logs'\nlog_dir.mkdir(exist_ok=True, parents=True)\n\nlogging.basicConfig(\nlevel=logging.INFO,\nformat='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\nhandlers=[\nlogging.FileHandler(log_dir / 'dashboard.log'),", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def check_dependencies", "output": "def check_dependencies():\n\"\"\"Check and install required Python packages.\"\"\"\nrequired_packages = [\n'flask',\n'werkzeug',\n'aiohttp',\n'psutil'\n]\n\nfor package in required_packages:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def run_tests", "output": "def run_tests(self, test_type: Optional[str] = None, parallel: bool = True) -> bool:\n\"\"\"Run tests and generate reports.\"\"\"\nlogger.info(\"Starting test execution...\")\nstart_time = datetime.now()\n\ntry:\n# Build pytest command\ncmd = [\n'pytest',\n'--cache-clear',", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _save_test_results", "output": "def _save_test_results(self, success: bool, duration: timedelta):\n\"\"\"Save test results to file.\"\"\"\nresults = {\n'timestamp': datetime.now().isoformat(),\n'success': success,\n'duration_seconds': duration.total_seconds(),\n'git_commit': self._get_git_commit()\n}\n\nresults_file = self.report_dir / 'test_results.json'", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_salt", "output": "def generate_salt() -> str:\n\"\"\"Generate a random salt.\"\"\"\nreturn base64.b64encode(secrets.token_bytes(16)).decode('utf-8')\n\ndef hash_password(password: str, salt: str) -> str:\n\"\"\"Hash password with salt using SHA-256.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def hash_password", "output": "def hash_password(password: str, salt: str) -> str:\n\"\"\"Hash password with salt using SHA-256.\"\"\"\ncombined = password.encode() + base64.b64decode(salt)\nreturn base64.b64encode(hashlib.sha256(combined).digest()).decode('utf-8')\n\ndef main():\n\"\"\"Set up dashboard authentication.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def main", "output": "def main():\n\"\"\"Set up dashboard authentication.\"\"\"\nbase_path = Path('/Volumes/Mac Mini External/MemoryCore/docs/dashboard')\nconfig_path = base_path / 'config/auth.json'\n\nif not config_path.parent.exists():\nconfig_path.parent.mkdir(parents=True)\n\n# Get credentials\nprint(\"Setting up dashboard authentication\")", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_cpu_metrics", "output": "def get_cpu_metrics(self) -> Dict:\n\"\"\"Get detailed CPU metrics.\"\"\"\ntry:\ncpu_freq = psutil.cpu_freq()\nreturn {\n'percent': psutil.cpu_percent(interval=1),\n'per_cpu': psutil.cpu_percent(interval=1, percpu=True),\n'count': psutil.cpu_count(),\n'count_logical': psutil.cpu_count(logical=True),\n'freq': {", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_memory_metrics", "output": "def get_memory_metrics(self) -> Dict:\n\"\"\"Get detailed memory metrics.\"\"\"\ntry:\nvm = psutil.virtual_memory()\nsm = psutil.swap_memory()\nreturn {\n'virtual': {\n'total_gb': round(vm.total / (1024**3), 2),\n'available_gb': round(vm.available / (1024**3), 2),\n'used_gb': round(vm.used / (1024**3), 2),", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_disk_metrics", "output": "def get_disk_metrics(self) -> Dict:\n\"\"\"Get detailed disk metrics.\"\"\"\ntry:\npath = '/Volumes/Mac Mini External'\nusage = psutil.disk_usage(path)\nio_counters = psutil.disk_io_counters()\n\nreturn {\n'usage': {\n'total_gb': round(usage.total / (1024**3), 2),", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_configuration", "output": "def test_configuration():\n\"\"\"Test configuration system.\"\"\"\nlogger.info(\"Testing configuration...\")\n\n# Check directory structure\ndirs_to_check = [\nservice_config.log_dir,\nservice_config.state_dir,\nservice_config.config_dir\n]", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_service_registry", "output": "def test_service_registry():\n\"\"\"Test service registry functionality.\"\"\"\nlogger.info(\"Testing service registry...\")\n\n# Register test service\nservice_registry.register_service('test_service', TestService)\n\n# Start service\nsuccess = service_registry.start_service('test_service')\nassert success, \"Failed to start test service\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_error_recovery", "output": "def test_error_recovery():\n\"\"\"Test error recovery mechanisms.\"\"\"\nlogger.info(\"Testing error recovery...\")\n\n# Start service\nservice_registry.start_service('test_service')\n\n# Wait for error (occurs every 10 iterations)\nlogger.info(\"Waiting for error condition...\")\ntime.sleep(12)  # Ensure we hit an error", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _generate_core_commands", "output": "def _generate_core_commands(self) -> List[str]:\n\"\"\"Generate commands for core infrastructure development\"\"\"\nreturn [\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/monitor.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/password_manager.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/docker_manager.py\"\n]\n\ndef _generate_ai_commands(self) -> List[str]:\n\"\"\"Generate commands for AI development\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _generate_ai_commands", "output": "def _generate_ai_commands(self) -> List[str]:\n\"\"\"Generate commands for AI development\"\"\"\nreturn [\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/ai/system_brain.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/ai/model_trainer.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/ai/pattern_analyzer.py\"\n]\n\ndef _generate_automation_commands(self) -> List[str]:\n\"\"\"Generate commands for automation development\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_all", "output": "def generate_all(self):\n\"\"\"Generate all documentation.\"\"\"\ntry:\nself.generate_architecture_docs()\nself.generate_api_docs()\nself.generate_deployment_docs()\nself.generate_troubleshooting_docs()\nself.generate_index()\n\nlogger.info(\"Documentation generation completed successfully\")", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_architecture_docs", "output": "def generate_architecture_docs(self):\n\"\"\"Generate system architecture documentation.\"\"\"\nlogger.info(\"Generating architecture documentation\")\n\ncontent = [\n\"# System Architecture\\n\",\n\"## Overview\\n\",\n\"The dashboard system consists of several key components working together \",\n\"to provide real-time monitoring and visualization capabilities.\\n\",\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _get_service_info", "output": "def _get_service_info(self, container) -> Dict:\n\"\"\"Get detailed service information\"\"\"\ntry:\nreturn {\n'id': container.id,\n'name': container.name,\n'status': container.status,\n'health': getattr(container, 'health', 'N/A'),\n'image': container.image.tags[0] if container.image.tags else 'none',\n'created': container.attrs['Created'],", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _needs_credential_rotation", "output": "def _needs_credential_rotation(self, service_name: str) -> bool:\n\"\"\"Check if service credentials need rotation\"\"\"\n# Implement credential rotation check logic\nreturn False\n\nasync def _rotate_service_credentials(self, service_name: str):\n\"\"\"Rotate service credentials\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _get_lastpass_entries", "output": "def _get_lastpass_entries(self) -> Dict:\n\"\"\"Get entries from LastPass\"\"\"\ntry:\n# Use lastpass-cli to get entries\nresult = subprocess.run(\n['lpass', 'export'],\ncapture_output=True,\ntext=True\n)\nreturn json.loads(result.stdout)", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _get_keychain_entries", "output": "def _get_keychain_entries(self) -> Dict:\n\"\"\"Get entries from macOS Keychain\"\"\"\ntry:\n# Use security command-line tool to get entries\nresult = subprocess.run(\n['security', 'dump-keychain'],\ncapture_output=True,\ntext=True\n)\n# Parse the output and return structured data", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_dir", "output": "def test_dir() -> Generator[Path, None, None]:\n\"\"\"Create a temporary test directory.\"\"\"\nwith tempfile.TemporaryDirectory() as temp_dir:\nyield Path(temp_dir)\n\n@pytest.fixture(scope='session')\ndef mock_metrics() -> Dict[str, Any]:\n\"\"\"Create mock system metrics.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def mock_metrics", "output": "def mock_metrics() -> Dict[str, Any]:\n\"\"\"Create mock system metrics.\"\"\"\nreturn {\n'cpu': {\n'percent': 50.0,\n'count': 8,\n'count_logical': 16,\n'per_cpu': [45.0, 55.0, 48.0, 52.0, 47.0, 53.0, 46.0, 54.0],\n'load_avg': [2.5, 2.7, 2.6]\n},", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def mock_system_info", "output": "def mock_system_info() -> Dict[str, Any]:\n\"\"\"Create mock system information.\"\"\"\nreturn {\n'os': 'Darwin',\n'version': '21.6.0',\n'arch': 'x86_64',\n'hostname': 'test-host',\n'uptime': 86400,  # 1 day\n'boot_time': 1625097600,  # 2021-07-01 00:00:00\n'users': [", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setUp", "output": "def setUp(self):\n\"\"\"Set up test environment.\"\"\"\n# Set up logging\nlogging.basicConfig(level=logging.DEBUG)\nself.logger = logging.getLogger('TestAutonomousSupervisor')\n\n# Create temp dir for test files\nself.test_dir = Path(tempfile.mkdtemp())\nself.test_service_dir = self.test_dir / 'services'\nself.test_service_dir.mkdir(parents=True)", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def tearDown", "output": "def tearDown(self):\n\"\"\"Clean up test environment.\"\"\"\n# Stop supervisor\nif self.supervisor:\nself.supervisor.stop()\ntime.sleep(0.1)  # Brief pause for cleanup\n\n# Remove test directory\nshutil.rmtree(self.test_dir)\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_initialization", "output": "def test_initialization(self):\n\"\"\"Test supervisor initialization.\"\"\"\nself.assertIsNotNone(self.supervisor)\nself.assertEqual(self.supervisor.service_dir, self.test_service_dir)\nself.assertFalse(self.supervisor.running)\nself.assertTrue(self.supervisor.task_queue.empty())\n\ndef test_task_queue_priority(self):\n\"\"\"Test task queue prioritization.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_health_check_initialization", "output": "def test_health_check_initialization(test_dir: Path):\n\"\"\"Test health check initialization.\"\"\"\nhealth_check = HealthCheck(test_dir)\nassert health_check.base_path == test_dir\nassert (test_dir / 'health').exists()\n\ndef test_check_system_resources(mock_health_check, mock_metrics):\n\"\"\"Test system resource checking.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_check_system_resources", "output": "def test_check_system_resources(mock_health_check, mock_metrics):\n\"\"\"Test system resource checking.\"\"\"\nresources = mock_health_check.check_system_resources()\nassert resources['memory']['healthy'] is True\nassert resources['cpu']['healthy'] is True\nassert resources['disk']['healthy'] is True\n\ndef test_check_component_health(mock_health_check):\n\"\"\"Test component health checking.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_check_component_health", "output": "def test_check_component_health(mock_health_check):\n\"\"\"Test component health checking.\"\"\"\ndef mock_check():\nreturn {'status': 'healthy', 'uptime': 3600}\n\nresult = mock_health_check.check_component_health('test_component', mock_check)\nassert result['healthy'] is True\nassert result['error'] is None\nassert 'response_time' in result\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_chatgpt_export_empty", "output": "def test_chatgpt_export_empty(self):\n\"\"\"Test that ChatGPT export handles empty state properly\"\"\"\nexporter = ChatGPTExporter(self.base_path)\nresult = exporter.export_conversations()\nself.assertEqual(result, [])\n\ndef test_save_and_export_conversation(self):\n\"\"\"Test saving and then exporting a conversation\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_search_exact_match", "output": "def test_search_exact_match(self):\n\"\"\"Test search with exact term matches.\"\"\"\nresults = self.search.search(\"semantic search\")\nself.assertGreater(len(results), 0)\nself.assertEqual(results[0].source_id, 'test1')\nself.assertGreater(results[0].score, 0.7)  # High confidence for exact match\n\ndef test_search_semantic_similarity(self):\n\"\"\"Test search with semantically similar terms.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, name: str, test_mode: bool = False):", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _run", "output": "def _run(self):\n\"\"\"Test run implementation.\"\"\"\nself.run_count += 1\nif self.should_fail:\nraise Exception(\"Test failure\")\nwhile self.running and not self.test_mode:\ntime.sleep(0.1)\n\nclass TestBaseService(unittest.TestCase):\n\"\"\"Test cases for BaseService.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setUp", "output": "def setUp(self):\n\"\"\"Set up test environment.\"\"\"\n# Create temp directory for test files\nself.test_dir = tempfile.mkdtemp()\nself.addCleanup(shutil.rmtree, self.test_dir)\n\n# Configure service paths\nservice_config.base_path = Path(self.test_dir)\nservice_config.create_dirs()\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_visualization_initialization", "output": "def test_visualization_initialization(self, test_dir):\n\"\"\"Test visualization system initialization.\"\"\"\nviz = MemoryVisualizationDashboard(test_dir)\nassert viz.base_path == test_dir\nassert (test_dir / 'visualizations').exists()\n\ndef test_memory_cluster_visualization(self, test_dir):\n\"\"\"Test memory cluster visualization generation.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_memory_cluster_visualization", "output": "def test_memory_cluster_visualization(self, test_dir):\n\"\"\"Test memory cluster visualization generation.\"\"\"\nviz = MemoryVisualizationDashboard(test_dir)\n\n# Sample cluster data\nclusters = {\n'cluster1': {\n'topic': 'Performance',\n'size': 5,\n'coherence': 0.8,", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_relationship_visualization", "output": "def test_relationship_visualization(self, test_dir):\n\"\"\"Test memory relationship visualization.\"\"\"\nviz = MemoryVisualizationDashboard(test_dir)\n\n# Sample relationship data\nrelationships = [\n{'source': 'mem1', 'target': 'mem2', 'strength': 0.8},\n{'source': 'mem2', 'target': 'mem3', 'strength': 0.6}\n]\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _setup_logging", "output": "def _setup_logging(self):\n\"\"\"Set up logging configuration.\"\"\"\nhandler = logging.StreamHandler()\nformatter = logging.Formatter(\n'%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nhandler.setFormatter(formatter)\nself.logger.addHandler(handler)\nself.logger.setLevel(logging.INFO)\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def analyze_file", "output": "def analyze_file(self, file_path: str) -> List[Dict[str, Any]]:\n\"\"\"Analyze a Python file for potential issues.\"\"\"\nself.issues = []\nself.current_file = file_path\n\ntry:\nwith open(file_path, 'r') as f:\ncontent = f.read()\n\n# Parse the content into an AST", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def check_indentation", "output": "def check_indentation(self, file_path: Path) -> List[Dict]:\n\"\"\"Check for indentation issues.\"\"\"\nissues = []\nwith open(file_path) as f:\nlines = f.readlines()\ncurrent_indent = 0\nfor i, line in enumerate(lines, 1):\nif line.strip() and (not line.strip().startswith('#')):\nleading_spaces = len(line) - len(line.lstrip())\nif leading_spaces % 4 != 0:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def check_try_except", "output": "def check_try_except(self, file_path: Path) -> List[Dict]:\n\"\"\"Check for incomplete try/except blocks.\"\"\"\nissues = []\nwith open(file_path) as f:\ncontent = f.read()\ntry:\ntree = ast.parse(content)\nfor node in ast.walk(tree):\nif isinstance(node, ast.Try):\nif not node.handlers:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _count_tokens", "output": "def _count_tokens(self, text: str) -> int:\n\"\"\"Count tokens in text.\"\"\"\nreturn len(self.encoding.encode(text))\n\ndef _format_conversation(self, raw_conversation: Dict) -> Dict:\n\"\"\"Format a raw conversation into our memory format.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _format_conversation", "output": "def _format_conversation(self, raw_conversation: Dict) -> Dict:\n\"\"\"Format a raw conversation into our memory format.\"\"\"\ntry:\nmessages = []\nfor msg in raw_conversation.get('messages', []):\nmessages.append({\n'role': msg.get('role', 'unknown'),\n'content': msg.get('content', ''),\n'tokens': self._count_tokens(msg.get('content', '')),\n'metadata': {", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_memory_usage", "output": "def test_memory_usage(mock_metrics_collector):\n\"\"\"Test memory usage during operation.\"\"\"\ninitial_memory = psutil.Process().memory_info().rss\n\n# Perform memory-intensive operations\ndata = []\nfor i in range(10000):\ndata.append({\n\"name\": \"test_metric\",\n\"value\": i,", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_metrics_collector_initialization", "output": "def test_metrics_collector_initialization(mock_metrics_collector):\n\"\"\"Test metrics collector initialization.\"\"\"\nassert mock_metrics_collector is not None\nassert hasattr(mock_metrics_collector, 'collect_metric')\nassert hasattr(mock_metrics_collector, 'get_metric')\n\ndef test_metric_collection(mock_metrics_collector):\n\"\"\"Test basic metric collection.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_metric_collection", "output": "def test_metric_collection(mock_metrics_collector):\n\"\"\"Test basic metric collection.\"\"\"\n# Collect test metrics\nmock_metrics_collector.collect_metric(\"cpu_usage\", 45.2)\nmock_metrics_collector.collect_metric(\"memory_usage\", 75.5)\n\n# Verify metrics were collected\ncpu_metrics = mock_metrics_collector.get_metric(\"cpu_usage\")\nmemory_metrics = mock_metrics_collector.get_metric(\"memory_usage\")\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_metric_time_range", "output": "def test_metric_time_range(mock_metrics_collector):\n\"\"\"Test metric collection with time ranges.\"\"\"\nstart_time = datetime.now()\n\n# Collect metrics at different times\nmock_metrics_collector.collect_metric(\"cpu_usage\", 45.2, start_time.timestamp())\nmock_metrics_collector.collect_metric(\"cpu_usage\", 48.5, (start_time + timedelta(minutes=1)).timestamp())\nmock_metrics_collector.collect_metric(\"cpu_usage\", 42.1, (start_time + timedelta(minutes=2)).timestamp())\n\n# Query with time range", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup", "output": "def setup(self):\n\"\"\"Initialize the Docker management system\"\"\"\ntry:\n# Create necessary directories\nfor path in [self.config_path, self.data_path, self.log_path, self.state_path]:\npath.mkdir(parents=True, exist_ok=True)\n\n# Setup logging\nlog_file = self.log_path / \"docker_manager.log\"\nlogging.basicConfig(", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_config", "output": "def load_config(self) -> Dict:\n\"\"\"Load or create configuration\"\"\"\ntry:\nconfig_file = self.config_path / \"docker_config.yaml\"\nif not config_file.exists():\n# Create default configuration\nconfig = {\n\"registries\": {\n\"docker.io\": {\n\"username\": \"memorycore\",", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup", "output": "def setup(self):\n\"\"\"Initialize the component\"\"\"\nif not self.initialized:\n# Create state file\nstate = {\n\"component\": \"Docker Management System\",\n\"status\": \"initialized\",\n\"timestamp\": datetime.now().isoformat()\n}\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def run", "output": "def run(self):\n\"\"\"Main execution loop\"\"\"\nif self.initialized:\nprint(f\"Running Docker Management System\")\nreturn True\nreturn False\n\ndef main():\ncomponent = DockerManager()\nsuccess = component.run()", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup", "output": "def setup(self):\n\"\"\"Initialize the component\"\"\"\nif not self.initialized:\n# Create state file\nstate = {\n\"component\": \"CalCareers Integration System\",\n\"status\": \"initialized\",\n\"timestamp\": datetime.now().isoformat()\n}\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def run", "output": "def run(self):\n\"\"\"Main execution loop\"\"\"\nif self.initialized:\nprint(f\"Running CalCareers Integration System\")\nreturn True\nreturn False\n\ndef main():\ncomponent = CalCareers()\nsuccess = component.run()", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _get_phase_components", "output": "def _get_phase_components(self, phase: int) -> List[str]:\n\"\"\"Get components for a phase\"\"\"\ncomponents = {\n# Core Infrastructure (1-5)\n1: [\"core/security/password_manager.py\"],\n2: [\"services/docker/manager.py\"],\n3: [\"core/monitoring/monitor.py\"],\n4: [\"core/automation/controller.py\"],\n5: [\"core/integration/service_manager.py\"],\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup", "output": "def setup(self):\n\"\"\"Initialize the component\"\"\"\nif not self.initialized:\n# Create state file\nstate = {\n\"component\": \"Consciousness Management System\",\n\"status\": \"initialized\",\n\"timestamp\": datetime.now().isoformat()\n}\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def run", "output": "def run(self):\n\"\"\"Main execution loop\"\"\"\nif self.initialized:\nprint(f\"Running Consciousness Management System\")\nreturn True\nreturn False\n\ndef main():\ncomponent = ConsciousnessSystem()\nsuccess = component.run()", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup", "output": "def setup(self):\n\"\"\"Initialize the component\"\"\"\nif not self.initialized:\n# Create state file\nstate = {\n\"component\": \"Decision Making Engine\",\n\"status\": \"initialized\",\n\"timestamp\": datetime.now().isoformat()\n}\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def run", "output": "def run(self):\n\"\"\"Main execution loop\"\"\"\nif self.initialized:\nprint(f\"Running Decision Making Engine\")\nreturn True\nreturn False\n\ndef main():\ncomponent = DecisionEngine()\nsuccess = component.run()", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup", "output": "def setup(self):\n\"\"\"Initialize the component\"\"\"\nif not self.initialized:\n# Create state file\nstate = {\n\"component\": \"AI Integration System\",\n\"status\": \"initialized\",\n\"timestamp\": datetime.now().isoformat()\n}\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def run", "output": "def run(self):\n\"\"\"Main execution loop\"\"\"\nif self.initialized:\nprint(f\"Running AI Integration System\")\nreturn True\nreturn False\n\ndef main():\ncomponent = AIIntegration()\nsuccess = component.run()", "source": "dashboard"}
{"instruction": "Write a Rust function.", "input": "Function: fn set<'a, T: 'a, I>", "output": "fn set<'a, T: 'a, I>(iter: I) -> HashSet<T>", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn indexmap<'a, T: 'a, I>", "output": "fn indexmap<'a, T: 'a, I>(iter: I) -> IndexMap<T, ()>", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn $fn_name:ident", "output": "fn $fn_name:ident($($arg_name:ident : $arg_ty:ty),*) -> $ret:ty {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_create_map", "output": "fn test_create_map() {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_create_set", "output": "fn test_create_set() {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, rhs: &(A, B)) -> bool {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn equivalent", "output": "fn equivalent(&self, other: &X) -> bool {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_lookup", "output": "fn test_lookup() {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_sort", "output": "fn test_sort() {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_sort_set", "output": "fn test_sort_set() {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn small_rng", "output": "fn small_rng() -> fastrand::Rng {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn hash<H: Hasher>", "output": "fn hash<H: Hasher>(&self, h: &mut H) {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(s: &'a S) -> Self {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn small_rng", "output": "fn small_rng() -> fastrand::Rng {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn new_hashmap", "output": "fn new_hashmap(b: &mut Bencher) {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn new_indexmap", "output": "fn new_indexmap(b: &mut Bencher) {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn arbitrary", "output": "fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn arbitrary_take_rest", "output": "fn arbitrary_take_rest(u: Unstructured<'a>) -> Result<Self> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn arbitrary", "output": "fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn stream<'sval, ST: Stream<'sval> + ?Sized>", "output": "fn stream<'sval, ST: Stream<'sval> + ?Sized>(&'sval self, stream: &mut ST) -> sval::Result {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn stream<'sval, ST: Stream<'sval> + ?Sized>", "output": "fn stream<'sval, ST: Stream<'sval> + ?Sized>(&'sval self, stream: &mut ST) -> sval::Result {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize<T>", "output": "fn serialize<T>(&self, serializer: T) -> Result<T::Ok, T::Error>", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn expecting", "output": "fn expecting(&self, formatter: &mut Formatter<'_>) -> fmt::Result {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn visit_map<A>", "output": "fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn get", "output": "fn get(self) -> u64 {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone", "output": "fn clone(&self) -> Self {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone_from", "output": "fn clone_from(&mut self, other: &Self) {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize<W: Write>", "output": "fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn deserialize_reader<R: Read>", "output": "fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize<W: Write>", "output": "fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone", "output": "fn clone(&self) -> Self {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone_from", "output": "fn clone_from(&mut self, other: &Self) {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<Self::Item> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn size_hint", "output": "fn size_hint(&self) -> (usize, Option<usize>) {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn count", "output": "fn count(self) -> usize {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone", "output": "fn clone(&self) -> Self {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone_from", "output": "fn clone_from(&mut self, other: &Self) {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn collect<I: IntoParallelIterator>", "output": "fn collect<I: IntoParallelIterator>(iter: I) -> LinkedList<Vec<I::Item>> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_par_iter", "output": "fn into_par_iter(self) -> Self::Iter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_par_iter", "output": "fn into_par_iter(self) -> Self::Iter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_par_iter", "output": "fn into_par_iter(self) -> Self::Iter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_par_iter", "output": "fn into_par_iter(self) -> Self::Iter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_hash<K, V>", "output": "fn get_hash<K, V>(entries: &[Bucket<K, V>]) -> impl Fn(&usize) -> u64 + use<'_, K, V> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn equivalent<'a, K, V, Q: ?Sized + Equivalent<K>>", "output": "fn equivalent<'a, K, V, Q: ?Sized + Equivalent<K>>(", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn erase_index", "output": "fn erase_index(table: &mut Indices, hash: HashValue, index: usize) {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_boxed", "output": "fn into_boxed(self: Box<Self>) -> Box<[Bucket<K, V>]> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_iter", "output": "fn into_iter(self) -> Self::IntoIter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_iter", "output": "fn into_iter(self) -> Self::IntoIter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_iter", "output": "fn into_iter(self) -> Self::IntoIter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_iter", "output": "fn into_iter(self) -> Self::IntoIter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_iter", "output": "fn into_iter(self) -> Self::IntoIter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_full_mut2<Q>", "output": "fn get_full_mut2<Q>(&mut self, key: &Q) -> Option<(usize, &mut Self::Key, &mut Self::Value)>", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_index_mut2", "output": "fn get_index_mut2(&mut self, index: usize) -> Option<(&mut Self::Key, &mut Self::Value)>;", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn iter_mut2", "output": "fn iter_mut2(&mut self) -> IterMut2<'_, Self::Key, Self::Value>;", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize<T>", "output": "fn serialize<T>(&self, serializer: T) -> Result<T::Ok, T::Error>", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize<Se>", "output": "fn serialize<Se>(&self, serializer: Se) -> Result<Se::Ok, Se::Error>", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn expecting", "output": "fn expecting(&self, formatter: &mut Formatter<'_>) -> fmt::Result {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn it_works", "output": "fn it_works() {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new() {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn insert", "output": "fn insert() {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_boxed", "output": "fn into_boxed(self: Box<Self>) -> Box<[Bucket<T>]> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_iter", "output": "fn into_iter(self) -> Self::IntoIter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_iter", "output": "fn into_iter(self) -> Self::IntoIter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_iter", "output": "fn into_iter(self) -> Self::IntoIter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_iter", "output": "fn into_iter(self) -> Self::IntoIter {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn len", "output": "fn len(&self) -> usize {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_full_mut2<Q>", "output": "fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut Self::Value)>", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_index_mut2", "output": "fn get_index_mut2(&mut self, index: usize) -> Option<&mut Self::Value>;", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn retain2<F>", "output": "fn retain2<F>(&mut self, keep: F)", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn it_works", "output": "fn it_works() {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new() {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn insert", "output": "fn insert() {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn raw_entry_v1", "output": "fn raw_entry_v1(&self) -> RawEntryBuilder<'_, K, V, S>;", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn raw_entry_mut_v1", "output": "fn raw_entry_mut_v1(&mut self) -> RawEntryBuilderMut<'_, K, V, S>;", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn raw_entry_v1", "output": "fn raw_entry_v1(&self) -> RawEntryBuilder<'_, K, V, S> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_ref_mut", "output": "fn into_ref_mut(self) -> RefMut<'a, K, V> {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "indexmap-2.12.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_json_stream_newlines", "output": "fn test_json_stream_newlines() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_json_stream_trailing_whitespaces", "output": "fn test_json_stream_trailing_whitespaces() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_json_stream_truncated", "output": "fn test_json_stream_truncated() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_encode_ok<T>", "output": "fn test_encode_ok<T>(errors: &[(T, &str)])", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_pretty_encode_ok<T>", "output": "fn test_pretty_encode_ok<T>(errors: &[(T, &str)])", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_write_null", "output": "fn test_write_null() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn ui", "output": "fn ui() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn number", "output": "fn number() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn value_null", "output": "fn value_null() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn value_bool", "output": "fn value_bool() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_preserve_order", "output": "fn test_preserve_order() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_shift_insert", "output": "fn test_shift_insert() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_append", "output": "fn test_append() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, other: &Self) -> bool {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn hash<H: Hasher>", "output": "fn hash<H: Hasher>(&self, h: &mut H) {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(j: Error) -> Self {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn source", "output": "fn source(&self) -> Option<&(dyn error::Error + 'static)> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn from_owned", "output": "fn from_owned(json: Box<str>) -> Box<Self> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_owned", "output": "fn into_owned(raw_value: Box<Self>) -> Box<str> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone", "output": "fn clone(&self) -> Self {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<io::Result<u8>> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize_bool", "output": "fn serialize_bool(self, value: bool) -> Result<()> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize_i8", "output": "fn serialize_i8(self, value: i8) -> Result<()> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize_i16", "output": "fn serialize_i16(self, value: i16) -> Result<()> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn visit<'de, V>", "output": "fn visit<'de, V>(self, visitor: V) -> Result<V::Value>", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn invalid_type", "output": "fn invalid_type(self, exp: &dyn Expected) -> Error {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn peek_or_null", "output": "fn peek_or_null(&mut self) -> Result<u8> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Result<Option<u8>>;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn peek", "output": "fn peek(&mut self) -> Result<Option<u8>>;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn discard", "output": "fn discard(&mut self);", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone", "output": "fn clone(&self) -> Self {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone_from", "output": "fn clone_from(&mut self, source: &Self) {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn round_toward", "output": "fn round_toward(fp: &mut ExtendedFloat, shift: i32) -> bool {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn downard", "output": "fn downard(_: &mut ExtendedFloat, _: bool) {}", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_powers", "output": "fn get_powers() -> &'static ModeratePathPowers;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_powers", "output": "fn get_powers() -> &'static ModeratePathPowers {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_u32", "output": "fn as_u32(self) -> u32;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_u64", "output": "fn as_u64(self) -> u64;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_u128", "output": "fn as_u128(self) -> u128;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn multiply_exponent_extended<F>", "output": "fn multiply_exponent_extended<F>(fp: &mut ExtendedFloat, exponent: i32, truncated: bool) -> bool", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn data", "output": "fn data(&self) -> &Vec<Limb> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn data_mut", "output": "fn data_mut(&mut self) -> &mut Vec<Limb> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn error_scale", "output": "fn error_scale() -> u32;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn error_halfscale", "output": "fn error_halfscale() -> u32;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn error_is_accurate<F: Float>", "output": "fn error_is_accurate<F: Float>(count: u32, fp: &ExtendedFloat) -> bool;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_wide<T: Integer>", "output": "fn as_wide<T: Integer>(t: T) -> Wide {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn split_u64", "output": "fn split_u64(x: u64) -> [Limb; 2] {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn split_u64", "output": "fn split_u64(x: u64) -> [Limb; 1] {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_i32", "output": "fn into_i32(value: usize) -> i32 {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn parse_mantissa<F>", "output": "fn parse_mantissa<F>(integer: &[u8], fraction: &[u8]) -> Bigint", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn round_nearest_tie_even", "output": "fn round_nearest_tie_even(fp: &mut ExtendedFloat, shift: i32, is_truncated: bool) {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn large_atof<F>", "output": "fn large_atof<F>(mantissa: Bigint, exponent: i32) -> F", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, _formatter: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn write", "output": "fn write(&mut self, buf: &[u8]) -> Result<usize>;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn write_all", "output": "fn write_all(&mut self, buf: &[u8]) -> Result<()> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn index_into<'v>", "output": "fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn index_into_mut<'v>", "output": "fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn index_or_insert<'v>", "output": "fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value;", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize<S>", "output": "fn serialize<S>(&self, serializer: S) -> result::Result<S::Ok, S::Error>", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize_bool", "output": "fn serialize_bool(self, value: bool) -> Result<Value> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize_i8", "output": "fn serialize_i8(self, value: i8) -> Result<Value> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn deserialize<D>", "output": "fn deserialize<D>(deserializer: D) -> Result<Value, D::Error>", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn expecting", "output": "fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn visit_bool<E>", "output": "fn visit_bool<E>(self, value: bool) -> Result<Value, E> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn write", "output": "fn write(&mut self, buf: &[u8]) -> io::Result<usize> {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(n: $ty) -> Self {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(f: f32) -> Self {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(f: f64) -> Self {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq_i64", "output": "fn eq_i64(value: &Value, other: i64) -> bool {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq_u64", "output": "fn eq_u64(value: &Value, other: u64) -> bool {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq_f32", "output": "fn eq_f32(value: &Value, other: f32) -> bool {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "serde_json-1.0.145"}
{"instruction": "Write a Rust function.", "input": "Function: fn parse", "output": "fn parse(rule: Rule, input: &str) -> Result<Pairs<Rule>, Error<Rule>> {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn json", "output": "fn json(state: Box<ParserState<'_, Rule>>) -> ParseResult<Box<ParserState<'_, Rule>>> {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn object", "output": "fn object(state: Box<ParserState<'_, Rule>>) -> ParseResult<Box<ParserState<'_, Rule>>> {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn parse", "output": "fn parse(rule: Rule, input: &str) -> Result<Pairs<Rule>, Error<Rule>> {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn expression", "output": "fn expression(", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn primary", "output": "fn primary(state: Box<ParserState<'_, Rule>>) -> ParseResult<Box<ParserState<'_, Rule>>> {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn parse", "output": "fn parse(rule: Rule, input: &str) -> Result<Pairs<Rule>, Error<Rule>> {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn expr", "output": "fn expr(state: Box<ParserState<'_, Rule>>) -> ParseResult<Box<ParserState<'_, Rule>>> {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn paren", "output": "fn paren(state: Box<ParserState<'_, Rule>>) -> ParseResult<Box<ParserState<'_, Rule>>> {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn snapshot_push_restore<T: Clone>", "output": "fn snapshot_push_restore<T: Clone>(elements: impl Iterator<Item = T> + Clone) {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn snapshot_push_clear_snapshot<T: Clone>", "output": "fn snapshot_push_clear_snapshot<T: Clone>(elements: impl Iterator<Item = T> + Clone) {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn snapshot_pop_restore<T: Clone>", "output": "fn snapshot_pop_restore<T: Clone>(elements: impl Iterator<Item = T>) {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn bitor", "output": "fn bitor(mut self, rhs: Self) -> Self {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn assign_next<R: RuleType>", "output": "fn assign_next<R: RuleType>(op: &mut Operator<R>, next: Operator<R>) {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn get", "output": "fn get(&self, rule: &R) -> Option<(u32, Assoc)> {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(value: Position<'_>) -> Self {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(value: Span<'_>) -> Self {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn tokens_helper_messages", "output": "fn tokens_helper_messages(", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn limit_reached", "output": "fn limit_reached(&self) -> bool {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn increment_depth", "output": "fn increment_depth(&mut self) {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, other: &Span<'i>) -> bool {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn hash<H: Hasher>", "output": "fn hash<H: Hasher>(&self, state: &mut H) {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn bitor", "output": "fn bitor(mut self, rhs: Self) -> Self {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn assign_next<R: RuleType>", "output": "fn assign_next<R: RuleType>(op: &mut Op<R>, next: Op<R>) {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Self {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn index", "output": "fn index(&self, range: Range<usize>) -> &[T] {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn snapshot_with_empty", "output": "fn snapshot_with_empty() {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn skip_until_basic", "output": "fn skip_until_basic(&mut self, strings: &[&str]) -> bool {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, other: &Position<'i>) -> bool {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn parse", "output": "fn parse(_: Rule, input: &str) -> Result<Pairs<'_, Rule>, Error<Rule>> {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn parses_to", "output": "fn parses_to() {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn missing_end", "output": "fn missing_end() {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn parse", "output": "fn parse(rule: R, input: &str) -> Result<Pairs<'_, R>, Error<R>>;", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn create_token", "output": "fn create_token(&self, index: usize) -> Token<'i, R> {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn len", "output": "fn len(&self) -> usize {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<Self::Item> {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn pair", "output": "fn pair(&self) -> usize {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn pair_from_end", "output": "fn pair_from_end(&self) -> usize {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn pos", "output": "fn pos(&self, index: usize) -> usize {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn pair", "output": "fn pair(&self) -> usize {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn pos", "output": "fn pos(&self, index: usize) -> usize {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_line_index", "output": "fn test_line_index() {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn next_start", "output": "fn next_start(&mut self) {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn next_start_from_end", "output": "fn next_start_from_end(&mut self) {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_start", "output": "fn is_start(&self, index: usize) -> bool {", "source": "pest-2.8.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn set<'a, T: 'a, I>", "output": "fn set<'a, T: 'a, I>(iter: I) -> HashSet<T>", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn indexmap<'a, T: 'a, I>", "output": "fn indexmap<'a, T: 'a, I>(iter: I) -> IndexMap<T, ()>", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn $fn_name:ident", "output": "fn $fn_name:ident($($arg_name:ident : $arg_ty:ty),*) -> $ret:ty {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_create_map", "output": "fn test_create_map() {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_create_set", "output": "fn test_create_set() {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, rhs: &(A, B)) -> bool {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn equivalent", "output": "fn equivalent(&self, other: &X) -> bool {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_lookup", "output": "fn test_lookup() {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_sort", "output": "fn test_sort() {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_sort_set", "output": "fn test_sort_set() {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn small_rng", "output": "fn small_rng() -> SmallRng {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn hash<H: Hasher>", "output": "fn hash<H: Hasher>(&self, h: &mut H) {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(s: &'a S) -> Self {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn small_rng", "output": "fn small_rng() -> SmallRng {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn new_hashmap", "output": "fn new_hashmap(b: &mut Bencher) {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn new_indexmap", "output": "fn new_indexmap(b: &mut Bencher) {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn equivalent", "output": "fn equivalent(&self, key: &K) -> bool;", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn equivalent", "output": "fn equivalent(&self, key: &K) -> bool {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn arbitrary", "output": "fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn arbitrary_take_rest", "output": "fn arbitrary_take_rest(u: Unstructured<'a>) -> Result<Self> {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn arbitrary", "output": "fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize<T>", "output": "fn serialize<T>(&self, serializer: T) -> Result<T::Ok, T::Error>", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn expecting", "output": "fn expecting(&self, formatter: &mut Formatter<'_>) -> fmt::Result {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn visit_map<A>", "output": "fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_full_mut2<Q: ?Sized>", "output": "fn get_full_mut2<Q: ?Sized>(", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn retain2<F>", "output": "fn retain2<F>(&mut self, keep: F)", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn __private_marker", "output": "fn __private_marker(&self) -> PrivateMarker;", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn get", "output": "fn get(self) -> u64 {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone", "output": "fn clone(&self) -> Self {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone_from", "output": "fn clone_from(&mut self, other: &Self) {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn expecting", "output": "fn expecting(&self, formatter: &mut Formatter<'_>) -> fmt::Result {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn visit_seq<A>", "output": "fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone", "output": "fn clone(&self) -> Self {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone_from", "output": "fn clone_from(&mut self, other: &Self) {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_entries", "output": "fn into_entries(self) -> Vec<Self::Entry> {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<Self::Item> {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn size_hint", "output": "fn size_hint(&self) -> (usize, Option<usize>) {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn count", "output": "fn count(self) -> usize {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone", "output": "fn clone(&self) -> Self {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn clone_from", "output": "fn clone_from(&mut self, other: &Self) {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_entries", "output": "fn into_entries(self) -> Vec<Self::Entry> {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_par_iter", "output": "fn into_par_iter(self) -> Self::Iter {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_par_iter", "output": "fn into_par_iter(self) -> Self::Iter {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_par_iter", "output": "fn into_par_iter(self) -> Self::Iter {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn collect<I: IntoParallelIterator>", "output": "fn collect<I: IntoParallelIterator>(iter: I) -> LinkedList<Vec<I::Item>> {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_par_iter", "output": "fn into_par_iter(self) -> Self::Iter {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_par_iter", "output": "fn into_par_iter(self) -> Self::Iter {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_par_iter", "output": "fn into_par_iter(self) -> Self::Iter {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_par_iter", "output": "fn into_par_iter(self) -> Self::Iter {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_hash<K, V>", "output": "fn get_hash<K, V>(entries: &[Bucket<K, V>]) -> impl Fn(&usize) -> u64 + '_ {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn equivalent<'a, K, V, Q: ?Sized + Equivalent<K>>", "output": "fn equivalent<'a, K, V, Q: ?Sized + Equivalent<K>>(", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn erase_index", "output": "fn erase_index(table: &mut RawTable<usize>, hash: HashValue, index: usize) {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn find_index", "output": "fn find_index(&self, index: usize) -> RawBucket {", "source": "indexmap-1.9.3"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def url_title_from_path", "output": "def url_title_from_path(path: str) -> str:\n\"\"\"\nExtracts the url_title part of a URI path\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def sitename_from_url", "output": "def sitename_from_url(_url: str) -> str | None:\n\"\"\"\nExtracts the sitename part of a URI path\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def preview_urls", "output": "def preview_urls(urls: list[str]) -> list[str]:\n\"\"\"\nsome sites have scene preview pages using the url_title as the path, e.g.\n- https://adulttimepilots.com/Expose-Her-Therapy/\n- https://daddysboy.org/A-Bets-A-Bet-Pop/\n- https://dareweshare.net/Thats-Good-Teamwork/\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def clean_text", "output": "def clean_text(details: str) -> str:\n\"\"\"\nremove escaped backslashes and html parse the details text\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def send_request", "output": "def send_request(url: str, head: dict, send_json=\"\") -> requests.Response:\n\"\"\"\nget post response from url\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def headers_for_homepage", "output": "def headers_for_homepage(homepage: str) -> dict[str, str]:", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def api_auth_cache_write", "output": "def api_auth_cache_write(site: str, app_id: str, api_key: str):", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def to_scraped_studio", "output": "def to_scraped_studio(raw_scene: dict) -> ScrapedStudio:", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def to_scraped_performer", "output": "def to_scraped_performer(dict: dict) -> ScrapedPerformer:", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def scrape_scene", "output": "def scrape_scene(url):\nquery = \"\"\"\nquery scrapeSceneURL($url: String!) {\nscrapeSceneURL(url: $url) {\ntitle\ndetails\ncode\ndate\nimage\nurls", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def site_name", "output": "def site_name(url: str) -> str:\n\"\"\"\nReturns the site name of the given URL, e.g. \"brazzers\" for \"https://www.brazzers.com\"\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_token_for", "output": "def get_token_for(domain: str, fallback: Callable[[str], str | None]) -> str | None:\n\"\"\"\nReturns a token for the given domain. If the stored token is not valid, the provided\nfallback function will be used to generate a new token.\n\nIf the fallback function returns None, it will return None.\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def add_markers", "output": "def add_markers(scene_id: str, markers: list[dict]):", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def biography_xpath_test", "output": "def biography_xpath_test(tree, html_name: str, selector: str) -> str | None:", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def determine_studio", "output": "def determine_studio(api_object: dict[str, Any]) -> str | None:\n\"\"\"\nDetermine studio name from API object properties to use instead of the\n`studio_name` property scraped by default\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def postprocess_scene", "output": "def postprocess_scene(scene: ScrapedScene, api_scene: dict[str, Any]) -> ScrapedScene:\n\"\"\"\nApplies post-processing to the scene\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def postprocess_movie", "output": "def postprocess_movie(movie: ScrapedMovie, api_movie: dict[str, Any]) -> ScrapedMovie:\n\"\"\"\nApplies post-processing to the movie\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def find_images", "output": "def find_images(input):\nquery = \"\"\"\nquery FindImages($image_filter: ImageFilterType, $filter:FindFilterType) {\nfindImages(image_filter: $image_filter, filter: $filter) {\nimages {\nid\n}\n}\n}\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_html_from_url", "output": "def get_html_from_url(url: str, session: requests.Session) -> html.HtmlElement | None:", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_first_elem_text", "output": "def get_first_elem_text(root: html.HtmlElement, expression: str) -> str | None:", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def clean_text", "output": "def clean_text(details: str) -> str:\n\"\"\"\nremove escaped backslashes and html parse the details text\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def determine_studio", "output": "def determine_studio(api_object: dict[str, Any]) -> str | None:\n\"\"\"\nDetermine studio name from API object properties to use instead of the\n`studio_name` property scraped by default\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def fix_ts_trans_find_replace", "output": "def fix_ts_trans_find_replace(text: str) -> str | None:\n\"\"\"\nAt some point in time, there was a mass find-replace performed that replaced\nall occurrences of \"TS\" or \"ts\" with \"Trans\".\n\nThe problem with this is that it replaced every match naively, resulting in\nthese examples:\n- tits -> tiTrans\n- hits -> hiTrans\n", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def fix_url", "output": "def fix_url(_url: str) -> str:\n\"\"\"\nReplaces the host part of the URL if criteria matched\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def to_scraped_studio", "output": "def to_scraped_studio(api_object: dict, lang=\"en\"):", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def send_request", "output": "def send_request(url: str, headers: dict = None):\n\"\"\"\nget post response from url\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def fetch_post", "output": "def fetch_post(cls, post_id: str) -> Union[Dict[str, Any], None]:\n\"\"\"\nFetches a post from the FetishKitsch website.\n\nParameters\n----------\npost_id : str\nThe ID of the post to fetch.\n\nReturns", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def fetch_thumbnail", "output": "def fetch_thumbnail(cls, thumbnail_url: str) -> Union[str, None]:\n\"\"\"\nFetches the thumbnail for a post from the FetishKitsch website.\n\nParameters\n----------\nthumbnail_url : str\nThe URL of the thumbnail to fetch.\n\nReturns", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def map_performer", "output": "def map_performer(cls, performer: str) -> ScrapedPerformer:\n\"\"\"\nMaps a raw performer info to a ScrapedPerformer.\n\nParameters\n----------\nperformer : str\nThe raw performer info to map.\n\nReturns", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def determine_studio", "output": "def determine_studio(api_object: dict[str, Any]) -> str | None:\n\"\"\"\nDetermine studio name from API object properties to use instead of the\n`studio_name` property scraped by default\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def postprocess_scene", "output": "def postprocess_scene(scene: ScrapedScene, api_scene: dict[str, Any]) -> ScrapedScene:\n\"\"\"\nApplies post-processing to the scene\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def postprocess_movie", "output": "def postprocess_movie(movie: ScrapedMovie, api_movie: dict[str, Any]) -> ScrapedMovie:\n\"\"\"\nApplies post-processing to the movie\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def determine_studio", "output": "def determine_studio(api_object: dict[str, Any]) -> str | None:\n\"\"\"\nDetermine studio name from API object properties to use instead of the\n`studio_name` property scraped by default\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def postprocess_scene", "output": "def postprocess_scene(scene: ScrapedScene, api_scene: dict[str, Any]) -> ScrapedScene:\n\"\"\"\nApplies post-processing to the scene\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def postprocess_movie", "output": "def postprocess_movie(movie: ScrapedMovie, api_movie: dict[str, Any]) -> ScrapedMovie:\n\"\"\"\nApplies post-processing to the movie\n\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def parse_name", "output": "def parse_name(name: str) -> tuple[str, str | None]:", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_page_content", "output": "def get_page_content(url):\n\"\"\"Fetch and parse HTML content from a given URL.\"\"\"\nheaders = {\n\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"\n}\nlog.debug(f\"Fetching URL: {url}\")\ntry:\nresponse = requests.get(url, headers=headers, timeout=10)\nresponse.raise_for_status()\nreturn html.fromstring(response.content)", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def format_date", "output": "def format_date(date_str):\n\"\"\"Convert date from 'Oct 9, 2017' to 'YYYY-MM-DD' format.\"\"\"\ntry:\nreturn datetime.strptime(date_str, \"%b %d, %Y\").strftime(\"%Y-%m-%d\")\nexcept ValueError:\nreturn None  # Return None if the date can't be parsed\n\n\ndef scrape_video_data(main_url):\n\"\"\"Extract title, image, details, tags, studio, and date for the given video URL.\"\"\"", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def scrape_video_data", "output": "def scrape_video_data(main_url):\n\"\"\"Extract title, image, details, tags, studio, and date for the given video URL.\"\"\"\ntree = get_page_content(main_url)\nif tree is None:\nreturn {}\n\nscene: dict = {\n\"studio\": {\"name\": \"Got2Pee\", \"url\": \"https://got2pee.com\"},\n}\n", "source": "CommunityScrapers"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def scene_from_url", "output": "def scene_from_url(url: str) -> ScrapedScene | None:", "source": "CommunityScrapers"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_generic<T>", "output": "fn test_generic<T>(x: T) -> TransparentWithGeneric<T> {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_generic_with_zst<T>", "output": "fn test_generic_with_zst<T>(x: T) -> TransparentWithGenericAndZeroSized<T> {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_transparent_wrapper", "output": "fn test_transparent_wrapper() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, &other: &u8) -> bool {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn eq", "output": "fn eq(&self, &other: &u8) -> bool {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_try_cast_slice", "output": "fn test_try_cast_slice() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_try_cast_slice_mut", "output": "fn test_try_cast_slice_mut() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_types", "output": "fn test_types() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_try_cast_slice", "output": "fn test_try_cast_slice() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_try_cast_slice_mut", "output": "fn test_try_cast_slice_mut() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_types", "output": "fn test_types() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_transparent_slice", "output": "fn test_transparent_slice() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_transparent_basic", "output": "fn test_transparent_basic() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_contiguous_doc", "output": "fn test_contiguous_doc() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_transparent_vtabled", "output": "fn test_transparent_vtabled() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_large_box_alloc", "output": "fn test_large_box_alloc() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_offset_of_vertex", "output": "fn test_offset_of_vertex() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_offset_of_foo", "output": "fn test_offset_of_foo() {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn zeroed", "output": "fn zeroed() -> Self {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn wrap", "output": "fn wrap(s: Inner) -> Self", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn wrap_ref", "output": "fn wrap_ref(s: &Inner) -> &Self {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn wrap_mut", "output": "fn wrap_mut(s: &mut Inner) -> &mut Self {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn drop", "output": "fn drop(&mut self) {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn from_integer", "output": "fn from_integer(value: Self::Int) -> Option<Self> {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn into_integer", "output": "fn into_integer(self) -> Self::Int {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_valid_bit_pattern", "output": "fn is_valid_bit_pattern(bits: &Self::Bits) -> bool;", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_valid_bit_pattern", "output": "fn is_valid_bit_pattern(_bits: &T) -> bool {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_valid_bit_pattern", "output": "fn is_valid_bit_pattern(bits: &Self::Bits) -> bool {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn wrap_vec", "output": "fn wrap_vec(s: Vec<Inner>) -> Vec<Self>", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn wrap_box", "output": "fn wrap_box(s: Box<Inner>) -> Box<Self> {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn wrap_rc", "output": "fn wrap_rc(s: Rc<Inner>) -> Rc<Self> {", "source": "bytemuck-1.24.0"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_simple", "output": "fn test_simple() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_trailing_commas", "output": "fn test_trailing_commas() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_single_line", "output": "fn test_single_line() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_basic_filter", "output": "fn test_basic_filter() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_basic_suffixes", "output": "fn test_basic_suffixes() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_basic_duplicates_passes", "output": "fn test_basic_duplicates_passes() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_debug_vector", "output": "fn test_debug_vector() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_unnamed_debug_vector", "output": "fn test_unnamed_debug_vector() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_unnamed_nested_closure", "output": "fn test_unnamed_nested_closure() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_simple", "output": "fn test_simple() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_bound_to_scope", "output": "fn test_bound_to_scope() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_settings_macro", "output": "fn test_settings_macro() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_selector_parser", "output": "fn test_selector_parser() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_with_random_value", "output": "fn test_with_random_value() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_with_random_value_inline_callback", "output": "fn test_with_random_value_inline_callback() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_basic_globbing", "output": "fn test_basic_globbing() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_basic_globbing_nested", "output": "fn test_basic_globbing_nested() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_globs_follow_links", "output": "fn test_globs_follow_links() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_binary_snapshot", "output": "fn test_binary_snapshot() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_new_extension", "output": "fn test_new_extension() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_malformed_name_and_extension", "output": "fn test_malformed_name_and_extension() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from((_, content): (AutoName, &'a str)) -> Self {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from((name, content): (Option<String>, &'a str)) -> Self {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from((name, content): (String, &'a str)) -> Self {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_embedded_test", "output": "fn test_embedded_test() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn source", "output": "fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_cargo_workspace_from_metadata", "output": "fn get_cargo_workspace_from_metadata(", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(value: $ty) -> Redaction {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(value: &'a str) -> Redaction {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_yaml_serialization", "output": "fn test_yaml_serialization() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from_content", "output": "fn from_content(content: Content) -> Result<PendingInlineSnapshot, Box<dyn Error>> {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_content", "output": "fn as_content(&self) -> Content {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from_content", "output": "fn from_content(content: Content) -> Result<MetaData, Box<dyn Error>> {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(value: I) -> Self {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from_iter<I: IntoIterator<Item = ", "output": "fn from_iter<I: IntoIterator<Item = (&'a str, &'a str)>>(iter: I) -> Self {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_filters", "output": "fn test_filters() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn print_snapshot_diff", "output": "fn print_snapshot_diff(&self) {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn print_snapshot_summary", "output": "fn print_snapshot_summary(&self) {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn print_info", "output": "fn print_info(&self) {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn f", "output": "fn f() {}", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn type_name_of_val<T>", "output": "fn type_name_of_val<T>(_: T) -> &'static str {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(value: Vec<(&'a str, Redaction)>) -> Redactions {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn default", "output": "fn default() -> Settings {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn add_redaction_impl", "output": "fn add_redaction_impl(&mut self, selector: &str, replacement: Redaction) {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn find_common_prefix", "output": "fn find_common_prefix(sorted_paths: &[PathBuf]) -> Option<&Path> {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_format_rust_expression", "output": "fn test_format_rust_expression() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn discriminant", "output": "fn discriminant(&self) -> usize {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn cmp", "output": "fn cmp(&self, other: &Self) -> Ordering {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn partial_cmp", "output": "fn partial_cmp(&self, other: &Self) -> Option<Ordering> {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn write_indentation", "output": "fn write_indentation(&mut self) {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn start_container", "output": "fn start_container(&mut self, c: char) {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn end_container", "output": "fn end_container(&mut self, c: char, empty: bool) {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(value: $ty) -> Content {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(_value: ()) -> Content {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from_yaml_blob", "output": "fn from_yaml_blob(blob: YamlValue, filename: &Path) -> Result<Content, Error> {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn to_yaml_value", "output": "fn to_yaml_value(content: &Content) -> YamlValue {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn translate_seq", "output": "fn translate_seq(seq: &[Content]) -> YamlValue {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new(index: usize, line: usize, col: usize) -> Marker {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn description", "output": "fn description(&self) -> &str {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn cause", "output": "fn cause(&self) -> Option<&dyn Error> {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_api", "output": "fn test_api() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn try_fail", "output": "fn try_fail(s: &str) -> Result<Vec<Yaml>, ScanError> {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_fail", "output": "fn test_fail() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn cause", "output": "fn cause(&self) -> Option<&dyn Error> {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn from", "output": "fn from(f: fmt::Error) -> Self {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn parse_f64", "output": "fn parse_f64(v: &str) -> Option<f64> {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn on_event", "output": "fn on_event(&mut self, ev: Event, _: Marker) {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn insert_new_node", "output": "fn insert_new_node(&mut self, node: (Yaml, usize)) {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn empty_scalar", "output": "fn empty_scalar() -> Event {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn empty_scalar_with_anchor", "output": "fn empty_scalar_with_anchor(anchor: usize, tag: Option<TokenType>) -> Event {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn on_event", "output": "fn on_event(&mut self, ev: Event);", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_basic_globbing_parent_dir", "output": "fn test_basic_globbing_parent_dir() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_basic_globbing_nested_parent_dir_base_path", "output": "fn test_basic_globbing_nested_parent_dir_base_path() {", "source": "insta-1.43.2"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_basic_globbing_nested_parent_glob", "output": "fn test_basic_globbing_nested_parent_glob() {", "source": "insta-1.43.2"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_synthesizer", "output": "def get_synthesizer(cpt: OrderedDict, device=torch.device(\"cpu\")):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __call__", "output": "def __call__(self, x: torch.Tensor, upp: int = 1) -> torch.Tensor:", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def forward", "output": "def forward(self, x: torch.Tensor, upp: int = 1) -> torch.Tensor:", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __call__", "output": "def __call__(self, y: torch.Tensor, y_hat: torch.Tensor) -> Tuple[", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def forward", "output": "def forward(self, y: torch.Tensor, y_hat: torch.Tensor) -> Tuple[", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __call__", "output": "def __call__(self, x: torch.Tensor, x_mask: torch.Tensor) -> torch.Tensor:", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def forward", "output": "def forward(self, x: torch.Tensor, x_mask: torch.Tensor) -> torch.Tensor:", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def call_weight_data_normal_if_Conv", "output": "def call_weight_data_normal_if_Conv(m: torch.nn.Module):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_padding", "output": "def get_padding(kernel_size: int, dilation=1) -> int:", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, channels: int, eps: float = 1e-5):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def export_onnx", "output": "def export_onnx(from_cpkt_pth: str, to_onnx_pth: str) -> str:", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __call__", "output": "def __call__(self, wav: np.ndarray[typing.Any, np.dtype]):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_inputs", "output": "def load_inputs(path: str | BytesIO, device: str, is_half=False):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, orig_func, sub_func, cond_func):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def unscale_", "output": "def unscale_(self, optimizer):\n\"\"\"\nDivides (\"unscales\") the optimizer's gradient tensors by the scale factor.\n:meth:`unscale_` is optional, serving cases where you need to\n:ref:`modify or inspect gradients<working-with-unscaled-gradients>`\nbetween the backward pass(es) and :meth:`step`.\nIf :meth:`unscale_` is not called explicitly,  gradients will be unscaled  automatically during :meth:`step`.\nSimple example, using :meth:`unscale_` to enable clipping of unscaled gradients::\n...\nscaler.scale(loss).backward()", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def update", "output": "def update(self, new_scale=None):\n\"\"\"\nUpdates the scale factor.\nIf any optimizer steps were skipped the scale is multiplied by ``backoff_factor``\nto reduce it. If ``growth_interval`` unskipped iterations occurred consecutively,\nthe scale is multiplied by ``growth_factor`` to increase it.\nPassing ``new_scale`` sets the new scale value manually. (``new_scale`` is not\nused directly, it's used to fill GradScaler's internal scale tensor. So if\n``new_scale`` was a tensor, later in-place changes to that tensor will not further\naffect the scale GradScaler uses internally.)", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def ipex_init", "output": "def ipex_init():  # pylint: disable=too-many-statements", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, hop_length=512, f0_min=50, f0_max=1100, sampling_rate=44100):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _interpolate_f0", "output": "def _interpolate_f0(self, f0: np.ndarray):\n\"\"\"\n\u5bf9F0\u8fdb\u884c\u63d2\u503c\u5904\u7406\n\"\"\"", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, hop_length=512, f0_min=50, f0_max=1100, sampling_rate=44100):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, model_path, device=\"cpu\", is_half=True):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, hop_length=512, f0_min=50, f0_max=1100, sampling_rate=44100):", "source": "rvc"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, image: torch.Tensor, weight: float):", "source": "apis"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_stability_style_presets", "output": "def get_stability_style_presets(include_none=True):", "source": "apis"}
{"instruction": "Write a Rust function.", "input": "Function: fn simple_concat", "output": "fn simple_concat() {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn decode_names<R>", "output": "fn decode_names<R>(ar: &mut Archive<R>) -> Vec<String>", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn header_impls", "output": "fn header_impls() {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn absolute_symlink", "output": "fn absolute_symlink() {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn absolute_hardlink", "output": "fn absolute_hardlink() {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn relative_hardlink", "output": "fn relative_hardlink() {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn description", "output": "fn description(&self) -> &str {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn source", "output": "fn source(&self) -> Option<&(dyn error::Error + 'static)> {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn other", "output": "fn other(msg: &str) -> Error {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_ustar", "output": "fn is_ustar(&self) -> bool {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_gnu", "output": "fn is_gnu(&self) -> bool {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn path_lossy", "output": "fn path_lossy(&self) -> String {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn read", "output": "fn read(&mut self, into: &mut [u8]) -> io::Result<usize> {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn path", "output": "fn path(&self) -> io::Result<Cow<Path>> {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn path_bytes", "output": "fn path_bytes(&self) -> Cow<[u8]> {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn _entries<'a>", "output": "fn _entries<'a>(", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn _unpack", "output": "fn _unpack(&mut self, dst: &Path) -> io::Result<()> {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<io::Result<Entry<'a, R>>> {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn _append_link", "output": "fn _append_link(&mut self, header: &mut Header, path: &Path, target: &Path) -> io::Result<()> {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_write", "output": "fn as_write(&mut self) -> &mut dyn Write;", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn as_write", "output": "fn as_write(&mut self) -> &mut dyn Write {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_newline", "output": "fn is_newline(a: &u8) -> bool {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<io::Result<PaxExtension<'entry>>> {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn default_gnu", "output": "fn default_gnu() {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn goto_old", "output": "fn goto_old() {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn goto_ustar", "output": "fn goto_ustar() {", "source": "tar-0.4.44"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "window-vibrancy-0.4.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "window-vibrancy-0.4.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn fmt", "output": "fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {", "source": "window-vibrancy-0.4.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_function_impl", "output": "fn get_function_impl(library: &str, function: &str) -> Option<FARPROC> {", "source": "window-vibrancy-0.4.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_win7", "output": "fn is_win7() -> bool {", "source": "window-vibrancy-0.4.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_at_least_build", "output": "fn is_at_least_build(build: u32) -> bool {", "source": "window-vibrancy-0.4.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn create_data", "output": "fn create_data(len: usize) -> Vec<u8> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_set_stream_len", "output": "fn test_set_stream_len(initial_len: usize, resize_len: usize) {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn resize_zero_to_zero", "output": "fn resize_zero_to_zero() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn panic_after<T, F>", "output": "fn panic_after<T, F>(d: Duration, f: F) -> T", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn can_read", "output": "fn can_read(path: &Path) {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn invalid_mini_sector_issue_16", "output": "fn invalid_mini_sector_issue_16() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn large_file_issue_12", "output": "fn large_file_issue_12() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn read_root_storage_to_vec<F>", "output": "fn read_root_storage_to_vec<F>(comp: &CompoundFile<F>) -> Vec<String> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn read_storage_to_vec<F>", "output": "fn read_storage_to_vec<F>(comp: &CompoundFile<F>, path: &str) -> Vec<String> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn walk_to_vec", "output": "fn walk_to_vec(entries: &[Entry]) -> Vec<&Path> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn split", "output": "fn split(path: &str) -> (PathBuf, PathBuf) {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn list_entry", "output": "fn list_entry(name: &str, entry: &cfb::Entry, long: bool) {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn main", "output": "fn main() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn open_rw_with_path", "output": "fn open_rw_with_path(path: &Path) -> io::Result<CompoundFile<fs::File>> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn create_with_path", "output": "fn create_with_path(path: &Path) -> io::Result<CompoundFile<fs::File>> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn stream_id_for_name_chain", "output": "fn stream_id_for_name_chain(&self, names: &[&str]) -> Option<u32> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn seek", "output": "fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn read", "output": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn write", "output": "fn write(&mut self, buf: &[u8]) -> io::Result<usize> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn number_round_trip", "output": "fn number_round_trip() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn round_trip", "output": "fn round_trip() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn make_valid_header", "output": "fn make_valid_header() -> Header {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn make_valid_header_data", "output": "fn make_valid_header_data() -> Vec<u8> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn round_trip", "output": "fn round_trip() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn timestamp_from_system_time", "output": "fn timestamp_from_system_time(system_time: SystemTime) -> u64 {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn duration_to_timestamp_delta", "output": "fn duration_to_timestamp_delta(duration: Duration) -> u64 {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn timestamp_delta_to_duration", "output": "fn timestamp_delta_to_duration(delta: u64) -> Duration {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn seek", "output": "fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn read", "output": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn write", "output": "fn write(&mut self, buf: &[u8]) -> io::Result<usize> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn name_ordering", "output": "fn name_ordering() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn short_name_is_valid", "output": "fn short_name_is_valid() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn long_name_is_invalid", "output": "fn long_name_is_invalid() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn validate", "output": "fn validate(&self) -> io::Result<()> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn allocate_sector", "output": "fn allocate_sector(&mut self, init: SectorInit) -> io::Result<u32> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn append_fat_sector", "output": "fn append_fat_sector(&mut self) -> io::Result<()> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn dir_entry_mut", "output": "fn dir_entry_mut(&mut self, stream_id: u32) -> &mut DirEntry {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn validate", "output": "fn validate(&self) -> io::Result<()> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn seek_to_dir_entry", "output": "fn seek_to_dir_entry(&mut self, stream_id: u32) -> io::Result<Sector<F>> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn remaining", "output": "fn remaining(&self) -> usize {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn read", "output": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn write", "output": "fn write(&mut self, buf: &[u8]) -> io::Result<usize> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn parse_valid_storage_entry_with_end_of_chain_start", "output": "fn parse_valid_storage_entry_with_end_of_chain_start() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn parse_valid_storage_entry", "output": "fn parse_valid_storage_entry() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn invalid_object_type", "output": "fn invalid_object_type() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn validate", "output": "fn validate(&self) -> io::Result<()> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn allocate_mini_sector", "output": "fn allocate_mini_sector(&mut self, value: u32) -> io::Result<u32> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn append_mini_sector", "output": "fn append_mini_sector(&mut self) -> io::Result<()> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn join_path", "output": "fn join_path(parent_path: &Path, dir_entry: &DirEntry) -> PathBuf {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn stack_left_spine", "output": "fn stack_left_spine(&mut self, parent_path: &Path, mut current_id: u32) {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn next", "output": "fn next(&mut self) -> Option<Entry> {", "source": "cfb-0.7.3"}
{"instruction": "Write a Rust function.", "input": "Function: fn round_trip", "output": "fn round_trip() {", "source": "cfb-0.7.3"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_metrics", "output": "def generate_metrics():\n\"\"\"Generate current system metrics.\"\"\"\ntry:\nmem = psutil.virtual_memory()\ndisk = psutil.disk_usage('/')\nnet_io = psutil.net_io_counters(pernic=True)\nreturn {\n'cpu_percent': psutil.cpu_percent(interval=1),\n'memory_percent': mem.percent,\n'disk_percent': disk.percent,", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def send_metrics", "output": "def send_metrics():\n\"\"\"SSE event generator.\"\"\"\ntry:\nwhile True:\nmetrics = generate_metrics()\nyield f\"data: {json.dumps(metrics)}\\n\\n\"\nsleep(2)  # Update every 2 seconds\nexcept GeneratorExit:\npass\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def healthz", "output": "def healthz():\n\"\"\"Health check endpoint.\"\"\"\ntry:\n# Basic system checks\npsutil.cpu_percent()\npsutil.virtual_memory()\npsutil.disk_usage('/')\nreturn jsonify({\n'status': 'healthy',\n'timestamp': datetime.now().isoformat()", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _load_config", "output": "def _load_config(self) -> Dict[str, Any]:\n\"\"\"Load deployment configuration.\"\"\"\nconfig = {\n'production': {\n'host': os.getenv('DEPLOY_HOST', 'localhost'),\n'port': int(os.getenv('DEPLOY_PORT', 8000)),\n'api_key': os.getenv('DEPLOY_KEY'),\n'backup_retention_days': 7\n},\n'staging': {", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def create_backup", "output": "def create_backup(self, env: str) -> str:\n\"\"\"Create backup of current deployment.\"\"\"\nlogger.info(f\"Creating backup for {env} environment\")\n\ntimestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\nbackup_path = self.backup_dir / f\"backup_{env}_{timestamp}.tar.gz\"\n\ntry:\n# Create backup archive\nsubprocess.run([", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def format_html_doc", "output": "def format_html_doc(content: str) -> str:\n\"\"\"Wrap content in a complete HTML document structure.\"\"\"\nreturn f\"\"\"<!DOCTYPE html>", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_html_content", "output": "def generate_html_content(metrics: Dict, events: List, timeline_data: Optional[Dict], narrative_data: Optional[Dict]) -> str:\n\"\"\"Generate the main HTML content.\"\"\"\ntry:\n# Build HTML content piece by piece\nparts = []\n\n# Add header\nparts.append(\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_system_status", "output": "def get_system_status() -> Dict:\n\"\"\"Get comprehensive system status including metrics and state.\"\"\"\ntry:\nmetrics = system_metrics.get_all_metrics()\nstatus = 'healthy'\nissues = []\nif metrics['cpu'].get('percent', 0) > 80:\nissues.append(f\"High CPU usage: {metrics['cpu']['percent']}%\")\nstatus = 'warning'\nif metrics['memory'].get('virtual', {}).get('percent', 0) > 80:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_memorycore_stats", "output": "def get_memorycore_stats():\n\"\"\"Get MemoryCore specific statistics.\"\"\"\nbase_path = Path('/Volumes/Mac Mini External/MemoryCore')\nstats = {'total_files': 0, 'total_size': 0, 'categories': {}, 'recent_changes': []}\nfor category in ['docs', 'scripts', 'data', 'models']:\ncat_path = base_path / category\nif cat_path.exists():\nfiles = list(cat_path.rglob('*'))\nfile_count = len([f for f in files if f.is_file()])\ntotal_size = sum((f.stat().st_size for f in files if f.is_file()))", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_recent_events", "output": "def get_recent_events():\n\"\"\"Get most recent events from timeline data and other sources.\"\"\"\nevents = []\nenriched_path = Path('/Volumes/Mac Mini External/MemoryCore/docs/dashboard/data/timeline/timeline_enriched.json')\nraw_path = Path('/Volumes/Mac Mini External/MemoryCore/docs/dashboard/data/timeline/timeline_data.json')\ntimeline_path = enriched_path if enriched_path.exists() else raw_path\nif timeline_path.exists():\ntry:\nwith open(timeline_path) as f:\ndata = json.load(f)", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup_logging", "output": "def setup_logging():\n\"\"\"Configure logging with rotation and structured format.\"\"\"\n# Create log directory if it doesn't exist\nLOG_DIR.mkdir(parents=True, exist_ok=True)\n\n# Create rotating file handler for debugging\nfile_handler = RotatingFileHandler(\nLOG_FILE,\nmaxBytes=MAX_BYTES,\nbackupCount=BACKUP_COUNT", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def log_with_context", "output": "def log_with_context(logger, level, message, **context):\n\"\"\"\nLog a message with additional context.\n\nArgs:\nlogger: Logger instance\nlevel: Logging level (e.g., INFO, ERROR)\nmessage: Log message\n**context: Additional context as key-value pairs\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get", "output": "def get(self, key: str) -> Optional[Any]:\n\"\"\"\nGet a value from cache if it exists and hasn't expired.\n\nArgs:\nkey: Cache key\n\nReturns:\nCached value if valid, None otherwise\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def set", "output": "def set(self, key: str, value: Any) -> None:\n\"\"\"\nSet a value in cache with current timestamp.\n\nArgs:\nkey: Cache key\nvalue: Value to cache\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _send_request", "output": "def _send_request(self, payload: Dict[str, Any]) -> requests.Response:\n\"\"\"Send request to Pushover API with retry logic\"\"\"\nfor attempt in range(self.retry_attempts):\ntry:\nresponse = requests.post(self.PUSHOVER_API_URL, data=payload)\nresponse.raise_for_status()\nreturn response\nexcept requests.RequestException as e:\nlogger.warning(f'Attempt {attempt + 1} failed: {str(e)}')\nif attempt < self.retry_attempts - 1:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def speak_message", "output": "def speak_message(self, message: str, voice: str='Daniel') -> None:\n\"\"\"\nSpeak the message using macOS text-to-speech\n\nArgs:\nmessage: The message to speak\nvoice: The voice to use (default: Daniel)\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def signal_handler", "output": "def signal_handler(signum, frame):\n\"\"\"Handle signals gracefully.\"\"\"\nlocal_logger = logging.getLogger('Launcher')\nif flask_process:\nlocal_logger.info(\"Stopping dashboard...\")\nflask_process.terminate()\ntry:\nflask_process.wait(timeout=5)\nexcept subprocess.TimeoutExpired:\nflask_process.kill()", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup_logging", "output": "def setup_logging():\n\"\"\"Set up logging.\"\"\"\nlog_dir = Path(__file__).parent / 'logs'\nlog_dir.mkdir(exist_ok=True, parents=True)\n\nlogging.basicConfig(\nlevel=logging.INFO,\nformat='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\nhandlers=[\nlogging.FileHandler(log_dir / 'dashboard.log'),", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def check_dependencies", "output": "def check_dependencies():\n\"\"\"Check and install required Python packages.\"\"\"\nrequired_packages = [\n'flask',\n'werkzeug',\n'aiohttp',\n'psutil'\n]\n\nfor package in required_packages:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def run_tests", "output": "def run_tests(self, test_type: Optional[str] = None, parallel: bool = True) -> bool:\n\"\"\"Run tests and generate reports.\"\"\"\nlogger.info(\"Starting test execution...\")\nstart_time = datetime.now()\n\ntry:\n# Build pytest command\ncmd = [\n'pytest',\n'--cache-clear',", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _save_test_results", "output": "def _save_test_results(self, success: bool, duration: timedelta):\n\"\"\"Save test results to file.\"\"\"\nresults = {\n'timestamp': datetime.now().isoformat(),\n'success': success,\n'duration_seconds': duration.total_seconds(),\n'git_commit': self._get_git_commit()\n}\n\nresults_file = self.report_dir / 'test_results.json'", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_salt", "output": "def generate_salt() -> str:\n\"\"\"Generate a random salt.\"\"\"\nreturn base64.b64encode(secrets.token_bytes(16)).decode('utf-8')\n\ndef hash_password(password: str, salt: str) -> str:\n\"\"\"Hash password with salt using SHA-256.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def hash_password", "output": "def hash_password(password: str, salt: str) -> str:\n\"\"\"Hash password with salt using SHA-256.\"\"\"\ncombined = password.encode() + base64.b64decode(salt)\nreturn base64.b64encode(hashlib.sha256(combined).digest()).decode('utf-8')\n\ndef main():\n\"\"\"Set up dashboard authentication.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def main", "output": "def main():\n\"\"\"Set up dashboard authentication.\"\"\"\nbase_path = Path('/Volumes/Mac Mini External/MemoryCore/docs/dashboard')\nconfig_path = base_path / 'config/auth.json'\n\nif not config_path.parent.exists():\nconfig_path.parent.mkdir(parents=True)\n\n# Get credentials\nprint(\"Setting up dashboard authentication\")", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_cpu_metrics", "output": "def get_cpu_metrics(self) -> Dict:\n\"\"\"Get detailed CPU metrics.\"\"\"\ntry:\ncpu_freq = psutil.cpu_freq()\nreturn {\n'percent': psutil.cpu_percent(interval=1),\n'per_cpu': psutil.cpu_percent(interval=1, percpu=True),\n'count': psutil.cpu_count(),\n'count_logical': psutil.cpu_count(logical=True),\n'freq': {", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_memory_metrics", "output": "def get_memory_metrics(self) -> Dict:\n\"\"\"Get detailed memory metrics.\"\"\"\ntry:\nvm = psutil.virtual_memory()\nsm = psutil.swap_memory()\nreturn {\n'virtual': {\n'total_gb': round(vm.total / (1024**3), 2),\n'available_gb': round(vm.available / (1024**3), 2),\n'used_gb': round(vm.used / (1024**3), 2),", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_disk_metrics", "output": "def get_disk_metrics(self) -> Dict:\n\"\"\"Get detailed disk metrics.\"\"\"\ntry:\npath = '/Volumes/Mac Mini External'\nusage = psutil.disk_usage(path)\nio_counters = psutil.disk_io_counters()\n\nreturn {\n'usage': {\n'total_gb': round(usage.total / (1024**3), 2),", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_configuration", "output": "def test_configuration():\n\"\"\"Test configuration system.\"\"\"\nlogger.info(\"Testing configuration...\")\n\n# Check directory structure\ndirs_to_check = [\nservice_config.log_dir,\nservice_config.state_dir,\nservice_config.config_dir\n]", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_service_registry", "output": "def test_service_registry():\n\"\"\"Test service registry functionality.\"\"\"\nlogger.info(\"Testing service registry...\")\n\n# Register test service\nservice_registry.register_service('test_service', TestService)\n\n# Start service\nsuccess = service_registry.start_service('test_service')\nassert success, \"Failed to start test service\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_error_recovery", "output": "def test_error_recovery():\n\"\"\"Test error recovery mechanisms.\"\"\"\nlogger.info(\"Testing error recovery...\")\n\n# Start service\nservice_registry.start_service('test_service')\n\n# Wait for error (occurs every 10 iterations)\nlogger.info(\"Waiting for error condition...\")\ntime.sleep(12)  # Ensure we hit an error", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _generate_core_commands", "output": "def _generate_core_commands(self) -> List[str]:\n\"\"\"Generate commands for core infrastructure development\"\"\"\nreturn [\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/monitor.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/password_manager.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/docker_manager.py\"\n]\n\ndef _generate_ai_commands(self) -> List[str]:\n\"\"\"Generate commands for AI development\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _generate_ai_commands", "output": "def _generate_ai_commands(self) -> List[str]:\n\"\"\"Generate commands for AI development\"\"\"\nreturn [\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/ai/system_brain.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/ai/model_trainer.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/ai/pattern_analyzer.py\"\n]\n\ndef _generate_automation_commands(self) -> List[str]:\n\"\"\"Generate commands for automation development\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_metrics", "output": "def generate_metrics():\n\"\"\"Generate current system metrics.\"\"\"\ntry:\nmem = psutil.virtual_memory()\ndisk = psutil.disk_usage('/')\nnet_io = psutil.net_io_counters(pernic=True)\nreturn {\n'cpu_percent': psutil.cpu_percent(interval=1),\n'memory_percent': mem.percent,\n'disk_percent': disk.percent,", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def send_metrics", "output": "def send_metrics():\n\"\"\"SSE event generator.\"\"\"\ntry:\nwhile True:\nmetrics = generate_metrics()\nyield f\"data: {json.dumps(metrics)}\\n\\n\"\nsleep(2)  # Update every 2 seconds\nexcept GeneratorExit:\npass\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def healthz", "output": "def healthz():\n\"\"\"Health check endpoint.\"\"\"\ntry:\n# Basic system checks\npsutil.cpu_percent()\npsutil.virtual_memory()\npsutil.disk_usage('/')\nreturn jsonify({\n'status': 'healthy',\n'timestamp': datetime.now().isoformat()", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _load_config", "output": "def _load_config(self) -> Dict[str, Any]:\n\"\"\"Load deployment configuration.\"\"\"\nconfig = {\n'production': {\n'host': os.getenv('DEPLOY_HOST', 'localhost'),\n'port': int(os.getenv('DEPLOY_PORT', 8000)),\n'api_key': os.getenv('DEPLOY_KEY'),\n'backup_retention_days': 7\n},\n'staging': {", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def create_backup", "output": "def create_backup(self, env: str) -> str:\n\"\"\"Create backup of current deployment.\"\"\"\nlogger.info(f\"Creating backup for {env} environment\")\n\ntimestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\nbackup_path = self.backup_dir / f\"backup_{env}_{timestamp}.tar.gz\"\n\ntry:\n# Create backup archive\nsubprocess.run([", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_system_status", "output": "def get_system_status() -> Dict:\n\"\"\"Get comprehensive system status including metrics and state.\"\"\"\ntry:\nmetrics = system_metrics.get_all_metrics()\nstatus = 'healthy'\nissues = []\nif metrics['cpu'].get('percent', 0) > 80:\nissues.append(f\"High CPU usage: {metrics['cpu']['percent']}%\")\nstatus = 'warning'\nif metrics['memory'].get('virtual', {}).get('percent', 0) > 80:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_memorycore_stats", "output": "def get_memorycore_stats():\n\"\"\"Get MemoryCore specific statistics.\"\"\"\nbase_path = Path('/Volumes/Mac Mini External/MemoryCore')\nstats = {'total_files': 0, 'total_size': 0, 'categories': {}, 'recent_changes': []}\nfor category in ['docs', 'scripts', 'data', 'models']:\ncat_path = base_path / category\nif cat_path.exists():\nfiles = list(cat_path.rglob('*'))\nfile_count = len([f for f in files if f.is_file()])\ntotal_size = sum((f.stat().st_size for f in files if f.is_file()))", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_recent_events", "output": "def get_recent_events():\n\"\"\"Get most recent events from timeline data and other sources.\"\"\"\nevents = []\nenriched_path = Path('/Volumes/Mac Mini External/MemoryCore/docs/dashboard/data/timeline/timeline_enriched.json')\nraw_path = Path('/Volumes/Mac Mini External/MemoryCore/docs/dashboard/data/timeline/timeline_data.json')\ntimeline_path = enriched_path if enriched_path.exists() else raw_path\nif timeline_path.exists():\ntry:\nwith open(timeline_path) as f:\ndata = json.load(f)", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def format_html_doc", "output": "def format_html_doc(content: str) -> str:\n\"\"\"Wrap content in a complete HTML document structure.\"\"\"\nreturn f\"\"\"<!DOCTYPE html>", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_html_content", "output": "def generate_html_content(metrics: Dict, events: List, timeline_data: Optional[Dict], narrative_data: Optional[Dict]) -> str:\n\"\"\"Generate the main HTML content.\"\"\"\ntry:\n# Build HTML content piece by piece\nparts = []\n\n# Add header\nparts.append(\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup_logging", "output": "def setup_logging():\n\"\"\"Configure logging with rotation and structured format.\"\"\"\n# Create log directory if it doesn't exist\nLOG_DIR.mkdir(parents=True, exist_ok=True)\n\n# Create rotating file handler for debugging\nfile_handler = RotatingFileHandler(\nLOG_FILE,\nmaxBytes=MAX_BYTES,\nbackupCount=BACKUP_COUNT", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def log_with_context", "output": "def log_with_context(logger, level, message, **context):\n\"\"\"\nLog a message with additional context.\n\nArgs:\nlogger: Logger instance\nlevel: Logging level (e.g., INFO, ERROR)\nmessage: Log message\n**context: Additional context as key-value pairs\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get", "output": "def get(self, key: str) -> Optional[Any]:\n\"\"\"\nGet a value from cache if it exists and hasn't expired.\n\nArgs:\nkey: Cache key\n\nReturns:\nCached value if valid, None otherwise\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def set", "output": "def set(self, key: str, value: Any) -> None:\n\"\"\"\nSet a value in cache with current timestamp.\n\nArgs:\nkey: Cache key\nvalue: Value to cache\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _send_request", "output": "def _send_request(self, payload: Dict[str, Any]) -> requests.Response:\n\"\"\"Send request to Pushover API with retry logic\"\"\"\nfor attempt in range(self.retry_attempts):\ntry:\nresponse = requests.post(self.PUSHOVER_API_URL, data=payload)\nresponse.raise_for_status()\nreturn response\nexcept requests.RequestException as e:\nlogger.warning(f'Attempt {attempt + 1} failed: {str(e)}')\nif attempt < self.retry_attempts - 1:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def speak_message", "output": "def speak_message(self, message: str, voice: str='Daniel') -> None:\n\"\"\"\nSpeak the message using macOS text-to-speech\n\nArgs:\nmessage: The message to speak\nvoice: The voice to use (default: Daniel)\n\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def signal_handler", "output": "def signal_handler(signum, frame):\n\"\"\"Handle signals gracefully.\"\"\"\nlocal_logger = logging.getLogger('Launcher')\nif flask_process:\nlocal_logger.info(\"Stopping dashboard...\")\nflask_process.terminate()\ntry:\nflask_process.wait(timeout=5)\nexcept subprocess.TimeoutExpired:\nflask_process.kill()", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def setup_logging", "output": "def setup_logging():\n\"\"\"Set up logging.\"\"\"\nlog_dir = Path(__file__).parent / 'logs'\nlog_dir.mkdir(exist_ok=True, parents=True)\n\nlogging.basicConfig(\nlevel=logging.INFO,\nformat='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\nhandlers=[\nlogging.FileHandler(log_dir / 'dashboard.log'),", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def check_dependencies", "output": "def check_dependencies():\n\"\"\"Check and install required Python packages.\"\"\"\nrequired_packages = [\n'flask',\n'werkzeug',\n'aiohttp',\n'psutil'\n]\n\nfor package in required_packages:", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_salt", "output": "def generate_salt() -> str:\n\"\"\"Generate a random salt.\"\"\"\nreturn base64.b64encode(secrets.token_bytes(16)).decode('utf-8')\n\ndef hash_password(password: str, salt: str) -> str:\n\"\"\"Hash password with salt using SHA-256.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def hash_password", "output": "def hash_password(password: str, salt: str) -> str:\n\"\"\"Hash password with salt using SHA-256.\"\"\"\ncombined = password.encode() + base64.b64decode(salt)\nreturn base64.b64encode(hashlib.sha256(combined).digest()).decode('utf-8')\n\ndef main():\n\"\"\"Set up dashboard authentication.\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def main", "output": "def main():\n\"\"\"Set up dashboard authentication.\"\"\"\nbase_path = Path('/Volumes/Mac Mini External/MemoryCore/docs/dashboard')\nconfig_path = base_path / 'config/auth.json'\n\nif not config_path.parent.exists():\nconfig_path.parent.mkdir(parents=True)\n\n# Get credentials\nprint(\"Setting up dashboard authentication\")", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_cpu_metrics", "output": "def get_cpu_metrics(self) -> Dict:\n\"\"\"Get detailed CPU metrics.\"\"\"\ntry:\ncpu_freq = psutil.cpu_freq()\nreturn {\n'percent': psutil.cpu_percent(interval=1),\n'per_cpu': psutil.cpu_percent(interval=1, percpu=True),\n'count': psutil.cpu_count(),\n'count_logical': psutil.cpu_count(logical=True),\n'freq': {", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_memory_metrics", "output": "def get_memory_metrics(self) -> Dict:\n\"\"\"Get detailed memory metrics.\"\"\"\ntry:\nvm = psutil.virtual_memory()\nsm = psutil.swap_memory()\nreturn {\n'virtual': {\n'total_gb': round(vm.total / (1024**3), 2),\n'available_gb': round(vm.available / (1024**3), 2),\n'used_gb': round(vm.used / (1024**3), 2),", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_disk_metrics", "output": "def get_disk_metrics(self) -> Dict:\n\"\"\"Get detailed disk metrics.\"\"\"\ntry:\npath = '/Volumes/Mac Mini External'\nusage = psutil.disk_usage(path)\nio_counters = psutil.disk_io_counters()\n\nreturn {\n'usage': {\n'total_gb': round(usage.total / (1024**3), 2),", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_configuration", "output": "def test_configuration():\n\"\"\"Test configuration system.\"\"\"\nlogger.info(\"Testing configuration...\")\n\n# Check directory structure\ndirs_to_check = [\nservice_config.log_dir,\nservice_config.state_dir,\nservice_config.config_dir\n]", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_service_registry", "output": "def test_service_registry():\n\"\"\"Test service registry functionality.\"\"\"\nlogger.info(\"Testing service registry...\")\n\n# Register test service\nservice_registry.register_service('test_service', TestService)\n\n# Start service\nsuccess = service_registry.start_service('test_service')\nassert success, \"Failed to start test service\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def test_error_recovery", "output": "def test_error_recovery():\n\"\"\"Test error recovery mechanisms.\"\"\"\nlogger.info(\"Testing error recovery...\")\n\n# Start service\nservice_registry.start_service('test_service')\n\n# Wait for error (occurs every 10 iterations)\nlogger.info(\"Waiting for error condition...\")\ntime.sleep(12)  # Ensure we hit an error", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _generate_core_commands", "output": "def _generate_core_commands(self) -> List[str]:\n\"\"\"Generate commands for core infrastructure development\"\"\"\nreturn [\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/monitor.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/password_manager.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/docker_manager.py\"\n]\n\ndef _generate_ai_commands(self) -> List[str]:\n\"\"\"Generate commands for AI development\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _generate_ai_commands", "output": "def _generate_ai_commands(self) -> List[str]:\n\"\"\"Generate commands for AI development\"\"\"\nreturn [\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/ai/system_brain.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/ai/model_trainer.py\",\n\"python3 /Volumes/Mac Mini External/MemoryCore/core/ai/pattern_analyzer.py\"\n]\n\ndef _generate_automation_commands(self) -> List[str]:\n\"\"\"Generate commands for automation development\"\"\"", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_all", "output": "def generate_all(self):\n\"\"\"Generate all documentation.\"\"\"\ntry:\nself.generate_architecture_docs()\nself.generate_api_docs()\nself.generate_deployment_docs()\nself.generate_troubleshooting_docs()\nself.generate_index()\n\nlogger.info(\"Documentation generation completed successfully\")", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_architecture_docs", "output": "def generate_architecture_docs(self):\n\"\"\"Generate system architecture documentation.\"\"\"\nlogger.info(\"Generating architecture documentation\")\n\ncontent = [\n\"# System Architecture\\n\",\n\"## Overview\\n\",\n\"The dashboard system consists of several key components working together \",\n\"to provide real-time monitoring and visualization capabilities.\\n\",\n", "source": "dashboard"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def transform", "output": "def transform(self, input_data, return_phase=False):\n\"\"\"Take input data (audio) to STFT domain.\n\nArguments:\ninput_data {tensor} -- Tensor of floats, with shape (num_batch, num_samples)\n\nReturns:\nmagnitude {tensor} -- Magnitude of STFT with shape (num_batch,\nnum_frequencies, num_frames)\nphase {tensor} -- Phase of STFT with shape (num_batch,", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def inverse", "output": "def inverse(self, magnitude, phase):\n\"\"\"Call the inverse STFT (iSTFT), given magnitude and phase tensors produced\nby the ```transform``` function.\n\nArguments:\nmagnitude {tensor} -- Magnitude of STFT with shape (num_batch,\nnum_frequencies, num_frames)\nphase {tensor} -- Phase of STFT with shape (num_batch,\nnum_frequencies, num_frames)\n", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def kl_divergence", "output": "def kl_divergence(m_p, logs_p, m_q, logs_q):\n\"\"\"KL(P||Q)\"\"\"\nkl = (logs_q - logs_p) - 0.5\nkl += (\n0.5 * (torch.exp(2.0 * logs_p) + ((m_p - m_q) ** 2)) * torch.exp(-2.0 * logs_q)\n)\nreturn kl\n\n\ndef rand_gumbel(shape):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, vec_path=\"pretrained/vec-768-layer-12.onnx\", device=None):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def jit_warm_up", "output": "def jit_warm_up(model, inputs_path, device=torch.device(\"cpu\"), epoch=5, is_half=False):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_synthesizer", "output": "def get_synthesizer(pth_path, device=torch.device(\"cpu\")):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_rmvpe", "output": "def get_rmvpe(model_path=\"assets/rmvpe/rmvpe.pt\", device=torch.device(\"cpu\")):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_data", "output": "def load_data(file_name: str = \"./infer/lib/uvr5_pack/name_params.json\") -> dict:", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def inference", "output": "def inference(X_spec, device, model, aggressiveness, data):\n\"\"\"\ndata \uff1a dic configs\n\"\"\"", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def dynamic_range_compression_torch", "output": "def dynamic_range_compression_torch(x, C=1, clip_val=1e-5):\n\"\"\"\nPARAMS\n------\nC: compression factor\n\"\"\"", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def dynamic_range_decompression_torch", "output": "def dynamic_range_decompression_torch(x, C=1):\n\"\"\"\nPARAMS\n------\nC: compression factor used to compress\n\"\"\"", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def savee", "output": "def savee(ckpt, sr, if_f0, name, epoch, version, hps):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def extract_small_model", "output": "def extract_small_model(path, name, sr, if_f0, info, version):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _filter", "output": "def _filter(self):\n\"\"\"\nFilter text & store spec lengths\n\"\"\"", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_checkpoint_d", "output": "def load_checkpoint_d(checkpoint_path, combd, sbd, optimizer=None, load_opt=1):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_checkpoint", "output": "def load_checkpoint(checkpoint_path, model, optimizer=None, load_opt=1):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def discriminator_loss", "output": "def discriminator_loss(disc_real_outputs, disc_generated_outputs):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, ch, dilations=(4, 8, 16, 32)):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, activ=nn.LeakyReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, nin, nout, ksize=3, stride=1, pad=1, dilation=1, activ=nn.ReLU):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, hop_length=512, f0_min=50, f0_max=1100, sampling_rate=44100):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, hop_length=512, f0_min=50, f0_max=1100, sampling_rate=44100):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, hop_length=512, f0_min=50, f0_max=1100, sampling_rate=44100):", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def compute_f0", "output": "def compute_f0(self, wav, p_len):\n\"\"\"\ninput: wav:[signal_length]\np_len:int\noutput: f0:[signal_length//hop_length]\n\"\"\"", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def compute_f0_uv", "output": "def compute_f0_uv(self, wav, p_len):\n\"\"\"\ninput: wav:[signal_length]\np_len:int\noutput: f0:[signal_length//hop_length],uv:[signal_length//hop_length]\n\"\"\"", "source": "lib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def male_average", "output": "def male_average(cls) -> 'SkeletonSpec':\n\"\"\"Average male proportions\"\"\"\nreturn cls(\nshoulder_width=0.26,  # Broader shoulders\nhip_width=0.17,       # Narrower hips\ntorso_length=0.30,\nleg_length=0.47,\narm_length=0.44,\nhead_size=0.13,\nheight_cm=178.0", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def female_average", "output": "def female_average(cls) -> 'SkeletonSpec':\n\"\"\"Average female proportions\"\"\"\nreturn cls(\nshoulder_width=0.22,  # Narrower shoulders\nhip_width=0.20,       # Wider hips\ntorso_length=0.28,\nleg_length=0.48,\narm_length=0.42,\nhead_size=0.12,\nheight_cm=164.0", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def default_male", "output": "def default_male(cls) -> 'AnatomicalConfig':\n\"\"\"Default male anatomical configuration\"\"\"\nconfig = cls()\n\n# Define bone chain (simplified - actual implementation would be more detailed)\nconfig.bones = [\nAnatomicalBone(\nname=\"anatomy_root\",\nparent=\"pelvis\",\nlocal_position=(0.0, -0.08, 0.02),", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def regenerate_face_mesh_from_texture", "output": "def regenerate_face_mesh_from_texture(performer_dir: Path, reconstructor: PhotorealisticFaceReconstructor):\n\"\"\"Regenerate face mesh for a performer using existing texture\"\"\"\n\n# Check for existing texture\ntexture_path = performer_dir / \"face_texture.png\"\nface_png_path = performer_dir / \"face.png\"\noriginal_face_path = performer_dir / \"original_face.png\"\n\n# Find the best available face image\nif texture_path.exists():", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def generate_full_triangulation", "output": "def generate_full_triangulation():\n\"\"\"Generate complete face triangulation using Delaunay on UV coordinates\"\"\"\n# Use canonical UV coordinates for 468 landmarks\n# and compute Delaunay triangulation\nfrom scipy.spatial import Delaunay\n\n# Canonical UV coordinates for 468 face landmarks (normalized 0-1)\n# This is a simplified version - ideally loaded from MediaPipe's data\nuv_coords = np.zeros((468, 2))\n", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _generate_triangulation", "output": "def _generate_triangulation(self, num_landmarks: int = 478) -> np.ndarray:\n\"\"\"Generate face mesh triangulation using Delaunay on actual landmark positions\"\"\"\n# This will be recomputed for each face using actual landmark positions\n# For initialization, use a placeholder\nreturn None\n\ndef _triangulate_landmarks(self, landmarks_2d: np.ndarray) -> np.ndarray:\n\"\"\"Create Delaunay triangulation from 2D landmark positions\"\"\"", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _calculate_quality", "output": "def _calculate_quality(self, face_crop: np.ndarray, landmarks: np.ndarray) -> float:\n\"\"\"Calculate face quality score based on size, sharpness, and frontality.\"\"\"\n# Size score (larger is better)\nh, w = face_crop.shape[:2]\nsize_score = min(1.0, (h * w) / (300 * 300))\n\n# Sharpness (Laplacian variance)\ngray = cv2.cvtColor(face_crop, cv2.COLOR_BGR2GRAY)\nsharpness = cv2.Laplacian(gray, cv2.CV_64F).var()\nsharpness_score = min(1.0, sharpness / 500)", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _classify_gender", "output": "def _classify_gender(self, face_crop: np.ndarray) -> Tuple[str, float]:\n\"\"\"Classify gender using DeepFace.\"\"\"\ntry:\n# DeepFace analyze\nresult = DeepFace.analyze(\nface_crop,\nactions=['gender'],\nenforce_detection=False,\nsilent=True\n)", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _ensure_models", "output": "def _ensure_models(self):\n\"\"\"Download models if needed.\"\"\"\nimport urllib.request\n\nself.POSE_MODEL_PATH.parent.mkdir(parents=True, exist_ok=True)\n\nif not self.POSE_MODEL_PATH.exists():\nprint(f\"Downloading pose model...\")\nurllib.request.urlretrieve(self.POSE_MODEL_URL, self.POSE_MODEL_PATH)\nprint(f\"Saved: {self.POSE_MODEL_PATH}\")", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _init_detectors", "output": "def _init_detectors(self):\n\"\"\"Initialize MediaPipe detectors.\"\"\"\n# Pose detector\npose_options = vision.PoseLandmarkerOptions(\nbase_options=mp_python.BaseOptions(model_asset_path=str(self.POSE_MODEL_PATH)),\noutput_segmentation_masks=False,\nnum_poses=4,\nmin_pose_detection_confidence=0.5,\nmin_tracking_confidence=0.5,\n)", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, canvas_size: Tuple[int, int] = (800, 1000)):", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _normalize_pose", "output": "def _normalize_pose(self, pose: np.ndarray) -> np.ndarray:\n\"\"\"Normalize pose to fit canvas, centered on hips.\"\"\"\nif len(pose) < 25:\nreturn pose\n\n# Get hip center\nhip_center = (pose[LEFT_HIP, :2] + pose[RIGHT_HIP, :2]) / 2\n\n# Get body height (nose to hip midpoint)\nbody_height = np.linalg.norm(pose[NOSE, :2] - hip_center)", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _draw_skeleton", "output": "def _draw_skeleton(self, canvas: np.ndarray, pose: np.ndarray,", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _get_face_mesh", "output": "def _get_face_mesh(self):\n\"\"\"Get MediaPipe face mesh for 468-point landmarks.\"\"\"\nif self._face_mesh is None:\ntry:\nimport mediapipe as mp\nself._face_mesh = mp.solutions.face_mesh.FaceMesh(\nstatic_image_mode=True,\nmax_num_faces=1,\nrefine_landmarks=True,\nmin_detection_confidence=0.5", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_face_landmarks_from_image", "output": "def get_face_landmarks_from_image(image_path):\n\"\"\"Get 68 landmarks from face image using insightface\"\"\"\ntry:\nimport insightface\nfrom insightface.app import FaceAnalysis\n\napp = FaceAnalysis(allowed_modules=['detection', 'landmark_2d_106'])\napp.prepare(ctx_id=-1, det_size=(512, 512))\n\nimg = cv2.imread(str(image_path))", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_landmarks_with_mediapipe", "output": "def get_landmarks_with_mediapipe(image_path):\n\"\"\"Fallback: get landmarks using mediapipe\"\"\"\nimport mediapipe as mp\n\nmp_face_mesh = mp.solutions.face_mesh\n\nimg = cv2.imread(str(image_path))\nif img is None:\nreturn None\n", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def apply_expression", "output": "def apply_expression(landmarks, expression_name, intensity=1.0):\n\"\"\"Apply expression morph to landmarks\"\"\"\nif expression_name not in EXPRESSIONS:\nreturn landmarks.copy()\n\nmorphed = landmarks.copy()\noffsets = EXPRESSIONS[expression_name]\n\nfor idx, (dx, dy) in offsets.items():\nif idx < len(morphed):", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def add_detection", "output": "def add_detection(self, embedding: np.ndarray, position: Tuple[float, float],", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_insightface_app", "output": "def get_insightface_app():\n\"\"\"Lazy load insightface\"\"\"\nglobal _insightface_app\nif _insightface_app is None:\ntry:\nfrom insightface.app import FaceAnalysis\n_insightface_app = FaceAnalysis(\nallowed_modules=['detection', 'recognition', 'landmark_2d_106']\n)\n_insightface_app.prepare(ctx_id=-1, det_size=(640, 640))", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_deepface", "output": "def get_deepface():\n\"\"\"Lazy load DeepFace\"\"\"\nglobal _deepface_loaded\nif not _deepface_loaded:\ntry:\nfrom deepface import DeepFace\n_deepface_loaded = True\nreturn DeepFace\nexcept ImportError:\nprint(\"Warning: DeepFace not available\")", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def download_model", "output": "def download_model(model_name: str, url: str, models_dir: Path) -> Path:\n\"\"\"Download model if not exists\"\"\"\nmodel_path = models_dir / model_name\nif not model_path.exists():\nprint(f\"Downloading {model_name}...\")\nmodels_dir.mkdir(parents=True, exist_ok=True)\nurllib.request.urlretrieve(url, str(model_path))\nreturn model_path\n\n", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def fix_performer_meshes", "output": "def fix_performer_meshes(performer_dir: Path):\n\"\"\"Fix meshes for a single performer\"\"\"\nprint(f\"\\n{'='*50}\")\nprint(f\"Fixing {performer_dir.name}\")\n\nbody_path = performer_dir / \"body_mesh.glb\"\nface_path = performer_dir / \"face_mesh_realistic.glb\"\n\nif not body_path.exists():\nprint(\"  No body mesh found\")", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def create_from_video", "output": "def create_from_video(self, video_path: str, config: CharacterConfig) -> Dict[str, Any]:\n\"\"\"Create a character from video input.\"\"\"\nvideo_path = Path(video_path)\n\n# Create character directory\nchar_dir = self.characters_dir / config.name\nchar_dir.mkdir(parents=True, exist_ok=True)\n\nprint(f\"\\n{'='*60}\")\nprint(f\"Creating character: {config.name}\")", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _prepare_unity_export", "output": "def _prepare_unity_export(self, name: str, config: Dict) -> Dict[str, str]:\n\"\"\"Prepare files for Unity import.\"\"\"\nexport_dir = self.exports_dir / \"unity\" / name\nexport_dir.mkdir(parents=True, exist_ok=True)\n\nexports = {}\n\n# Copy face mesh\nif config['face']['mesh']:\nsrc = Path(config['face']['mesh'])", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _ensure_model", "output": "def _ensure_model(self):\n\"\"\"Download model if not present.\"\"\"\nself.MODEL_PATH.parent.mkdir(parents=True, exist_ok=True)\nif not self.MODEL_PATH.exists():\nprint(f\"Downloading face landmarker model...\")\nurllib.request.urlretrieve(self.MODEL_URL, self.MODEL_PATH)\nprint(f\"Model saved to {self.MODEL_PATH}\")\n\ndef extract_from_frame(self, frame: np.ndarray, frame_idx: int) -> List[FaceData]:\n\"\"\"Extract face data from a single frame. Returns list for multi-face.\"\"\"", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def extract_from_frame", "output": "def extract_from_frame(self, frame: np.ndarray, frame_idx: int) -> List[FaceData]:\n\"\"\"Extract face data from a single frame. Returns list for multi-face.\"\"\"\nrgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\nh, w = frame.shape[:2]\n\n# Create MediaPipe Image\nmp_image = mp.Image(image_format=mp.ImageFormat.SRGB, data=rgb_frame)\n\n# Detect faces\nresult = self.detector.detect(mp_image)", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _compute_flame_landmarks", "output": "def _compute_flame_landmarks(self):\n\"\"\"Compute the 3D positions of 68 landmarks on FLAME template\"\"\"\nvertices = self.flame_template.vertices\nfaces = self.flame_template.faces\n\nlandmarks = []\nfor i in range(len(self.full_lmk_faces_idx)):\nface_idx = self.full_lmk_faces_idx[i]\nbary = self.full_lmk_bary_coords[i]\n", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def detect_landmarks", "output": "def detect_landmarks(self, image: np.ndarray):\n\"\"\"\nDetect 68 3D facial landmarks in an image\n\nReturns:\nlandmarks_2d: (68, 2) array of 2D pixel coordinates\nlandmarks_3d: (68, 3) array of 3D positions (x, y, depth)\n\"\"\"", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def process_frame", "output": "def process_frame(self, frame: np.ndarray, frame_idx: int) -> Optional[BodyFrame]:\n\"\"\"Process a single frame and extract body data.\"\"\"\nif self.pose_detector is None:\nreturn None\n\nrgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\nh, w = frame.shape[:2]\n\n# Use tasks API\nmp_image = mp.Image(image_format=mp.ImageFormat.SRGB, data=rgb)", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _calculate_pose_angles", "output": "def _calculate_pose_angles(self, landmarks: np.ndarray) -> Dict[str, float]:\n\"\"\"Calculate joint angles from landmarks.\"\"\"\nangles = {}\n\n# Helper to calculate angle between three points\ndef angle_3p(p1, p2, p3):\nv1 = p1 - p2\nv2 = p3 - p2\ncos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2) + 1e-6)\nreturn np.arccos(np.clip(cos_angle, -1, 1))", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_poses", "output": "def load_poses(self, pose_path: Path) -> np.ndarray:\n\"\"\"Load numpy pose data.\"\"\"\nreturn np.load(str(pose_path))\n\ndef poses_to_keyframes(self, poses: np.ndarray) -> List[AnimationKeyframe]:\n\"\"\"Convert MediaPipe poses to humanoid keyframes.\"\"\"", "source": "scripts"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def poses_to_keyframes", "output": "def poses_to_keyframes(self, poses: np.ndarray) -> List[AnimationKeyframe]:\n\"\"\"Convert MediaPipe poses to humanoid keyframes.\"\"\"\nkeyframes = []\n\nfor i, pose in enumerate(poses):\ntime = i / self.fps\n\nbone_transforms = {}\n\n# Calculate hip position (root)", "source": "scripts"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_phase5_policy_full_lifecycle", "output": "fn test_phase5_policy_full_lifecycle() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_phase5_multi_agent_coordination", "output": "fn test_phase5_multi_agent_coordination() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_phase5_policy_reject_workflow", "output": "fn test_phase5_policy_reject_workflow() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn validate_ssh_host", "output": "fn validate_ssh_host(host: &str) -> Result<(), String> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn validate_ssh_port", "output": "fn validate_ssh_port(port: u16) -> Result<(), String> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn validate_ssh_username", "output": "fn validate_ssh_username(username: &str) -> Result<(), String> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn create_test_context", "output": "fn create_test_context() -> HashMap<String, String> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn parse_tool_call", "output": "fn parse_tool_call(json: &str) -> Option<(String, serde_json::Value)> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn execute_tool", "output": "fn execute_tool(tool: &str, args: &serde_json::Value) -> Result<String, String> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn normalize_path", "output": "fn normalize_path(path: &str) -> Result<PathBuf, String> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_within_sandbox", "output": "fn is_within_sandbox(path: &Path, sandbox_root: &Path) -> bool {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn validate_path", "output": "fn validate_path(path: &str) -> Result<(), String> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_full_phase1_6_workflow", "output": "fn test_full_phase1_6_workflow() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_phase_integration_with_dependencies", "output": "fn test_phase_integration_with_dependencies() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_full_batch_workflow", "output": "fn test_full_batch_workflow() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new() -> Self {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn create_batch", "output": "fn create_batch(&self, commands: Vec<String>) -> u32 {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn approve_batch", "output": "fn approve_batch(&self, id: u32) -> Result<(), String> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_phase3_inproc_runner", "output": "fn test_phase3_inproc_runner() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_phase3_batch_dependencies", "output": "fn test_phase3_batch_dependencies() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn get_test_dir", "output": "fn get_test_dir() -> PathBuf {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn cleanup_test_dir", "output": "fn cleanup_test_dir(dir: &PathBuf) {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_disk_metrics_collection", "output": "fn test_disk_metrics_collection() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn wait_for_batch_completion", "output": "fn wait_for_batch_completion(", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_phase1_single_tool_execution", "output": "fn test_phase1_single_tool_execution() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_phase2_batch_workflow", "output": "fn test_phase2_batch_workflow() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new(base_path: &str) -> Self {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn serialize_session", "output": "fn serialize_session(session: &PersistedSession) -> Result<String, String> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn deserialize_session", "output": "fn deserialize_session(data: &str) -> Result<PersistedSession, String> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn new", "output": "fn new(id: u32, shell: &str, cwd: &str) -> Self {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn send_input", "output": "fn send_input(&mut self, data: &[u8]) -> Result<(), String> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn read_output", "output": "fn read_output(&mut self) -> Vec<u8> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_glob_files_finds_rust_files", "output": "fn test_glob_files_finds_rust_files() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_grep_files_finds_pattern", "output": "fn test_grep_files_finds_pattern() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_grep_files_with_regex", "output": "fn test_grep_files_with_regex() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_phase2_batch_creation", "output": "fn test_phase2_batch_creation() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_phase2_policy_engine", "output": "fn test_phase2_policy_engine() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn validate_command", "output": "fn validate_command(command: &str) -> Result<(), String> {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn sanitize_command", "output": "fn sanitize_command(command: &str) -> String {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn is_dangerous_command", "output": "fn is_dangerous_command(command: &str) -> bool {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_pty_spawns_successfully", "output": "fn test_pty_spawns_successfully() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_pty_executes_simple_command", "output": "fn test_pty_executes_simple_command() {", "source": "tests"}
{"instruction": "Write a Rust function.", "input": "Function: fn test_pty_handles_exit_codes", "output": "fn test_pty_handles_exit_codes() {", "source": "tests"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, model, config=None, device='cuda:0'):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, testpath='/ps/scratch/yfeng/Data/AFLW2000/GT', crop_size=224):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, K, image_size, scale, trans_scale = 0, dataname='vox2', n_train=100000, isTemporal=False, isEval=False, isSingle=False):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, K, image_size, scale, trans_scale = 0, isTemporal=False, isEval=False, isSingle=False):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, testpath, iscrop=True, crop_size=224, scale=1.25, face_detector='fan', sample_step=10):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, ring_elements=6, crop_size=224, scale=1.6):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, K, image_size, scale, trans_scale = 0, dataname='vox2', n_train=100000, isTemporal=False, isEval=False, isSingle=False):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, K, image_size, scale, trans_scale = 0, isTemporal=False, isEval=False, isSingle=False):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def get_cfg_defaults", "output": "def get_cfg_defaults():\n\"\"\"Get a yacs CfgNode object with default values for my_project.\"\"\"\n# Return a clone so that the defaults will not be altered\n# This is for the \"local variable\" use pattern\nreturn cfg.clone()\n\ndef update_cfg(cfg, cfg_file):\ncfg.merge_from_file(cfg_file)\nreturn cfg.clone()\n", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def upsample_mesh", "output": "def upsample_mesh(vertices, normals, faces, displacement_map, texture_map, dense_template):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def load_obj", "output": "def load_obj(obj_filename):\n\"\"\" Ref: https://github.com/facebookresearch/pytorch3d/blob/25c065e9dafa90163e7cec873dbb324a637c68b7/pytorch3d/io/obj_io.py\nLoad a mesh from a file-like object.\n\"\"\"", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, height, width=None):\n\"\"\"\nuse fixed raster_settings for rendering faces\n\"\"\"", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def forward", "output": "def forward(self, vertices, faces, attributes=None, h=None, w=None):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def rad2deg", "output": "def rad2deg(tensor):\n\"\"\"Function that converts angles from radians to degrees.\n\nSee :class:`~torchgeometry.RadToDeg` for details.\n\nArgs:\ntensor (Tensor): Tensor of arbitrary shape.\n\nReturns:\nTensor: Tensor with same shape as input.", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def deg2rad", "output": "def deg2rad(tensor):\n\"\"\"Function that converts angles from degrees to radians.\n\nSee :class:`~torchgeometry.DegToRad` for details.\n\nArgs:\ntensor (Tensor): Tensor of arbitrary shape.\n\nReturns:\nTensor: Tensor with same shape as input.", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def augment_bbox", "output": "def augment_bbox(center, bbox_size, scale=[1.0, 1.0], trans_scale=0.):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def crop_tensor", "output": "def crop_tensor(image, center, bbox_size, crop_size, interpolation = 'bilinear', align_corners=False):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def kl_loss", "output": "def kl_loss(texcode):\n\"\"\"\nrecon_x: generating images\nx: origin images\nmu: latent mean\nlogvar: latent log variance\n\"\"\"", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, model, config=None, device='cuda:0'):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def conv3x3", "output": "def conv3x3(in_planes, out_planes, stride=1):\n\"\"\"3x3 convolution with padding\"\"\"\nreturn nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride,\npadding=1, bias=False)\n\nclass BasicBlock(nn.Module):\nexpansion = 1\n\ndef __init__(self, inplanes, planes, stride=1, downsample=None):\nsuper(BasicBlock, self).__init__()", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, inplanes, planes, stride=1, downsample=None):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, latent_dim=100, out_channels=1, out_scale=0.01, sample_mode = 'bilinear'):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def find_dynamic_lmk_idx_and_bcoords", "output": "def find_dynamic_lmk_idx_and_bcoords(vertices, pose, dynamic_lmk_faces_idx,", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def vertices2landmarks", "output": "def vertices2landmarks(vertices, faces, lmk_faces_idx, lmk_bary_coords):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def __init__", "output": "def __init__(self, block, layers, num_classes=1000):", "source": "decalib"}
{"instruction": "Write a Python function with proper documentation.", "input": "Function signature: def _make_layer", "output": "def _make_layer(self, block, planes, blocks, stride=1):", "source": "decalib"}
